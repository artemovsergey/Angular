# Code Tweaks and Data Services

Наше веб-приложение WorldCities теперь представляет собой полноценный проект, предоставляющий ряд интересных
особенности: мы можем получить список всех городов и стран, доступных в нашей СУБД, и просмотреть их.
через страничные таблицы, которые мы можем упорядочивать и фильтровать; благодаря нашему шаблону пользовательского интерфейса «основной/детальный» мы также можем
доступ к подробному представлению каждого города и страны, где мы можем читать и/или редактировать наиболее важные поля
для них обоих; и последнее, но не менее важное: мы можем создавать новые города и страны благодаря функции «Добавить новые».
возможности вышеупомянутого подробного представления.
Теперь, прежде чем идти дальше, было бы разумно потратить некоторое время на закрепление того, что мы узнали, поэтому
далеко и улучшить базовые модели, которым мы следовали. В конце концов, совершенствование нашего внешнего и внутреннего интерфейса и
общая логика, на которую они сейчас полагаются, определенно сделает их более универсальными и безотказными.
ради того, что еще впереди.
Данная глава полностью посвящена этим задачам. Вот что мы собираемся делать с помощью различных
разделы, с которыми нам предстоит столкнуться:
- Оптимизации и настройки: мы реализуем некоторые высокоуровневые исходные коды и улучшения пользовательского интерфейса.
- Исправления ошибок и улучшения: мы будем использовать предыдущие настройки, чтобы улучшить работу нашего приложения.
согласованность и добавить некоторые новые функции
- Службы данных: мы узнаем, как перейти с текущей упрощенной реализации.
– где мы использовали необработанный сервис HttpClient непосредственно внутри компонентов – к более универсальному подходу, который позволяет нам добавлять такие функции, как постобработка, обработка ошибок, повторная попытка
логика и многое другое
Все эти изменения будут стоить потраченного на них времени, поскольку они улучшат исходный код нашего приложения и подготовят
это для этапа отладки и тестирования, который появится в следующей главе.
Хорошо, тогда... приступим к работе.

# Оптимизации и настройки
В компьютерном программировании термин «раздувание кода» обычно используется для описания излишне длинного,
медленный или расточительный объем исходного кода. Такой код вряд ли желателен, поскольку он неизбежно приводит к
наше приложение более уязвимо к человеческим ошибкам, ошибкам регрессии, логическим несоответствиям, напрасной трате ресурсов,
и так далее. Это также делает отладку и тестирование намного более трудными и напряженными; по всем вышеупомянутым причинам мы должны постараться предотвратить это, насколько это возможно.
Самый эффективный способ борьбы с раздуванием кода — принять и придерживаться принципа «Не повторяйся» (DRY).
Принцип, которому любой разработчик должен стараться следовать, когда может. Как уже
Как указано в главе 6 «Извлечение и отображение данных», DRY — это широко распространенный принцип разработки программного обеспечения: всякий раз, когда мы его нарушаем, мы впадаем в подход WET, что может означать «записать все».
Дважды мы наслаждаемся набором текста или тратим время всех впустую, в зависимости от того, что нам нравится больше всего.
В этом разделе мы попытаемся рассмотреть некоторые довольно WET-части нашего текущего кода и посмотрим, как мы можем
сделайте их более СУХИМИ: это очень поможет нашим сеансам отладки и тестирования в дальнейшем.

# Улучшения шаблона
Если мы еще раз посмотрим на файлы шаблонов CityEditComponent и CountryEditComponent, мы сможем
определенно увидите определенное раздувание кода. Точнее, у нас много элементов mat-error,
иногда их целых три (!) для одного входа – например, для ISO 3166-1 ALPHA-2.
и коды стран АЛЬФА-3; кроме того, большинство этих элементов являются избыточными, а это означает, что они
проверить один и тот же статус ошибки для разных входов и – при срабатывании – вернуть очень похожий текст ошибки.
Этот подход может иметь некоторые преимущества, особенно в малых формах: например, он обеспечивает хорошее
уровень читабельности, поскольку элементы мат-ошибок позволяют сразу понять, что происходит
за каждую конкретную ошибку. Однако, когда вы имеете дело с большими формами (или с приложением с большим количеством форм),
этот подход в конечном итоге приведет к созданию значительного объема исходного кода, который может стать
сложно поддерживать: это еще более верно для многоязычных приложений, где усилия, необходимые для обработки
литеральные строки растут экспоненциально с количеством строк. Что нам делать в таких случаях? Есть
«лучший» или «умный» способ решить эту проблему?
На самом деле так и есть: всякий раз, когда мы чувствуем, что пишем слишком много кода или повторяем сложную задачу,
задачу слишком много раз, мы можем создать один или несколько вспомогательных методов в нашем классе компонента, чтобы
централизовать основную логику. Эти вспомогательные методы будут действовать как ярлыки, которые мы можем вместо этого вызывать.
повторения всей логики проверки. Давайте попробуем добавить их в наши угловые компоненты, связанные с формой.

# Ярлыки проверки формы
Давайте посмотрим, как добавить ярлыки проверки формы в класс CountryEditComponent, которые в итоге оказались
с большим количеством избыточных элементов mat-error, так как нам приходилось проверять множество возможных статусов ошибок для
два кода страны по стандарту ISO 3166-1.
Откройте файл /src/app/countries/country-edit.comComponent.ts и добавьте следующий код справа
после объявления класса (новые строки выделены):

```ts
export class CountryEditComponent implements OnInit {
getErrors(
 control: AbstractControl,
 displayName: string,
 ): string[] {
 var errors: string[] = [];
 Object.keys(control.errors || {}).forEach((key) => {
 switch (key) {
 case 'required':
 errors.push('${displayName} is required.');
 break;
 case 'pattern':
 errors.push('${displayName} contains invalid characters.');
 break;
 case 'isDupeField':
 errors.push('${displayName} already exists: please choose another.');
 break;
 default:
 errors.push('${displayName} is invalid.');
 break;
 }
 });
 return errors;
}
```
Как мы видим, мы добавили простую функцию getErrors(), которая возвращает массив сообщений об ошибках, соответствующий всем активным ошибкам для любого данного элемента управления, или пустой массив, если их нет; эти ошибки
также будет добавлен параметр displayName, который может быть установлен вызывающей стороной, чтобы гарантировать, что
каждый элемент управления будет иметь собственный персонализированный набор сообщений об ошибках.

Созданный нами оператор switch содержит все валидаторы, которые мы в настоящее время используем и которые, возможно, захотим использовать.
централизовать, включая собственный валидатор isDupeField, который мы реализовали еще в главе 7 «Формы».
и проверка данных; мы даже включили случай по умолчанию, возвращающий общую ошибку, которая будет действовать как
универсальное средство для всех неподдерживаемых валидаторов.
Это именно то, что нам нужно: централизованный метод «ярлыка», который позволит нам сжимать HTML-код.
шаблон и, что наиболее важно, удалите некоторые элементы с матовыми ошибками и лишний литеральный текст.
Давайте посмотрим, как мы можем реорганизовать существующий компонент mat-form-field ISO2 в редакторе страны.
компонент.html, который в настоящее время содержит три элемента mat-error, чтобы воспользоваться преимуществами нашего
новая функция getErrors():

```html
<mat-form-field>
 <mat-label>
 ISO 3166-1 ALPHA-2 Country code (2 letters)
 </mat-label>
 <input matInput formControlName="iso2" required
 placeholder="Insert the ISO2 Country code">
 <mat-error *ngFor="let error of getErrors(form.get('iso2')!,
 'ISO 3166-1 ALPHA 2 Country code')">
 {{error}}
 </mat-error>
</mat-form-field>
```
Гораздо лучше, правда? Если мы протестируем компонент сейчас, мы увидим, что его поведение осталось прежним, то есть
что мы нашли способ оптимизировать шаблон, ничего не теряя.
Все, что нам нужно сделать сейчас, это реорганизовать все остальные компоненты mat-form-field в CountryEditComponent.
шаблон, затем переключитесь на CityEditComponent и проделайте там тот же трюк с оптимизацией…
... Или нет.
Подождите: разве мы только что не сказали, что будем придерживаться модели DRY настолько, насколько сможем? Как мы можем
разумно ожидать, что это произойдет, если мы собираемся скопировать и вставить одни и те же идентичные переменные и методы.
в разных классах? Что, если бы нам нужно было исправить 10 компонентов на основе форм вместо двух?
Это не звучит иначе, как ВЛАЖНО. Теперь, когда мы нашли хороший способ уменьшить код нашего шаблона,
нам также нужно найти достойный способ реализовать эти методы, связанные с формами, без создания клонов.
повсюду.
К счастью, TypeScript предоставляет отличный способ справиться с подобными сценариями: наследование классов.
Давайте посмотрим, как мы можем использовать эти функции в своих интересах.

# Наследование классов
Объектно-ориентированное программирование (ООП) обычно определяется двумя основными концепциями: полиморфизмом и наследованием. Хотя оба понятия связаны, они не одно и то же. Вот что они означают в двух словах:
- Полиморфизм позволяет нам назначать несколько интерфейсов одному и тому же объекту (например, переменной,
функция, объект или тип) и/или назначать один и тот же интерфейс разным объектам. Другими словами,
это позволяет сущностям иметь более одной формы.
- Наследование позволяет нам расширять объект или класс, производя его от другого объекта (наследование на основе прототипа) или класса (наследование на основе класса), сохраняя при этом аналогичную реализацию;
расширенный класс обычно называют подклассом или дочерним классом, тогда как унаследованный класс принимает
имя суперкласса или базового класса.
Давайте теперь сосредоточимся на наследовании: в TypeScript, как и в большинстве объектно-ориентированных языков на основе классов,
тип, созданный посредством наследования (дочерний класс), приобретает все свойства и поведение родительского класса
type, за исключением конструкторов, деструкторов, перегруженных операторов и частных членов базового класса.
Если подумать, это именно то, что нам нужно в нашем сценарии: если мы создадим базовый класс и реализуем все
наши методы, связанные с формой, нам просто нужно расширить наш текущий класс компонента, не
написать это более одного раза.
Давайте посмотрим, как мы можем это осуществить.

# Реализация компонента BaseFormComponent
Мы несколько раз использовали команду CLI nggenerate для создания компонентов, но командная строка
в первый раз мы собираемся использовать его для создания класса.
Откройте командную строку, перейдите в папку /src/app/ и введите следующую команду:

```
ng generate component BaseForm --skip-import --skip-tests --inline-template --inline-style --flat
```
Эти настройки не позволят Angular CLI создавать что-либо, кроме файла TypeScript.
поскольку компонент, который мы хотим сгенерировать, не нуждается в файлах HMTL, тестах и (S)CSS, а также не требует
требуется ссылка в AppModule: предыдущая команда просто создаст /src/app/
файл base-form.comComponent.ts и ничего больше.

Это также означает, что мы могли бы даже создать этот файл вручную вместо использования Angular.
CLI, если мы предпочтем это сделать.

После создания файла откройте его и замените существующее содержимое следующим кодом:

```ts
import { Component } from '@angular/core';
import { FormGroup, AbstractControl } from '@angular/forms';
@Component({
template: ''
})
export abstract class BaseFormComponent {
 // the form model
 form!: FormGroup;
 getErrors(
 control: AbstractControl,
 displayName: string,
 ): string[] {
 var errors: string[] = [];
 Object.keys(control.errors || {}).forEach((key) => {
 switch (key) {
 case 'required':
 errors.push('${displayName} is required.');
 break;
 case 'pattern':
 errors.push('${displayName} contains invalid characters.');
 break;
 case 'isDupeField':
 errors.push('${displayName} already exists: please choose another.');
 break;
 default:
 errors.push('${displayName} is invalid.');
 break;
 }
 });
 return errors;
 }
 constructor() { }
}
```

Как мы видим, там нет ничего особенного, только метод getError(), который мы видели недавно,
и сама переменная формы: эти два члена можно переместить (и централизовать) сюда вместо того, чтобы объявлять их в любом контроллере, который должен иметь дело с формой. Кроме того, мы намеренно добавили аннотацию
модификатор, поскольку мы не планируем когда-либо создавать экземпляр этого класса; мы только хотим, чтобы другие классы были производными от него.

С этого момента мы будем считать само собой разумеющимся, что у нас есть логика, лежащая в основе наших примеров кода;
следовательно, мы собираемся представить их более лаконично, чтобы не тратить больше
страницы, говоря очевидное: пожалуйста, терпите! В конце концов, всякий раз, когда нам нужно увидеть
полный файл, мы всегда можем найти его в онлайн-репозитории исходного кода книги на GitHub.

Теперь у нас есть суперкласс BaseFormComponent, который мы можем использовать для расширения наших подклассов; это означает
что мы можем обновить наши текущие файлы TypeScript CityEditComponent и CountryEditComponent в
чтобы соответствующим образом расширить свой класс.

# Расширение CountryEditComponent
Откройте файл /src/app/countries/country-edit.comComponent.ts, затем добавьте BaseFormComponent.
суперкласс из конца списка импорта в начало файла:

```
import { Country } from './country';
import { BaseFormComponent } from '../base-form.component';
```
Теперь нам нужно реализовать наследование классов, используя модификатор расширения, который находится сразу после
объявление класса:

```
export class CountryEditComponent
extends BaseFormComponent implements OnInit {
```

Вот и все: CountryEditComponent теперь официально стал дочерним классом BaseFormComponent.
суперкласс.
И последнее, но не менее важное: нам нужно вызвать конструктор суперкласса, вызвав super() внутри дочернего класса.
реализация конструктора:

```ts
constructor(
 private fb: FormBuilder,
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private http: HttpClient) {
 super();
```
Прежде чем закрыть файл TypeScript, мы должны воспользоваться возможностью удалить переменную формы, а также
метод getErrors(), поскольку мы решили централизовать их в суперклассе.
Теперь мы можем, наконец, провести рефакторинг остальных компонентов mat-form-field, включенных в
HTML-шаблон CountryEditComponent (имя и iso3) с использованием метода getErrors(), определенного в
базовый класс, поскольку наш дочерний класс прозрачно унаследует его от суперкласса.

Из соображений экономии места мы не показываем, как их реорганизовать: просто оставьте то, что мы сделали с
поле iso2 на ранней стадии для справки, изменив параметры form.get и displayName
соответственно, или посмотрите код GitHub для этой главы, чтобы получить полностью обновленный исходный код.

Давайте теперь проверим, что мы сделали, нажав F5 и перейдя по CountryEditComponent в обоих
редактировать и добавлять новые режимы. Если мы все сделали правильно, проблем не должно быть: все должно
работать так же, как и раньше, со значительно меньшим объемом исходного кода.

При выполнении теста обязательно проверьте все валидаторы, так как то, что мы сделали, влияет на них больше всего: работают ли еще валидаторы форм и показывают ли свои ошибки при
срабатывает, это означает, что дочерний класс может наследовать и использовать требуемый метод
для своего базового класса, тем самым доказывая, что наша совершенно новая реализация суперкласса/подкласса
работает нормально.

Как только мы убедимся, что все работает нормально, мы наконец можем переключиться на CityEditComponent.
и выполните там ту же настройку оптимизации.

# Расширение CityEditComponent
CityEditComponent можно расширить так же, как мы это сделали с файлом TypeScript для CountryEditComponent:
добавление оператора импорта для класса BaseFormComponent с использованием ключевого слова Extensions в классе
объявление и, наконец, добавление функции super() в конструктор.

Мы не собираемся показывать здесь изменения исходного кода, поскольку необходимые шаги
почти идентично тому, что мы только что видели; если у вас есть какие-либо сомнения, вы можете обратиться к этому
исходный код главы в репозитории GitHub.

Как только это будет сделано, мы сможем удалить теперь уже лишнюю переменную формы, точно так же, как мы это сделали с
Класс CountryEditComponent минуту назад.

Сразу после этого мы можем перейти к HTML-шаблону CityEditComponent и провести рефакторинг всех компонентов поля matform, чтобы каждый из них имел один элемент mat-error, используя метод
метод getErrors().
В конце концов, единственный элемент mat-error, который не будет затронут нашей задачей рефакторинга, будет
быть тем, который вызывается валидатором isDupeCity (первый в порядке появления); по сути
на самом деле, централизовать этот код не имеет особого смысла, так как мы вряд ли когда-нибудь будем (повторно)использовать его за пределами
CityEditComponent.

Это прекрасный пример контекстно-зависимого, одноразового кода, который следует просто сохранить.
там, поскольку перемещение его в суперкласс не сделает нашу кодовую базу более сухой.

Теперь, когда мы оптимизировали и реорганизовали код TypeScript и HTML наших компонентов, давайте посмотрим, что
мы можем сделать, чтобы улучшить взаимодействие с пользователем нашего приложения.

# Исправления ошибок и улучшения
Давайте будем честными: хотя мы и проделали достойную работу по созданию шаблона основного/детального пользовательского интерфейса, и мы
собрал оба представления, используя наиболее подходящие поля города и страны, нашему приложению все еще чего-то не хватает.
которые наши пользователи, возможно, захотят увидеть. В частности, отсутствуют следующие детали:
- В нашем представлении «Подробности города» неправильно проверяются входные значения широты и долготы. Например, мы
разрешено вводить буквы вместо цифр, что приводит к полному сбою формы
- В представлении "Наши страны" не показано количество городов, которые на самом деле есть в каждой стране.
- В представлении "Города" не отображается название страны для каждого города в списке.
Давайте сделаем все возможное, чтобы исправить все эти проблемы навсегда.

# Проверка широты и долготы
Начнем с единственной реальной ошибки: форма, которую можно взломать из внешнего интерфейса, — это то, что мы
всегда следует избегать, даже если эти типы ввода неявно проверяются в серверной части нашим ASP.NET.
Основной API.
К счастью, мы уже знаем, как исправить подобные ошибки: нам нужно добавить некоторые основанные на шаблонах
валидаторы для lat и lon FormControls для CityEditComponent, как мы это делали с iso2.
и элементы управления iso3 в файлах CountryEditComponent. Как мы уже знаем, нам нужно будет обновить
Файл класса CityEditComponent для реализации валидаторов и определения шаблона проверки на основе
по регулярному выражению.

# city-edit.component.ts

Откройте файл /src/app/cities/city-edit.comComponent.ts и соответствующим образом обновите его содержимое (новый/
обновленные строки выделены):

```ts
ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl('', Validators.required),
 lat: new FormControl('', [
 Validators.required,
 Validators.pattern(/^[-]?[0-9]+(\.[0-9]{1,4})?$/)
 ]),
 lon: new FormControl('', [
 Validators.required,
 Validators.pattern(/^[-]?[0-9]+(\.[0-9]{1,4})?$/)
 ]),
 countryId: new FormControl('', Validators.required)
 }, null, this.isDupeCity());
 this.loadData();
 }
```

Вот так. Как мы уже знаем из главы 7 «Формы и проверка данных», реализация этой формы по-прежнему основана на созданных вручную объектах FormGroup и FormControl вместо использования
Формбилдер; однако сейчас нет смысла менять его, поскольку мы еще смогли реализовать
Validators.pattern без проблем.
Давайте потратим пару минут на объяснение регулярного выражения, которое мы там использовали:
- ^ определяет начало строки пользовательского ввода, которую нам нужно проверить.
- [-]? допускает наличие необязательного знака минус, который необходим при работе с
отрицательные координаты
- [0–9]+ запрашивает одно или несколько чисел от 0 до 9.
- (\.[0-9]{1,4})? определяет необязательную группу (благодаря ? в конце), которая, если она присутствует, требует
соблюдать следующие правила:
- \.: требует, чтобы ввод начинался с одной точки (десятичного знака). Точка экранирована
потому что это зарезервированный символ регулярного выражения, который, если его не экранировать, означает любой символ.
- [0-9]{1,4} запрашивает от одного до четырех чисел от 0 до 9 (так как нам нужно от 1
и 4 десятичных значения после точки).
- $ определяет конец строки пользовательского ввода.

Мы могли бы использовать \d (любую цифру) в качестве альтернативы [0-9], что немного более лаконично.
синтаксис; однако мы решили оставить [0-9] для лучшей читаемости. Не стесняйся
замените его на \d в любое время.

Теперь, когда валидаторы шаблонов установлены, все должно работать автоматически:
соответствующее сообщение об ошибке уже будет обработано нашей централизованной функцией getError(), которая
уже содержит правильное сообщение, которое возвращается, когда валидатор шаблонов выдает ошибку.
Тем не менее, сообщение все еще довольно общее:

```
{displayName} contains invalid characters.
```
Это предупреждение сообщит нашим пользователям о том, что они ввели что-то неправильно, но это
не скажет им, какие символы им следует использовать вместо этого. Что, если мы хотим предоставить им эти
дополнительные детали? Вряд ли мы сможем это исправить, просто переписав его, так как это сообщение используется для ISO2
и ISO3, для которых требуются только буквы, а также для LAT и LON, которым нужны только цифры.
По сути, у нас есть только два варианта:
- Избегайте использования централизованной функции getError() для этих полей и вместо этого используйте некоторые элементы ошибок вручную.
- Улучшите централизованную функцию getError(), чтобы она могла (необязательно) принимать пользовательские сообщения.
для одного (или нескольких) типов ошибок валидатора
Оба подхода жизнеспособны. Однако, поскольку мы не хотим отказываться от только что проделанной тяжелой работы, мы
с таким же успехом можно выбрать последнее и улучшить наш метод getError().
К счастью, это будет не сложно.

# base-form.component.ts

Откройте файл /src/app/base-form.comComponent.ts и измените существующий код getError().
функционировать следующим образом (обновленный код выделен):

```ts
getErrors(
 control: AbstractControl,
 displayName: string,
 customMessages: { [key: string] : string } | null = null
): string[] {
 var errors: string[] = [];
 Object.keys(control.errors || {}).forEach((key) => {
 switch (key) {
 case 'required':
errors.push('${displayName} ${customMessages?.[key] ?? "is
required."}');
 break;
 case 'pattern':
 errors.push('${displayName} ${customMessages?.[key] ?? "contains
invalid characters."}');
 break;
 case 'isDupeField':
 errors.push('${displayName} ${customMessages?.[key] ?? "already exists:
please choose another."}');
 break;
 default:
 errors.push('${displayName} is invalid.');
 break;
 }
 });
 return errors;
}
```
Вот так. Как мы видим, мы добавили необязательный третий параметр, который теперь можем использовать для указания
необязательные customMessages всякий раз, когда мы не хотим использовать общее сообщение, и мы можем сделать это для
любой валидатор, а не только шаблонный.

Стоит отметить, что, поскольку новый параметр customMessages является необязательным,
Рефакторинг getErrors(), который мы только что провели, обратно совместим, а это означает, что наш существующий код по-прежнему будет работать – даже если мы не реализуем новую функцию ни в одном из наших проектов.
HTML-шаблоны.

Давайте посмотрим, как мы можем реализовать новую функцию, начиная с файла HTML-шаблона
CityEditComponent.

# city-edit.component.html

Откройте файл /src/app/cities/city-edit.comComponent.html и измените существующую реализацию.
для полей LAT и LON следующим образом (обновления выделены):

```html
<mat-form-field>
 <mat-label>Latitude:</mat-label>
 <input matInput formControlName="lat" required
 placeholder="Insert latitude">
 <mat-error *ngFor="let error of getErrors(form.get('lat')!,
 'Latitude',
 { 'pattern' : 'requires a positive or negative number with 0-4 decimal
values' })">
 {{error}}
 </mat-error>
</mat-form-field>
<!--Lon -->
<mat-form-field>
 <mat-label>Longitude:</mat-label>
 <input matInput formControlName="lon" required
 placeholder="Insert longitude">
 <mat-error *ngFor="let error of getErrors(form.get('lon')!,
 'Longitude',
 { 'pattern' : 'requires a positive or negative number with 0-4 decimal
values' })">
 {{error}}
 </mat-error>
</mat-form-field>
```
Как только это будет сделано, сделайте то же самое в полях ISO2 и ISO3 файла /src/app/country-edit.comComponent.
html, используя немного другое сообщение об ошибке для ISO2:

```
{ 'pattern' : 'requires 2 letters' }
```
… И для ISO3:

```
{ 'pattern' : 'requires 3 letters' }
```
Давайте быстро проверим, что мы уже сделали:
1. Нажмите F5, чтобы запустить приложение в режиме отладки.
2. Навигация по представлению «Города».
3. Отфильтруйте список, чтобы найти Мадрид.
4. Введите несколько недопустимых символов в поля ввода «Широта города» и «Долгота города».

Если новая функция реализована правильно, мы должны увидеть сообщения об ошибках во всех
их слава и кнопка «Сохранить» отключена, как на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/0abdce85-452c-4d0f-bffd-e73d8e797e9c)

Вот и все. Теперь мы можем повторить тот же тест для CountryEditController, чтобы убедиться, что все работает.
работаю и там.
Теперь, когда мы исправили нашу первую ошибку пользовательского интерфейса, давайте перейдем к следующей задаче.

# Добавляем количество городов
Теперь нам нужно найти способ отобразить дополнительный столбец в представлении «Страны», который будет
позволяют пользователям мгновенно видеть количество городов для каждой указанной страны. Для этого мы обязательно
необходимо улучшить наш серверный веб-API, поскольку мы знаем, что в настоящее время невозможно получить такие
информация с сервера.
Ну, технически говоря, есть способ: мы могли бы использовать метод GetCities() класса CitiesController.
с огромным параметром pageSize (99 999 или около того) и подходящим фильтром для получения всего набора городов
для каждой страны, а затем подсчитайте эту коллекцию и выведите число.
Однако это действительно окажет огромное влияние на производительность: нам придется не только извлекать
все города для всех перечисленных стран, но нам придется сделать это, выдав отдельный HTTP-запрос
для каждой строки таблицы. Это определенно не то, чего мы хотим, если хотим разумно и эффективно выполнить нашу задачу.
эффективно

Вот что мы собираемся сделать вместо этого:
- Найдите умный и эффективный способ подсчитать количество городов для каждой страны из списка.
серверная часть
- Добавьте свойство TotCities в наш интерфейс Country Angular, чтобы сохранить тот же номер в
клиент
Давай сделаем это.

# CountriesController
Начнем с задней части. Найти умный и эффективный способ подсчитать количество городов для
в каждой стране может быть сложнее, чем кажется.
Если мы хотим получить это значение за один раз, то есть без дополнительных запросов API
с Angular нет сомнений в том, что нам необходимо улучшить наш текущий метод GetCountries()
CountriesController — то, что мы сейчас используем для получения данных о странах.
Давайте откроем наш файл /Controllers/CountriesController.cs и посмотрим, как ASP.NET Core и Entity
Framework Core (EF Core) может помочь нам делать то, что мы хотим.
Вот метод GetCountries(), который нам нужно обновить:

```Csharp
public async Task<ActionResult<ApiResult<Country>>> GetCountries(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<Country>.CreateAsync(
 _context.Countries.AsNoTracking(),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
}
```
Как мы видим, от Городов не осталось и следа. Хотя мы знаем, что наша сущность Country содержит Cities
свойство, предназначенное для хранения списка городов, мы также помним (из Главы 5, Модель данных с Entity
Framework Core), что для этого свойства установлено значение null, поскольку мы никогда не указывали EF Core загружать
соответствующие данные.

Что, если мы сделаем это сейчас? У нас может возникнуть соблазн решить нашу проблему, активировав шаблон ORM «Стремительная загрузка» (как описано в главе 5 «Модель данных с Entity Framework Core») и заполнив свойство Cities.
с фактическими значениями, которые можно передать нашему клиенту Angular. Вот как мы могли бы это сделать:

```Csharp
return await ApiResult<Country>.CreateAsync(
 _context.Countries.AsNoTracking()
 .Include(c => c.Cities),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
```
Однако не нужно быть гением, чтобы понять, что такой обходной путь вряд ли будет умным и эффективным:
в стране может быть множество городов, а иногда и сотни. Неужели мы действительно думаем, что это будет
приемлемо ли для нашей серверной части получение их всех из СУБД? Неужели мы действительно собираемся затопить наши
Интерфейс Angular с огромными массивами JSON?
Это определенно бесполезно: мы можем добиться большего, особенно если учесть, что нам, в конце концов, не нужно
чтобы получить все данные о городах для каждой страны для достижения нашей цели: нам просто нужно знать количество городов.
Вот как мы можем это сделать (обновленный код выделен):

```Csharp
[HttpGet]
public async Task<ActionResult<ApiResult<CountryDTO>>> GetCountries(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<CountryDTO>.CreateAsync(
 _context.Countries.AsNoTracking()
 .Select(c => new CountryDTO()
 {
 Id = c.Id,
 Name = c.Name,
 ISO2 = c.ISO2,
 ISO3 = c.ISO3,
 TotCities = c.Cities!.Count
 }),
 pageIndex,
 pageSize,
sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
}
```
Как мы видим, мы выбрали совершенно другой подход: метод Include() исключен; сейчас,
вместо того, чтобы активно загружать города, мы используем метод Select() для проецирования полученных стран.
в совершенно новый объект CountryDTO, который содержит точно такие же свойства, что и его источник, плюс новый
Переменная TotCities. Таким образом, мы никогда не получим городов; мы получаем только их номер.

Также стоит отметить, что, поскольку мы заменили наш класс Countryentity на новый CountryDTO
класс, нам пришлось изменить общий тип ApiResult (с ApiResult<Country> на
ApiResult<CountryDTO>) в типе возвращаемого значения метода.

Хотя этот метод немного сложнее реализовать, это, безусловно, разумный и эффективный способ борьбы с
с нашей задачей; Единственным недостатком является то, что нам нужно создать класс CountryDTO, которого пока не существует.

# Создание класса CountryDTO
В обозревателе решений щелкните правой кнопкой мыши папку /Data/, затем добавьте новый файл CountryDTO.cs, откройте его,
и заполните его следующим содержимым:

```Csharp
using System.Text.Json.Serialization;
namespace WorldCitiesAPI.Data
{
 public class CountryDTO
 {
 #region Properties
 public int Id { get; set; }
 public string Name { get; set; } = null!;
 [JsonPropertyName("iso2")]
 public string ISO2 { get; set; } = null!;
 [JsonPropertyName("iso3")]
 public string ISO3 { get; set; } = null!;
 public int? TotCities { get; set; } = null!;
 #endregion
 }
}
```
Как мы видим, класс CountryDTO содержит большинство свойств, которые уже предоставлены классом CountryDTO.
Класс сущности Country без свойства Cities (которое, как мы знаем, нам здесь не понадобится) и с одним
дополнительное свойство TotCities: это класс Data Transfer Object (DTO), который служит только этой цели.
предоставления клиенту (только) данных, которые нам нужно отправить.

Как следует из названия, DTO — это объект, который передает данные между процессами. Это широко
используемая концепция при разработке веб-сервисов и микросервисов, где каждый HTTP-вызов
это дорогостоящая операция, которую всегда следует сокращать до минимального количества
Необходимые данные.
Разница между DTO и бизнес-объектами и/или объектами доступа к данным (такими как
DataSets, DataTables, DataRows, IQueryables и Entities) заключается в том, что DTO должен хранить только
сериализовать и десериализовать свои собственные данные.

Стоит отметить, что здесь нам также пришлось использовать атрибуты [JsonPropertyName], поскольку этот класс
будут преобразованы в JSON, а свойства ISO2 и ISO3 не будут преобразованы так, как мы
ожидать (как мы видели в главе 6 «Извлечение и отображение данных»).

# Обновления интерфейса Angular
Пришло время переключиться на Angular и соответствующим образом обновить интерфейс, применив новые изменения к
задняя часть.
Следуй этим шагам:
1. Откройте файл /src/app/countries/country.ts, чтобы добавить свойство TotCities к стране.
интерфейс следующим образом:

```ts
export interface Country {
 id: number;
 name: string;
 iso2: string;
 iso3: string;
 totCities: number;
}
```
2. Сразу после этого откройте файл /src/app/countries/countries.comComponent.ts и обновите
Внутренняя переменная displayColumns следующим образом:

```ts
public displayedColumns: string[] = ['id', 'name', 'iso2',
'iso3', 'totCities'];
```
3. После этого откройте файл /src/app/countries/countries.comComponent.html и добавьте
TotCities в шаблон MatTable Angular Material следующим образом (обновлено
строки выделены):

```html
<ng-container matColumnDef="iso3">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>ISO 3</th>
 <td mat-cell *matCellDef="let country"> {{country.iso3}} </td>
</ng-container>
<!-- TotCities Column -->
<ng-container matColumnDef="totCities">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Tot. Cities</th>
 <td mat-cell *matCellDef="let country"> {{country.totCities}} </td>
</ng-container>
```

4. Теперь мы наконец можем нажать F5 и увидеть результаты нашей тяжелой работы. Если мы все сделали правильно,
мы сможем увидеть нового Тота. Столбец «Города», как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5d4e1288-0181-489b-b976-2be1011fae17)

Совсем неплохо: кроме того, новый столбец также будет сортируемым, а это значит, что мы сможем упорядочить наши
страны по количеству перечисленных городов в порядке возрастания или убывания в один-два клика. Спасибо
благодаря этой новой функции мы можем узнать, что Соединенные Штаты являются страной, в которой больше всего городов в списке.
(7824), а Новая Япония, воображаемая страна, которую мы создали еще в главе 7 «Формы и данные»,
Проверка, все еще имеет ноль.
Раз уж мы здесь, давайте быстро исправим это, перейдя в представление «Города», используя его для редактирования «Нового Токио», и
сменил свою страну на Новую Японию.
Нажав кнопку «Сохранить», чтобы применить изменения, перейдите в представление «Страны» и найдите «Новая Япония»: теперь в этой стране должен отображаться один город в списке «Всего». Столбец «Города», как показано ниже.
Скриншот:

![image](https://github.com/artemovsergey/Angular/assets/26972859/61d94946-ca81-4ba1-bcd9-0cfbe3f1da7d)

Теперь, когда мы успешно показали количество городов для каждой страны в представлении «Страны» —
и связали Новую Японию с Новым Токио в процессе – мы готовы перейти к третьему
улучшение.
Однако, прежде чем сделать это, было бы полезно потратить некоторое время на размышления о том классе DTO, который
нам пришлось творить, чтобы выполнить нашу последнюю задачу.

# Классы DTO – стоит ли нам их использовать?
Теперь, когда мы увидели, насколько на самом деле похожи класс сущности Country и класс CountryDTO, мы
должны спросить себя, можем ли мы сделать что-то лучше этого. Например, мы могли бы
наследовать класс сущности Country в классе CountryDTO, тем самым предотвращая повторение четырех свойств; или мы могли бы полностью опустить класс CountryDTO и просто добавить свойство TotCities в
Вместо этого субъект страны.

Что ж, ответ — да: мы определенно могли бы использовать эти обходные пути, тем самым избежав необходимости
для создания дополнительных свойств (или классов) и сохранения кода, несомненно, более СУХИМ. Почему не
мы это делаем?
Ответ довольно прост: поскольку оба предыдущих обходных пути имеют некоторые соответствующие
недостатки конструкции и безопасности. Давайте сделаем все возможное, чтобы решить их и понять, почему они должны быть
избегаем, когда можем.

# Разделение интересов
Как правило, классы сущностей не должны быть обременены свойствами, которые существуют только для выполнения
наши потребности на стороне клиента: всякий раз, когда нам нужно их создать, разумно создать промежуточный класс и
затем отделите сущность от выходного объекта, который мы отправляем клиенту через веб-API.

Если вы работали с инфраструктурой ASP.NET MVC, вы можете понять это разделение
проблемы с тем, что отличает Модель от ViewModel в шаблоне представления Model-View-ViewModel (MVVM). Сценарий в основном тот же: оба
— это простые классы с атрибутами, но у них разная аудитория — контроллер
и вид. В нашем сценарии представление — это наш клиент Angular.

Само собой разумеется, что размещение свойства TotCities внутри класса сущности нарушит это правило.
разделение забот. В нашей таблице базы данных «Страны» нет столбца TotCities; это свойство
будет нужен только для отправки некоторых дополнительных данных во внешний интерфейс.
Кроме того, не будет никаких связей между свойством TotCities и уже существующим
Свойство Cities: если мы активируем шаблон загрузки EF Core Eager и заполним свойство Cities,
Свойству TotCities по-прежнему будет присвоено нулевое значение (и наоборот); такое вводящее в заблуждение поведение было бы плохим
выбор дизайна и может даже привести к ошибкам реализации для тех, кто разумно ожидает, что наша
классы сущностей будут версией C# нашего источника данных.

# Соображения безопасности
Хранение классов сущностей отдельно от классов вывода API на стороне клиента часто является хорошим выбором, даже для
целях безопасности. Теперь, когда мы имеем дело с городами и странами, мы от этого особо не страдаем, но
что, если бы нам пришлось обрабатывать таблицу пользователей с личными данными и/или данными для входа? Если мы об этом подумаем, то есть
множество возможных сценариев, в которых было бы неразумно просто вытащить все поля из базы данных и отправить
их клиенту в формате JSON. Методы по умолчанию, созданные контроллерами веб-API ASP.NET Core.
когда мы добавляем их из интерфейса Visual Studio — именно это мы и делали в главе 5 «Модель данных».
с Entity Framework Core — не беспокойтесь об этом, что отлично подходит для примеров кода и даже
простые проекты на основе API. Однако, когда ситуация становится более сложной, рекомендуется кормить
клиенту с ограниченными данными и контролируемым образом.
Тем не менее, наиболее эффективный способ сделать это в .NET — создать и обслуживать более тонкие и безопасные
Классы DTO вместо основных Entities: именно это мы и сделали с классом CountryDTO.
в предыдущих разделах.

# Классы DTO против анонимных типов
Единственной приемлемой альтернативой вышеупомянутым классам DTO будет использование метода Select().
проецировать основные классы сущностей на анонимные типы и вместо этого обслуживать их.
Вот еще одна версия предыдущего метода GetCountries() класса CountryController, использующая
анонимный тип вместо класса CountryDTO (соответствующие изменения выделены в следующем коде):

```Csharp
[HttpGet]
public async Task<ActionResult<ApiResult<object>>> GetCountries(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<object>.CreateAsync(
 _context.Countries.AsNoTracking()
 .Select(c => new
 {
 id = c.Id,
 name = c.Name,
 iso2 = c.ISO2,
 iso3 = c.ISO3,
 totCities = c.Cities!.Count
 }),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
}
```

Как и ожидалось, нам пришлось изменить общий тип ApiResult на объект в коде, а также в
возвращаемое значение метода; кроме этого, предыдущий метод кажется хорошим, и он определенно будет
работать так же, как предыдущий.

Что же нам тогда использовать? Классы DTO или анонимные типы?
По правде говоря, оба метода вполне хороши. Анонимные типы часто могут быть отличным вариантом, особенно
когда нам нужно быстро определить типы возвращаемых данных JSON; однако существуют некоторые конкретные сценарии (например,
как модульное тестирование, как мы увидим позже), где мы предпочли бы вместо этого иметь дело с именованными типами.
Выбор, как всегда, зависит от ситуации. В нашем текущем сценарии мы будем придерживаться CountryDTO.
class, но в ближайшем будущем мы собираемся использовать и анонимные типы.

# Обеспечивающие организации
Если мы не хотим использовать классы DTO, а анонимные типы не для нас, есть третий возможный вариант.
альтернатива, которую мы могли бы рассмотреть: обеспечение безопасности наших объектов, чтобы они не давали
неправильные инструкции (например, создание неправильных столбцов) для EF Core или отправка слишком большого количества данных через
наши RESTful API. Если нам удастся это сделать, мы могли бы просто продолжать использовать их и сохранить наш веб-API.
код DRY.
Мы можем добиться этого результата, украсив свойства наших объектов некоторыми конкретными аннотациями данных.
атрибуты, такие как следующие:
- [NotMapped]: запрещает EF Core создавать столбец базы данных для этого свойства.
- [JsonIgnore]: предотвращает сериализацию или десериализацию свойства.
- [JsonPropertyName("name")]: позволяет переопределить имя свойства в классе JSON.
сериализация и десериализация, переопределение имени свойства и любой политики именования, которая
указанный настройками JsonNamingPolicy в файле Program.cs
Для первого атрибута требуется пространство имен Microsoft.EntityFrameworkCore, а для остальных
часть пространства имен System.Text.Json.Serialization.
Мы уже использовали атрибут [JsonPropertyName] в главе 6 «Извлечение и отображение данных».
где нам пришлось указать имя свойства JSON для свойств ISO2 и ISO3 сущности Country.
Давайте теперь реализуем и два других.

# Атрибуты [NotMapped] и [JsonIgnore]
Откройте файл /Data/Models/Country.cs и обновите существующий код в конце файла следующим образом.
(новые/обновленные строки выделены):

```Csharp
#region Client-side properties
/// <summary>
/// The number of cities related to this country.
/// </summary>
[NotMapped]
public int TotCities
{
 get
 {
 return (Cities != null)
? Cities.Count
 : _TotCities;
 }
 set { _TotCities = value; }
}
private int _TotCities = 0;
#endregion
#region Navigation Properties
/// <summary>
/// A list containing all the cities related to this country.
/// </summary>
[JsonIgnore]
public ICollection<City>? Cities { get; set; } = null!;
#endregion
```

Вот что мы сделали, в двух словах:
- Мы реализовали свойство TotCities в коде Entity и украсили его
[NotMapped], чтобы EF Core не создавал соответствующий столбец базы данных при
любая задача миграции и/или обновления.
- Пока мы были там, мы воспользовались возможностью написать дополнительную логику, чтобы связать это свойство с
значение свойства Cities (только если оно не равно нулю). Таким образом, наша Сущность не будет вводить в заблуждение.
информацию, например наличие более 20 городов в свойстве списка Cities и нулевое значение TotCities в
в то же время.
- И последнее, но не менее важное: мы добавили атрибут [JsonIgnore] в свойства Cities, тем самым предотвращая отправку этой информации клиенту (независимо от его значения, даже если оно равно нулю).

Атрибут [NotMapped], который мы никогда раньше не использовали, помогает смягчить тот факт, что
мы используем сущность для хранения свойств, которые требуются интерфейсу, и
поэтому совершенно не связан с моделью данных. Короче говоря, этот атрибут сообщит EF
Я хочу сказать, что мы не хотим создавать столбец базы данных для этого свойства в базе данных.
Поскольку мы создали нашу базу данных с использованием подхода EF Core «сначала код» (см. главу 5, Данные
Модель с Entity Framework Core), и мы используем миграции для обновления структуры базы данных, нам нужно использовать этот атрибут каждый раз, когда мы хотим создать дополнительный
свойство наших классов сущностей. Всякий раз, когда мы забудем это сделать, мы обязательно окажемся
с нежелательными полями базы данных.

Использование [JsonIgnore] для предотвращения отправки сервером свойства Cities может показаться похожим на
overkill: зачем нам вообще пропускать это значение, если оно сейчас равно нулю?

На самом деле, мы приняли это решение в качестве меры предосторожности. Поскольку мы используем сущности напрямую, вместо этого
полагаться на классы DTO или анонимные типы, мы хотим реализовать ограничительный подход с помощью наших
данные. Всякий раз, когда нам это не нужно, разумно применить [JsonIgnore], чтобы быть уверенными, что мы не раскроем информацию.
что-то большее, чем нам нужно; мы могли бы назвать это подходом «Защита данных по умолчанию», который
мы надеемся, что это поможет нам держать наш веб-API под контролем и не допускать его слишком большого распространения. После всего,
мы всегда можем удалить этот атрибут, когда нам понадобится.
Само собой разумеется, что если мы хотим принять подход Secured Entities, нам не понадобится
Класс CountryDTO.cs больше; следовательно, мы могли бы отменить изменения, которые мы недавно внесли в /
Метод GetCountries() файла Controllers/CountriesController.cs и поместите ссылку на страну.
туда, где это было:

```Csharp
return await ApiResult<Country>.CreateAsync(
 _context.Countries.AsNoTracking()
 .Include(c => c.Cities)
 .Select(c => new Country()
 {
 Id = c.Id,
 Name = c.Name,
 ISO2 = c.ISO2,
 ISO3 = c.ISO3,
 TotCities = c.Cities!.Count
 }),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);

```

Однако прежде чем делать все это, нам следует потратить пару минут на тщательную оценку недостатков этого подхода с обеспечением безопасности.

# Недостатки швейцарских армейских ножей
Подход Security Entities, который мы только что обсудили, может звучать как действительная альтернатива DTO: он
дает нам возможность писать меньше кода за счет «сжатия» всей логики внутри класса сущности, что
стать «мастером на все руки». Но действительно ли это так хорошо, как кажется?
К сожалению, ответ — нет. Хотя этот метод будет работать, он подвергает нашу кодовую базу нескольким
недостатки, которых нам следует избегать.

Вот список причин, которые должны заставить нас избегать этого метода:
- Классы сущностей предназначены для использования в качестве оболочек объектов для таблиц и представлений базы данных; непосредственно используя их
«настройка» вывода данных JSON для нашего клиентского приложения нарушит единую ответственность
Принцип (SRP), который гласит, что каждый модуль, класс или функция в компьютерной программе
должен нести ответственность за одну часть функциональности этой программы.
- Сущности могут содержать много данных, которые пользователь и/или клиентское приложение никогда не смогут получить.
для просмотра, например хеши паролей и личные данные. Скрытие этих свойств с помощью [JsonIgnore]
атрибуты будут постоянно заставлять разработчика чрезмерно усложнять исходный код, что
в конечном итоге приведет к запутанной кодовой базе.
- Классы сущностей, вероятно, будут развиваться с течением времени. Например, в таблице базы данных они
предназначены для «обертывания» изменений; все разработчики, работающие над проектом, должны быть осведомлены о
тот факт, что все новые свойства будут обслуживаться ответом API, если только они не «защищены» должным образом:
отсутствие одного атрибута [JsonIgnore] может привести к опасной утечке.
- И последнее, но не менее важное: заполнение поля TotCities заставило нас загрузить все свойство Cities.
используя метод Include(c => c.Cities), что означает передачу большого количества данных из
СУБД на серверную часть. Такое поведение, известное как чрезмерная выборка, может оказать значительное влияние на производительность, широко считается плохой практикой, и поэтому его следует избегать любой ценой.
Учитывая все это, этот подход в конечном итоге приведет к потенциальной утечке данных нашей базы данных из-за
повышенная вероятность ошибок разработчика, единственное реальное преимущество — меньшее количество (полезных)
классы, с которыми нужно иметь дело. Стоит ли оно того?
Честно говоря, мы так не думаем: нам нужны не несколько швейцарских армейских ножей, а несколько хорошо сделанных и читаемых
классы, которые могут решать необходимые задачи наилучшим (и наиболее эффективным) способом.

Швейцарский армейский нож, иногда также известный как кухонная раковина, — это имя, которое большинство разработчиков дают чрезмерно сложным интерфейсам классов, явно предназначенным для удовлетворения всех возможных требований.
потребности; этот подход часто чрезмерно усложняет вещи вместо того, чтобы упростить их, что приводит к прекращению
в тщетной попытке, которая сводит на нет большую часть их предпосылок. Именно по этой причине почти
всегда считалось плохой практикой.

# Последние мысли
Все три альтернативные реализации метода GetCountries(), которые обсуждались.
в этом разделе — CountryDTO, анонимные типы и страна — доступны в /Controllers/
Файл CountryController.cs в исходном коде GitHub для этой главы. Первое — это то, что мы будем использовать
для примеров из этой книги, а два других были закомментированы и помещены сюда для справки.
только. Читателям предлагается переключать их по своему желанию, чтобы найти наиболее подходящий подход к
их стиль программирования. Тем не менее, мы настоятельно рекомендуем принять наши советы во внимание, чтобы
сделать самый ответственный выбор.
Вот и все. Теперь мы можем, наконец, перейти к нашей третьей и последней задаче.

# Добавляем название страны
Теперь нам нужно найти способ добавить столбец «Страна» в представление «Города», чтобы наши пользователи могли
см. название страны для каждого города в списке. Учитывая то, что мы только что сделали со странами, это должно
быть довольно простой задачей.

# CitiesController
Как всегда, начнем с веб-API. Следуй этим шагам:
1. Откройте файл /Controllers/CitiesController.cs и измените метод GetCities() в
следующим образом:

```Csharp
[HttpGet]
public async Task<ActionResult<ApiResult<CityDTO>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<CityDTO>.CreateAsync(
 _context.Cities.AsNoTracking()
 .Select(c => new CityDTO()
 {
 Id = c.Id,
 Name = c.Name,
 Lat = c.Lat,
 Lon = c.Lon,
 CountryId = c.Country!.Id,
 CountryName = c.Country!.Name
 }),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
}
```
Как мы видим, мы придерживаемся шаблона на основе DTO, а это означает, что нам придется создать
дополнительный класс CityDTO.
2. С помощью обозревателя решений Visual Studio добавьте новый файл /Data/CityDTO.cs и заполните его
следующее содержание:

```Csharp
namespace WorldCitiesAPI.Data
{
 public class CityDTO
 {
 public int Id { get; set; }
 public string Name { get; set; } = null!;
 public decimal Lat { get; set; }
 public decimal Lon { get; set; }
 public int CountryId { get; set; }
 public string? CountryName { get; set; } = null!;
 }
}
```
Вот и все. Само собой разумеется, что, как мы видели при работе с методом GetCountries() функции
На раннем этапе CountryController мы могли реализовать веб-API, используя анонимные типы,
или с защищенным объектом City, что позволяет избежать написания класса CityDTO. Однако мы намеренно выбрали подход DTO из соображений безопасности, о которых упоминали ранее.
Наш веб-API готов, поэтому давайте перейдем к Angular.

# Обновления интерфейса Angular
Начнем с интерфейса /src/app/cities/city.ts, куда нам нужно добавить название страны.
свойство. Откройте этот файл и обновите его содержимое следующим образом:

```ts
export interface City {
 id: number;
 name: string;
 lat: number;
 lon: number;
 countryId: number;
 countryName: string;
}
```
После этого откройте класс /src/app/cities/cities.comComponent.ts, куда нам нужно добавить
Определение столбца CountryName:

```ts
public displayedColumns: string[] = ['id', 'name', 'lat', 'lon',
'countryName'];
```
Затем откройте класс /src/app/cities/cities.comComponent.html и добавьте новый <ng-container>.
соответственно:

```html
<ng-container matColumnDef="lon">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Longitude</th>
 <td mat-cell *matCellDef="let city">{{city.lon}}</td>
</ng-container>
<!-- CountryName Column -->
<ng-container matColumnDef="countryName">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Country</th>
 <td mat-cell *matCellDef="let city">
 <a [routerLink]="['/country', city.countryId]">{{city.countryName}}</a>
 </td>
</ng-container>
```
Как мы видим, мы обернули имя страны в routerLink, указывая на представление «Редактировать страну», так что
наши пользователи смогут использовать его в качестве элемента навигации.

Давайте проверим, что мы сделали. Нажмите F5, чтобы запустить приложение в режиме отладки, затем перейдите к представлению «Города». Если мы
все сделали правильно, нас должен приветствовать следующий результат:

![image](https://github.com/artemovsergey/Angular/assets/26972859/8472301d-b0e3-4d75-aac9-81b2c428beee)

Неплохо, правда?
Оттуда, если мы нажмем на название страны, мы должны перейти к представлению «Редактировать страну». Это потрясающе, правда?
На этом мы заканчиваем небольшие улучшения кода и настройки пользовательского интерфейса. В следующем разделе мы рассмотрим
столкнутся с более сложной задачей, которая потребует рефакторинга кода всех компонентов Angular, которые
мы создали на данный момент.

В разработке программного обеспечения рефакторинг кода — это процесс реструктуризации существующего исходного кода.
код без изменения его внешнего поведения. Может быть несколько причин для выполнения
действия по рефакторингу, такие как улучшение читаемости, расширяемости или производительности кода, повышение его безопасности или уменьшение его сложности.
Дополнительную информацию о концепции рефакторинга кода высокого уровня см.
введите следующий URL-адрес: https://docs.microsoft.com/en-us/visualstudio/ide/
рефакторинг в Visual Studio.

Пришло время перейти к совершенно другой теме, которая внесет еще одно существенное улучшение в нашу
Angular приложение.

# Data services
Два веб-приложения, которые мы создали на данный момент – HealthCheck и WorldCities – оба имеют функции
интерфейсная и серверная связь между двумя проектами по протоколу HTTP(S), и в порядке
для установления такого взаимодействия мы хорошо использовали класс HttpClient, встроенный HTTP-интерфейс Angular.
Клиент API поставляется с пакетом @angular/common/http, основанным на интерфейсе XMLHttpRequest.
Класс Angular HttpClient имеет множество преимуществ, включая функции тестируемости, запросы и ответы.
типизированные объекты, перехват запросов и ответов, наблюдаемые API и оптимизированная обработка ошибок. Это
можно использовать даже без сервера данных благодаря пакету веб-API в памяти, который эмулирует CRUD
операции через RESTful API. Мы кратко говорили об этом в начале главы 5 «Модель данных».
с Entity Framework Core, когда мы задавались вопросом, действительно ли нам нужен сервер данных или нет
(ответ был отрицательный, поэтому мы его не использовали).
По всем этим причинам эффективное использование класса HttpClient, возможно, является наиболее логичным выбором.
для всех, кто хочет разработать интерфейсное веб-приложение с использованием платформы Angular; тем не менее, там
есть несколько способов реализовать его, в зависимости от того, насколько мы хотим воспользоваться его ценными преимуществами.
функции.
В этом разделе, после краткого рассмотрения альтернатив, мы увидим, как провести рефакторинг нашего приложения, чтобы заменить
наша текущая реализация HttpClient с более универсальным подходом, основанным на выделенном
Служба передачи данных HTTP.

# XMLHttpRequest и Fetch (по сравнению с HttpClient)
Как мы уже говорили, класс HttpClient Angular основан на XMLHttpRequest (XHR), API.
состоящий из объекта, предоставляемого браузером через его механизм JavaScript, который может быть
используется для асинхронной передачи данных между веб-браузером и веб-сервером без необходимости
перезагрузите всю страницу. Эта техника, недавно отпраздновавшая свое 20-летие, по сути была
единственный вариант до 2017 года, когда наконец вышел Fetch API.
Fetch API — это еще один интерфейс для получения ресурсов, который призван стать современной альтернативой
XMLHttpRequest API, предоставляющий более мощный и гибкий набор функций; в следующем разделе мы расскажем
быстро просмотрите их оба и обсудите их плюсы и минусы.

# XMLHttpRequest
Идея, стоящая за этим, впервые появилась еще в 1999 году, когда Microsoft выпустила первый
версия Outlook Web Access (OWA) для Exchange Server 2000.

Вот отрывок из очень старого поста, написанного Алексом Хопманном, одним из разработчиков, родивших его:

«Фактически XMLHTTP начал свою жизнь в команде Exchange 2000. Я присоединился к Microsoft в ноябре 1996 года и переехал в Редмонд весной 1997 года, сначала работая
о некоторых интернет-стандартах, связанных с будущим Outlook. я был специально
проводит некоторую работу над метаданными для веб-сайтов, включая раннее предложение под названием «Веб-сайт».
Коллекции». Однажды в это время Томас Рирдон потащил меня по
зал, чтобы познакомить меня с парнем по имени Жан Паоли, который только что присоединился к компании.
Джин работала над новой вещью под названием XML, которая, как подозревали некоторые люди, будет
когда-нибудь будет очень большим (по какой-то неясной на тот момент причине)».
  – Алекс Хопманн, История XMLHTTP

Алекс был прав: несколько месяцев спустя его команда выпустила интерфейс под названием IXMLHTTPRequest, который
реализовано во второй версии библиотеки Microsoft XML Core Services (MSXML). Эта версия
затем в марте 1999 года был выпущен вместе с Internet Explorer 5.0, который, возможно, был первым браузером, который
смог получить доступ к этому интерфейсу (через ActiveX).
Вскоре после этого проект Mozilla разработал интерфейс под названием nsIXMLHttpRequest и реализовал его в своем механизме компоновки Gecko. Это было очень похоже на интерфейс Microsoft, но также появилось
с оболочкой, позволяющей использовать его через JavaScript, благодаря объекту, возвращаемому
браузер. Объект, который был доступен в Gecko v0.6 6 декабря 2000 г., назывался
XMLHttpRequest.
В последующие годы объект XMLHttpRequest стал фактическим стандартом во всех основных браузерах.
реализуется в Safari 1.2 (февраль 2004 г.), Opera 8.0 (апрель 2005 г.), iCab 3.0b352 (сентябрь 2005 г.),
и Internet Explorer 7 (октябрь 2006 г.). Эти ранние внедрения позволили инженерам Google разработать и
выпустить Gmail (2004 г.) и Google Maps (2005 г.), два новаторских веб-приложения, которые были полностью
на основе API XMLHttpRequest. Одного взгляда на эти приложения было достаточно, чтобы продемонстрировать, что Интернет
развитие вступило в новую эпоху.
Единственное, чего не хватало этой захватывающей технологии, так это названия, которое было найдено 18 февраля.
2005 год, когда Джесси Джеймс Гарретт написал культовую статью под названием AJAX: новый подход к веб-приложениям.
Это было первое известное появление термина AJAX, аббревиатуры от Asynchronous JavaScript +.
XML — набор методов веб-разработки, которые можно использовать для создания асинхронных веб-приложений.
со стороны клиента, где объект XMLHttpRequest играл ключевую роль.

5 апреля 2006 года Консорциум Всемирной паутины (W3C) опубликовал первый проект спецификации для
XMLHttpRequest в попытке создать официальный веб-стандарт.

Проект W3C проложил путь к широкому распространению разработки AJAX. Однако первые реализации были довольно трудными для большинства веб-разработчиков из-за некоторых различий между различными версиями.
реализация браузерами задействованных API. К счастью, все стало намного проще благодаря
множество кроссбраузерных библиотек JavaScript, таких как jQuery, Axios и MooTools, которые были достаточно умными
чтобы добавить его в свой доступный набор инструментов. Это позволило разработчикам использовать базовый XMLHttpRequest.
функциональность объекта косвенно, через стандартизированный набор методов высокого уровня.
Со временем формат данных XHR быстро переключился с XML на JSON, HTML и простой текст, что
больше подходили для работы со страницей DOM без изменения общего подхода. Кроме того, когда
появилась библиотека Reactive Extensions for JavaScript (RxJS), объект XMLHttpRequest может быть
легко поставить позади Observable, получив таким образом множество преимуществ (например, возможность смешивать и сопоставлять
это с другими Observables, подпиской/отпиской и каналом/картой).
Это основная идея класса HttpClient Angular, который можно описать как способ Angular.
для работы с XMLHttpRequest: очень удобная обертка, позволяющая разработчикам эффективно ее использовать
через шаблон Observable.

# Fetch
В первые годы своего существования использование необработанного объекта XMLHttpRequest было довольно трудным для большинства веб-разработчиков.
и могло легко привести к большому объему исходного кода JavaScript, который часто было трудно читать и
понимать; эти проблемы в конечном итоге были решены с помощью надстроек, предоставленных библиотеками.
такие как jQuery, но за счет некоторых неизбежных накладных расходов на код (и ресурсы).
Fetch API был выпущен для более четкого решения таких проблем с использованием встроенного подхода на основе Promise, который можно использовать для простого выполнения тех же асинхронных запросов к серверу, не требуя
сторонние библиотеки.
Вот пример HTTP-запроса с использованием XHR:

```
var oReq = new XMLHttpRequest();
oReq.onload = function() {
 // success
 var jsonData = JSON.parse(this.responseText);
};
oReq.onerror = function() {
 // error
console.error(err);
};
oReq.open('get', './api/myCmd', true);
oReq.send();
```
А вот тот же запрос, выполненный с помощью fetch:

```
fetch('./api/myCmd')
 .then((response) => {
 response.json().then((jsonData) => {
 // success
 });
 })
 .catch((err) => {
 // error
 console.error(err);
 });
```
Как мы видим, код на основе выборки определенно более читабелен. Его общие интерфейсы обеспечивают лучшее
согласованность, собственные возможности JSON делают код более сухим, а возвращаемые обещания позволяют
упрощение цепочек и асинхронных/ожидающих задач без необходимости определения обратных вызовов.
Короче говоря, не нужно быть гением, чтобы увидеть это, если мы сравним необработанную реализацию XHR с
совершенно новый API fetch(), последний явно выигрывает.

# HttpClient
Благодаря классу HttpClient в Angular об использовании необработанного XHR не может быть и речи; мы будем использовать
встроенная абстракция, предоставляемая клиентом, которая позволяет нам писать предыдущий код в
следующим образом:

```ts
this.http.get('./api/myCmd')
 .subscribe(jsonData => {
 // success
 },
 error => {
 // error
 console.error(error));
 };
```
Как мы видим, код HttpClient на основе Observable в предыдущем коде предоставляет аналогичные преимущества.
к коду на основе выборки, который мы видели ранее: мы получаем согласованный интерфейс, собственные возможности JSON,
цепочка и асинхронные/ожидающие задачи.

Кроме того, Observables также можно преобразовать в Promises, а это означает, что мы можем даже сделать
следующий:

```ts
this.http.get('./api/myCmd')
 .toPromise()
 .then((response) => {
 response.json().then((jsonData) => {
 // success
 });
 })
 .catch((err) => {
 // error
 console.error(err);
 });
```
В то же время верно, что обещания также можно преобразовать в Observable с помощью
Библиотека RxJS.

В целом, как JavaScript-родной Fetch API, так и Angular-native класс HttpClient прекрасно
жизнеспособны, и любой из них можно эффективно использовать в приложении Angular.
Вот основные преимущества использования Fetch:
- Это новейший отраслевой стандарт, который можно использовать для обработки HTTP-запросов и ответов.
- Это собственный JavaScript; следовательно, его можно использовать не только в Angular, но и в любой другой внешней среде на основе JavaScript (например, React и Vue).
- Это упрощает работу с сервис-воркерами, поскольку объекты запроса и ответа совпадают с
те, которые мы используем в нашем обычном коде
- Он построен на основе нормы, согласно которой HTTP-запросы имеют одно возвращаемое значение, таким образом возвращая обещание.
вместо потокового типа, как у Observer (это может быть преимуществом в большинстве сценариев,
но это может стать и недостатком)
Вот наиболее важные преимущества использования HttpClient:
- Он основан на Angular и поэтому широко поддерживается и постоянно обновляется фреймворком.
(и скорее всего будет и в будущем)
- Это позволяет легко смешивать и сопоставлять несколько Observables.
- Его уровень абстракции позволяет нам легко реализовать некоторую магию HTTP (например, определение автоматической повторной попытки).
попытки в случае неудачного запроса)
- Наблюдатели, возможно, более универсальны и многофункциональны, чем промисы, которые могут быть полезны в
некоторые сложные сценарии, такие как выполнение вызовов последовательности и возможность отмены HTTP
запросы после их отправки
- Его можно внедрить и, следовательно, использовать для написания модульных тестов для различных сценариев.
- Это позволяет нам использовать HttpInterceptors для прозрачной обработки HTTP-заголовков, токенов-носителей и
больше задач на основе HTTP, как мы увидим в главе 11 «Аутентификация и авторизация».

По всем этим причинам, после тщательного рассмотрения, мы искренне считаем, что внедрение HttpClient в
Возможно, Angular будет лучшим выбором, и поэтому мы будем придерживаться его до конца книги. Тем не менее,
поскольку Fetch API почти так же жизнеспособен в большинстве сценариев, читатели определенно могут попробовать оба подхода.
и посмотрите, какой из них наиболее подходит для той или иной задачи.

Теперь, когда мы знаем преимущества Angular HttpClient, мы можем увидеть, как еще улучшить его.
как мы используем его в нашем коде.

# Создание службы данных
Поскольку мы решили придерживаться класса HttpClient Angular, который мы уже использовали повсюду,
это значит, что у нас все хорошо, да?
Ну, по сути, нет. Хотя использование HttpClient, безусловно, является хорошим выбором, мы реализовали его, используя слишком упрощенный подход. Если мы посмотрим на исходный код Angular, мы увидим, как
фактические HTTP-вызовы размещаются внутри компонентов, что может быть приемлемо для небольших масштабов.
примеры приложений, но это определенно не лучший способ сделать это в реальных сценариях. Что, если мы хотим
обрабатывать ошибки HTTP более сложным способом (например, отправлять их все на удаленный сервер для
статистических целях)? Что делать, если нам нужно кэшировать и/или постобрабатывать данные, которые мы получаем через
серверный API? Не говоря уже о том, что мы обязательно реализуем некоторую логику повторов, чтобы
для решения потенциальных проблем с подключением, что является типичным требованием любого прогрессивного веб-приложения.
Должны ли мы реализовать все предыдущие вещи в наборе методов каждого компонента? Это определенно
не вариант, если мы хотим придерживаться шаблона DRY; возможно, мы могли бы определить суперкласс и предоставить ему
HTTP-возможности и адаптируем исходный код наших подклассов для выполнения всего, вызывая супер
методы с множеством настраиваемых параметров. Такой обходной путь может работать для небольших
задачи, но это может легко превратиться в беспорядок, когда все станет сложнее.

Как правило, мы должны стараться изо всех сил не допускать использования наших классов TypeScript – будь то стандартные, супер- или
sub – от загроможденности огромными объемами кода доступа к данным. Как только мы упадем в эту яму, наш
компоненты станут намного труднее понимать, и нам будет трудно всякий раз, когда
мы хотим обновить, стандартизировать и/или протестировать их. Чтобы избежать такого исхода, крайне важно
Целесообразно отделить уровень доступа к данным от логики представления данных, что можно сделать, инкапсулировав первый в отдельный сервис, а затем внедрив этот сервис в сам компонент.
Это именно то, что мы собираемся сделать.

# Создание BaseService
Поскольку мы имеем дело с несколькими классами компонентов, которые решают разные задачи в зависимости от их
контекста (то есть источника данных, к которому им необходим доступ), настоятельно рекомендуется создать несколько сервисов, по одному для каждого контекста.
Точнее, нам понадобится следующее:
- CityService для работы с компонентами Angular, связанными с городом, и веб-API ASP.NET Core.
- CountryService для работы с компонентами Angular, связанными со страной, и веб-сайтом ASP.NET Core API
Кроме того, если предположить, что они, скорее всего, будут иметь некоторые общие черты, было бы полезно
предоставьте каждому из них суперкласс, который будет действовать как общий интерфейс. Давай сделаем это.

Использование абстрактного суперкласса в качестве общего интерфейса может показаться немного нелогичным:
почему бы нам просто не создать интерфейс? Два из них у нас уже есть, для городов (/cities/
city.ts) и страны (/countries/country.ts).
На самом деле мы сделали это по уважительной причине: Angular не позволяет нам предоставлять интерфейсы в качестве поставщиков, поскольку интерфейсы не компилируются в выходных данных JavaScript TypeScript.
Поэтому, чтобы создать интерфейс сервиса к интерфейсу, наиболее эффективным
способ сделать это - использовать абстрактный класс.

Чтобы создать BaseService, мы можем запустить следующую команду CLI из папки /src/app/
нашего проекта Angular:

```
ng generate service Base --flat --skip-tests
```
Или мы можем просто создать новый файл /src/app/base.service.ts, используя решение Visual Studio.
Исследователь.
После создания нового файла откройте его и заполните следующим кодом:

```ts
import { HttpClient } from '@angular/common/http';
export abstract class BaseService {
 constructor(
protected http: HttpClient) {
 }
}
```
Предыдущий исходный код (за исключением абстрактных и выделенных модификаторов protected) также является ядром.
типичного сервиса данных HTTP: мы собираемся использовать его в качестве базового класса для расширения нашего сервиса.
занятия; точнее, у нас будет один суперкласс (BaseService), содержащий общий интерфейс для
два разных подкласса (CityService и CountryService), которые будут внедрены в наши компоненты.
Что касается двух выделенных модификаторов, попробуем пролить на них свет:
- Abstract: ранее мы использовали этот модификатор в классе BaseFormComponent. Пока мы здесь,
давайте поговорим об этом немного подробнее. В TypeScript абстрактный класс — это класс, который может иметь некоторые
нереализованные методы: эти методы называются абстрактными методами. Абстрактные классы не могут
создаваться как экземпляры, но другие классы могут расширять абстрактный класс и, следовательно, повторно использовать
его конструктор и члены.
- protected: класс HttpClient потребуется всем подклассам служб. Следовательно, это
первый участник, которого мы собираемся сделать доступным для них (а также единственный, по крайней мере, для
сейчас). Для этого нам нужно использовать модификатор доступа, который позволит подклассам использовать его.
В нашем примере мы использовали protected, но могли бы использовать и public.
Прежде чем идти дальше, было бы полезно кратко вспомнить, сколько модификаторов доступа поддерживается.
TypeScript и как они на самом деле работают. Если мы уже знаем их по C# или другим объектно-ориентированным
языков программирования, по большей части это будет знакомая история.

# Модификаторы доступа TypeScript
Модификаторы доступа — это концепция TypeScript, которая позволяет разработчикам объявлять методы и свойства.
как общедоступный, частный, защищенный или доступный только для чтения. Если модификатор не указан, то метод или свойство
Предполагается, что он общедоступен, а это означает, что к нему можно получить доступ как внутри, так и снаружи без проблем.
И наоборот, если он помечен как частный, этот метод или свойство будут доступны только внутри
класс, не включая его подклассы (если таковые имеются). protected подразумевает, что метод или свойство доступны
только внутри класса и всех его подклассов, то есть любого класса, который его расширяет, но не снаружи.
Наконец, режим «только чтение» приведет к тому, что компилятор TypeScript выдаст ошибку, если значение свойства равно
изменен после его первоначального назначения в конструкторе класса.

Для полноты картины стоит отметить, что модификаторы доступа работают немного по-другому, если их назначить параметрам конструктора. Если там не указан модификатор,
переменная будет доступна только в области действия конструктора; и наоборот, если мы присвоим
модификатор этой переменной, она будет доступна во всем классе после модификатора
правила, которые мы описали ранее, точно так же, как они были объявлены как отдельный член.

Однако важно помнить, что эти модификаторы доступа будут применяться только во время компиляции.
Транспилятор TypeScript предупредит нас обо всех ненадлежащих использованиях, но не сможет остановить ненадлежащее использование во время выполнения.

# Добавление общих методов интерфейса
Давайте теперь расширим наш общий интерфейс BaseService некоторыми высокоуровневыми методами, которые соответствуют
что нам нужно будет сделать в наших подклассах. Поскольку компоненты, которые мы рефакторим, уже существуют, лучшее
способ определить эти общие методы интерфейса — просмотреть их исходный код и действовать соответствующим образом.
Вот хорошее начало:

```ts
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { environment } from '../environments/environment';
export abstract class BaseService<T> {
 constructor(
 protected http: HttpClient) {
 }
 abstract getData(
 pageIndex: number,
 pageSize: number,
 sortColumn: string,
 sortOrder: string,
 filterColumn: string | null,
 filterQuery: string | null): Observable<ApiResult<T>>;
 abstract get(id: number): Observable<T>;
 abstract put(item: T): Observable<T>;
 abstract post(item: T): Observable<T>;
 protected getUrl(url: string) {
 return environment.baseUrl + url;
 }
}
export interface ApiResult<T> {
 data: T[];
 pageIndex: number;
 pageSize: number;
 totalCount: number;
 totalPages: number;
 sortColumn: string;
 sortOrder: string;
 filterColumn: string;
 filterQuery: string;
}
```
Давайте кратко рассмотрим каждый из предыдущих абстрактных методов:
- getData(): обновления призваны заменить текущую реализацию методов в нашем
Файлы TypeScript CitiesComponent и CountrysComponent для получения городов и стран.
списки. Как мы видим, мы воспользовались возможностью указать новый строго типизированный интерфейс — ApiResult<T>.
– он будет заполнен структурированным выводом JSON, который мы уже получаем от
Веб-API ASP.NET Core GetCities и GetCountries.
- get(): это заменит текущую реализацию методов loadData() нашего
Файлы TypeScript CityEditComponent и CountryEditComponent.
- put() и post(): эти методы заменят наши текущие реализации submit().
методы наших TypeScript-файлов CityEditComponent и CountryEditComponent.
- getUrl(): этот вспомогательный метод централизует необходимые задачи для создания URL-адреса для API.
конечные точки, что позволяет избежать принудительного использования свойства Environment.baseUrl для каждого
HTTP-запрос.
Поскольку мы используем большое количество переменных универсального типа, возможно, будет полезно кратко вспомнить, что они собой представляют.
- как они могут помочь нам определить наши общие интерфейсы.

# Переменные типа и универсальные типы – <T> и <any>
Стоит отметить, что для методов get, put и post мы не использовали строго типизированный интерфейс, но
вместо этого пошел на переменную типа. Мы были вынуждены это сделать, потому что эти методы вернут результат.
интерфейс City или Country, в зависимости от производного класса, который их реализует.
Принимая это во внимание, мы выберем использование <T> вместо <any>, чтобы не потерять информацию о том, каким был этот тип, когда функция вернется. Общий тип <T> позволяет нам отложить
спецификация типа возвращаемой переменной до тех пор, пока класс или метод не будут объявлены и не будут созданы экземпляры
клиентский код, а это означает, что мы сможем зафиксировать тип данного аргумента всякий раз, когда мы реализуем
метод в производном классе (то есть, когда мы знаем, что возвращается).

Переменная типа <T> — отличный способ справиться с неизвестными типами в интерфейсе.
Обратите внимание, что мы также использовали его в предыдущем интерфейсе ApiResult Angular, точно так же, как мы
сделал это в файле C# /Data/ApiResult.cs в серверной части .NET.

В этих концепциях нет ничего нового, поскольку мы уже использовали их в нашем внутреннем коде: это просто здорово.
что мы также можем использовать их во внешнем интерфейсе Angular благодаря языку программирования TypeScript.

# Зачем возвращать Observables, а не JSON?
Прежде чем двигаться дальше, было бы разумно кратко объяснить, почему мы решили возвращать наблюдаемые типы.
вместо уже имеющихся у нас интерфейсов на основе JSON, таких как City, Country и ApiResult.
Разве это не было бы более практичным выбором?
На самом деле все как раз наоборот: наши типы интерфейсов имеют крайне ограниченные возможности, если мы
сравните их с многофункциональными коллекциями Observable, о которых мы уже говорили несколько раз.
начиная с главы 4 «Взаимодействие с внешним и внутренним интерфейсом».

Зачем нам ограничивать себя и компоненты, которые будут вызывать эти методы? Даже если мы
хотели (или нуждались) фактически выполнить HTTP-вызов и получить данные изнутри него, мы могли бы
всегда заново создавайте Observable и возвращайте его после выполнения этой задачи. Мы поговорим об этом подробнее в следующих главах.

# Создание CityService
Давайте теперь создадим нашу первую производную службу, то есть первый производный класс (или подкласс) BaseService.
В обозревателе решений перейдите к папке /src/app/cities/ и щелкните правой кнопкой мыши, чтобы создать новый город.
service.ts и заполните его следующим кодом:

```ts
import { Injectable} from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { BaseService, ApiResult } from '../base.service';
import { Observable } from 'rxjs';
import { City } from './city';
@Injectable({
 providedIn: 'root',
})
export class CityService
 extends BaseService<City> {
 constructor(
 http: HttpClient) {
 super(http);
 }
 getData(
 pageIndex: number,
 pageSize: number,
 sortColumn: string,
 sortOrder: string,
 filterColumn: string | null,
 filterQuery: string | null
 ): Observable<ApiResult<City>> {
 var url = this.getUrl("api/Cities");
 var params = new HttpParams()
 .set("pageIndex", pageIndex.toString())
 .set("pageSize", pageSize.toString())
 .set("sortColumn", sortColumn)
.set("sortOrder", sortOrder);
 if (filterColumn && filterQuery) {
 params = params
 .set("filterColumn", filterColumn)
 .set("filterQuery", filterQuery);
 }
 return this.http.get<ApiResult<City>>(url, { params });
 }
 get(id: number): Observable<City> {
 var url = this.getUrl("api/Cities/" + id);
 return this.http.get<City>(url);
 }
 put(item: City): Observable<City> {
 var url = this.getUrl("api/Cities/" + item.id);
 return this.http.put<City>(url, item);
 }
 post(item: City): Observable<City> {
 var url = this.getUrl("api/Cities");
 return this.http.post<City>(url, item);
 }
}
```
Наиболее важным аспектом предыдущего исходного кода является свойство ProvideIn в @ службы.
Декоратор Injectable(), которому мы установили root. Это скажет Angular предоставить этот инъекционный элемент в
корень приложения, что делает его одноэлементной службой.

Одноэлементная служба — это служба, для которой в приложении существует только один экземпляр. Другими словами,
Angular создаст только один экземпляр этого сервиса, который будет доступен всем
компоненты, которые будут использовать его (посредством внедрения зависимостей) в нашем приложении. Хотя
Сервисы Angular не обязательно должны быть одиночными, этот метод позволяет эффективно использовать
памяти и обеспечивает хорошую производительность, что делает его наиболее часто используемым
подход к реализации.
Дополнительную информацию о сервисах Singleton можно найти по следующему URL-адресу: https://
angular.io/guide/singleton-services.

Кроме этого, в предыдущем коде нет ничего нового: мы просто скопировали (и немного адаптировали)
реализация, которая уже существует в наших файлах TypeScript CitiesComponent и CityEditComponent.
Основное отличие состоит в том, что теперь мы используем HttpClient, а это означает, что мы можем удалить его из
классы компонентов и вместо этого абстрагируем их использование с помощью CityService.

# Реализация CityService
Давайте теперь проведем рефакторинг наших Angular компонентов, чтобы использовать совершенно новый CityService вместо исходного кода.
HttpClient. Как мы вскоре увидим, новый шаблон одноэлементных сервисов, который мы использовали
(и об этом говорилось) ранее, сделает все немного проще, чем раньше 

# AppModule
В версиях Angular до 6.0 единственный способ сделать единый сервис доступным во всем приложении.
нужно было бы ссылаться на него в файле AppModule следующим образом:

```ts
import { CityService } from './cities/city.service';
// ...existing code...
 providers: [ CityService ],
```
Как мы видим, нам следовало добавить оператор импорта для новой службы в начале
файл AppModule, а также зарегистрировал сам сервис в существующих (пусть и пока пустых) провайдерах:
[] раздел.
К счастью, поскольку мы использовали корневой подход, представленный в Angular,
6.0 предыдущий метод больше не требуется, хотя он по-прежнему поддерживается как жизнеспособная альтернатива.

На самом деле подход, предоставленныйIn:root, предпочтительнее, поскольку он делает нашу
дерево услуг-потрясающее. Встряхивание дерева — это метод оптимизации скомпилированного с помощью JavaScript
пакеты кода, удаляя из конечного файла весь код, который на самом деле не используется.
Дополнительную информацию о встряхивании деревьев в JavaScript можно найти по следующему URL-адресу:
https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking.

Короче говоря, благодаря новому подходу нам больше не нужно обновлять файл AppModule: мы просто
необходимо провести рефакторинг компонентов, которые будут использовать сервис.

# CitiesComponent
В обозревателе решений откройте файл /src/app/cities/cities.comComponent.ts и обновите его содержимое.
следующее:

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
// import { HttpClient, HttpParams } from '@angular/common/http';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { City } from './city';
import { CityService } from './city.service';
import { ApiResult } from '../base.service';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
// ...existing code...
 constructor(
 private cityService: CityService) {
 }
// ...existing code...
 getData(event: PageEvent) {
 var sortColumn = (this.sort)
 ? this.sort.active
 : this.defaultSortColumn;
 var sortOrder = (this.sort)
 ? this.sort.direction
 : this.defaultSortOrder;
 var filterColumn = (this.filterQuery)
 ? this.defaultFilterColumn
 : null;
 var filterQuery = (this.filterQuery)
 ? this.filterQuery
 : null;
 this.cityService.getData(
 event.pageIndex,
 event.pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery)
 .subscribe(result => {
 this.paginator.length = result.totalCount;
 this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.cities = new MatTableDataSource<City>(result.data);
 }, error => console.error(error));
 }
}
```

Как мы видим, нам просто нужно было выполнить несколько незначительных обновлений:
- В разделе импорта мы добавили ссылки на наши новые файлы.
- В конструкторе мы заменили существующую http-переменную типа HttpClient новой переменной cityService типа CityService.
- И последнее, но не менее важное: мы изменили существующую реализацию метода getData() — на основе
HttpClient — для нового, основанного на новом CityService.
Стоит отметить, что мы закомментировали все ссылки на импорт из @angular/common/.
http просто потому, что они нам больше не нужны, поскольку мы не используем их напрямую в
этот класс.

# CityEditComponent
Реализация CityService в CityEditComponent будет такой же простой, как и для
Компоненты городов.

В обозревателе решений откройте файл /src/app/cities/city-edit.comComponent.ts и обновите его.
содержание следующее:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormControl, Validators, AbstractControl, AsyncValidatorFn
} from '@angular/forms';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { City } from './city';
import { Country } from './../countries/country';
import { BaseFormComponent } from '../base-form.component';
import { CityService } from './city.service';
import { ApiResult } from '../base.service';
// ...existing code...
 constructor(
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private http: HttpClient,
 private cityService: CityService) {
 super();
 }
// ...existing code...
 onSubmit() {
 // ...existing code...
 if (this.id) {
 // EDIT mode
 this.cityService
 .put(city)
 .subscribe(result => {
 console.log("City " + city!.id + " has been updated.");
 // go back to cities view
 this.router.navigate(['/cities']);
}, error => console.error(error));
 }
 else {
 // ADD NEW mode
 this.cityService
 .post(city)
 .subscribe(result => {
 console.log("City " + result.id + " has been created.");
 // go back to cities view
 this.router.navigate(['/cities']);
 }, error => console.error(error));
 }
 }
```

Как мы видим, на этот раз нам не удалось избавиться от ссылки на пакет @angular/common/http.
потому что нам все еще нужен HttpClient для выполнения некоторых конкретных задач — loadCountries() и isDupeCity().
– с чем мы не можем справиться с помощью нашего текущего сервиса. Чтобы решить эти проблемы, нам определенно кажется, что мы
необходимо реализовать еще два метода в CityService.
Давай сделаем это!

# Реализация loadCountries и isDupeCity в CityService
В обозревателе решений откройте файл /src/app/cities/city.service.ts и добавьте следующее
методы в конце файла, непосредственно перед последней фигурной скобкой:

```ts
getCountries(
 pageIndex: number,
 pageSize: number,
 sortColumn: string,
 sortOrder: string,
 filterColumn: string | null,
 filterQuery: string | null
): Observable<ApiResult<Country>> {
 var url = this.getUrl("api/Countries");
 var params = new HttpParams()
 .set("pageIndex", pageIndex.toString())
 .set("pageSize", pageSize.toString())
.set("sortColumn", sortColumn)
 .set("sortOrder", sortOrder);
 if (filterColumn && filterQuery) {
 params = params
 .set("filterColumn", filterColumn)
 .set("filterQuery", filterQuery);
 }
 return this.http.get<ApiResult<Country>>(url, { params });
}
isDupeCity(item: City): Observable<boolean> {
 var url = this.getUrl("api/Cities/isDupeCity");
 return this.http.post<boolean>(url, item);
}
```
Поскольку этот код содержит ссылку на интерфейс Country, нам также необходимо добавить следующий импорт
утверждение (мы можем поместить его прямо под интерфейсом City):

```ts
import { Country } from './../countries/country';
```
Теперь, когда у нас есть эти методы, мы можем исправить наш файл класса CityEditComponent следующим образом:

```ts
Now that we have these methods, we can patch our CityEditComponent class file as follows:
import { Component, OnInit } from '@angular/core';
// import { HttpClient, HttpParams } from '@angular/common/http';
// ...existing code...
 constructor(
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private cityService: CityService) {
 super();
 }
// ...existing code...
 loadData() {
 // ...existing code...

 // fetch the city from the server
this.cityService.get(this.id).subscribe(result => {
 // ...existing code...
 }
 loadCountries() {
 // fetch all the countries from the server
 this.cityService.getCountries(
 0,
 9999,
 "name",
 "asc",
 null,
 null,
 ).subscribe(result => {
 this.countries = result.data;
 }, error => console.error(error));
 }
// ...existing code...
 isDupeCity(): AsyncValidatorFn {
 return (control: AbstractControl): Observable<{ [key: string]:
 any } | null> => {
 var city = <City>{};
 city.id = (this.id) ? this.id : 0;
 city.name = this.form.controls['name'].value;
 city.lat = +this.form.controls['lat'].value;
 city.lon = +this.form.controls['lon'].value;
 city.countryId = +this.form.controls['countryId'].value;
 return this.cityService.isDupeCity(city)
 .pipe(map(result => {
 return (result ? { isDupeCity: true } : null);
 }));
 }
 }
}
```
Вот и все! Теперь мы можем удалить ссылки @angular/common/http и HttpClient из нашего
Код CityEditComponent.

Прежде чем идти дальше, было бы разумно проверить, что мы уже сделали, нажав F5.
и убедиться, что все работает как прежде. Если мы все сделали правильно, мы
не должен видеть различий: наш новый CityService должен иметь возможность прозрачно выполнять
все задачи, которые ранее выполнялись HttpClient. Это ожидаемо, поскольку мы
до сих пор использую его под капотом!

В следующем разделе мы сделаем то же самое с компонентами, связанными со страной.

# Создание CountryService
Пришло время создать CountryService, который будет вторым и последним производным классом (или подклассом).
из Базового Сервиса.
Как и в начале работы с CityService, создайте новый файл /src/app/countries/country.service.ts.
с помощью команды nggenerate Angular CLI (или обозревателя решений) и заполните ее следующим кодом:

```ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { BaseService, ApiResult } from '../base.service';
import { Observable } from 'rxjs';
import { Country } from './country';
@Injectable({
 providedIn: 'root',
})
export class CountryService
 extends BaseService<Country> {
 constructor(
 http: HttpClient) {
 super(http);
 }
 getData (
 pageIndex: number,
 pageSize: number,
 sortColumn: string,
 sortOrder: string,
 filterColumn: string | null,
 filterQuery: string | null
 ): Observable<ApiResult<Country>> {
var url = this.getUrl("api/Countries");
 var params = new HttpParams()
 .set("pageIndex", pageIndex.toString())
 .set("pageSize", pageSize.toString())
 .set("sortColumn", sortColumn)
 .set("sortOrder", sortOrder);
 if (filterColumn && filterQuery) {
 params = params
 .set("filterColumn", filterColumn)
 .set("filterQuery", filterQuery);
 }
 return this.http.get<ApiResult<Country>>(url, { params });
 }
 get(id: number): Observable<Country> {
 var url = this.getUrl("api/Countries/" + id);
 return this.http.get<Country>(url);
 }
 put(item: Country): Observable<Country> {
 var url = this.getUrl("api/Countries/" + item.id);
 return this.http.put<Country>(url, item);
 }
 post(item: Country): Observable<Country> {
 var url = this.getUrl("api/Countries");
 return this.http.post<Country>(url, item);
 }
 isDupeField(countryId: number, fieldName: string, fieldValue: string):
Observable<boolean> {
 var params = new HttpParams()
 .set("countryId", countryId)
 .set("fieldName", fieldName)
 .set("fieldValue", fieldValue);
 var url = this.getUrl("api/Countries/IsDupeField");
 return this.http.post<boolean>(url, null, { params });
 }
}
```
Как мы видим, на этот раз мы опередили время и воспользовались возможностью напрямую добавить isDupeField().
метод, так как он нам определенно понадобится для рефакторинга валидатора нашего CountryEditComponent
в ближайшее время.
Как всегда, теперь, когда мы создали сервис, нам нужно реализовать его в нашем приложении. К счастью
достаточно, как мы объяснили ранее, нам не нужно ссылаться на него в нашем файле AppModule; нам просто нужно
чтобы правильно реализовать его в компонентах, связанных с нашей страной.

# CountriesComponent
В обозревателе решений откройте файл /src/app/countries/countries.comComponent.ts и обновите его.
содержание следующее:

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
// import { HttpClient, HttpParams } from '@angular/common/http';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { Country } from './country';
import { CountryService } from './country.service';
import { ApiResult } from '../base.service';
 // ...existing code...
 constructor(
 private countryService: CountryService) {
 }
 // ...existing code...
 getData(event: PageEvent) {
 var sortColumn = (this.sort)
 ? this.sort.active
 : this.defaultSortColumn;
 var sortOrder = (this.sort)
 ? this.sort.direction
 : this.defaultSortOrder;
var filterColumn = (this.filterQuery)
 ? this.defaultFilterColumn
 : null;
 var filterQuery = (this.filterQuery)
 ? this.filterQuery
 : null;
 this.countryService.getData(
 event.pageIndex,
 event.pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery)
 .subscribe(result => {
 this.paginator.length = result.totalCount;
 this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.countries = new MatTableDataSource<Country>(result.data);
 }, error => console.error(error));
 }
}
```
Здесь нет ничего нового; мы только что повторили то, что недавно сделали с CitiesComponent.

# CountryEditComponent
В обозревателе решений откройте файл /src/app/countries/country-edit.comComponent.ts и измените
его содержание следующее:

```ts
import { Component, OnInit } from '@angular/core';
// import { HttpClient, HttpParams } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormBuilder, Validators, AbstractControl, AsyncValidatorFn
} from '@angular/forms';
import { map } from 'rxjs/operators';
import { Observable } from 'rxjs';
import { Country } from './country';
import { BaseFormComponent } from '../base-form.component';
import { CountryService } from './country.service';
 // ...existing code...
 constructor(
 private fb: FormBuilder,
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private countryService: CountryService) {
 super();
 }

// ...existing code...
 loadData() {
 // ...existing code...
 // fetch the country from the server
 this.countryService.get(this.id)
 .subscribe(result => {
 this.country = result;
 this.title = "Edit - " + this.country.name;
 // update the form with the country value
 this.form.patchValue(this.country);
 }, error => console.error(error));
 }
 else {
 // ADD NEW MODE
 this.title = "Create a new Country";
 }
 }
 onSubmit() {
 // ...existing code...
 if (this.id) {
 // EDIT mode
 this.countryService
.put(country)
 .subscribe(result => {
 console.log("Country " + country!.id + " has been updated.");
 // go back to countries view
 this.router.navigate(['/countries']);
 }, error => console.error(error));
 }
 else {
 // ADD NEW mode
 this.countryService
 .post(country)
 .subscribe(result => {
 console.log("Country " + result.id + " has been created.");
 // go back to countries view
 this.router.navigate(['/countries']);
 }, error => console.error(error));
 }
 }
 isDupeField(fieldName: string): AsyncValidatorFn {
 return (control: AbstractControl): Observable<{ [key: string]:
 any } | null> => {
 return this.countryService.isDupeField(
 this.id ?? 0,
 fieldName,
 control.value)
 .pipe(map(result => {
 return (result ? { isDupeField: true } : null);
 }));
 }
 }
}
```
Как мы видим, изменения кода, которые мы здесь применили, очень похожи на то, что мы сделали в CityEditComponent.
Поскольку мы воспользовались возможностью превентивно добавить метод isDupeField() в наш класс CountryService,
на этот раз нам удалось избавиться от пакета @angular/common/http за один раз.

Вот и все, по крайней мере, на данный момент. В следующей главе мы будем эффективно использовать эти новые сервисы. Однако,
прежде чем идти дальше, настоятельно рекомендуется выполнить несколько отладочных прогонов (нажав F5), чтобы
убедитесь, что все по-прежнему работает.
Если это не так, обратитесь к разделу «Исправления ошибок и улучшения» ранее в этой главе.

# Краткое содержание
В этой главе мы потратили некоторое драгоценное время на объединение существующего исходного кода нашего приложения WorldCities Angular. Мы успешно реализовали некоторые оптимизации и настройки, эффективно используя
особенностей наследования классов TypeScript и научились создавать базовые классы (суперклассы)
и производные классы (подклассы), что делает наш исходный код более удобным в сопровождении и СУХИМ. В то же
время мы воспользовались возможностью исправить некоторые ошибки и добавить пару новых функций в пользовательский интерфейс нашего приложения.
Сразу после этого мы усовершенствовали возможности получения данных в нашем приложении Angular, перейдя с прямого
использование класса Angular HttpClient в наших компонентах для более универсального подхода на основе сервисов.
В конце концов мы создали CityService и CountryService — оба расширяют абстракцию BaseService.
class – для обработки всех HTTP-запросов, тем самым открывая путь для постобработки, обработки ошибок,
логика повтора и другие интересные вещи, которые будут представлены в следующей главе.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: объектно-ориентированное программирование, полиморфизм, наследование, AJAX, XMLHttpRequest, Fetch API, Angular HttpClient, сервисы Angular.
RxJS, Observables, Promises, встряхивание деревьев, одноэлементные сервисы, модификаторы доступа TypeScript, TypeScript
универсальные типы, базовые классы и производные классы, суперклассы и подклассы, модификаторы доступа.










