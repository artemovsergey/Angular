# Fetching and Displaying Data

В предыдущей главе мы создали новое решение WorldCities, содержащее проект WorldCities.
(наше приложение Angular) и проект WorldCitiesAPI (наш веб-API ASP.NET) и внесли значительный вклад в
усилия по расширению возможностей последнего с помощью поставщика данных на основе СУБД, построенного на Entity Framework Core.
используя подход Code-First. Теперь, когда у нас есть постоянство данных, мы готовы доверить нашим пользователям
с возможностью взаимодействия с нашим приложением; это означает, что мы можем переключиться на приложение Angular и
реализовать некоторые столь необходимые вещи, такие как следующие:
- Извлечение данных: запрос поставщика данных со стороны клиента с использованием HTTP-запросов и получение
структурированные результаты со стороны сервера
- Отображение данных: заполнение типичных клиентских компонентов, таких как таблицы и списки, и тем самым
обеспечение хорошего пользовательского опыта для конечного пользователя
- Добавление стран в цикл. Для простоты мы научимся реализовывать выборку.
и отображать задачи, сосредоточив внимание на сущности «Город»: в последней части главы мы будем использовать
знания, полученные для применения тех же методов к субъекту «Страна», а также

В этой главе мы рассмотрим темы выборки и отображения, добавив несколько взаимодействий клиент-сервер.
обрабатывается стандартными цепочками запросов/ответов HTTP; само собой разумеется, что Angular будет играть
здесь важную роль, а также пару полезных пакетов, которые помогут нам достичь нашей цели.

# Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, а также
следующую внешнюю библиотеку:
- System.Linq.Dynamic.Core (пакет .NET Core NuGet) для приложения WorldCitiesAPI ASP.NET.
Как всегда, желательно не устанавливать их сразу; мы собираемся привезти их во время
эту главу, чтобы лучше понять их цель в рамках нашего проекта.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/master/Chapter_06/.

# Получение данных
Как мы уже знаем из главы 2 «Подготовка», чтение данных из базы данных в основном является задачей
чтобы приложение Angular (интерфейсная часть) отправляло HTTP-запросы приложению ASP.NET (внутренняя часть) и
получение соответствующих ответов HTTP соответственно; эта передача данных будет в основном реализована с использованием нотации объектов JavaScript (JSON), облегченного формата обмена данными, который изначально
поддерживается обеими платформами.
В этом разделе мы в основном будем говорить о HTTP-запросах и ответах, посмотрим, как мы можем получать данные из
приложение ASP.NET и выложите несколько необработанных примеров пользовательского интерфейса с использованием компонентов Angular, которые будут далее
уточняется в следующих разделах.
Мы готовы? Давайте начнем!

# Запросы и ответы
Давайте начнем с рассмотрения тех HTTP-запросов и ответов, с которыми мы будем иметь дело: нажмите F5, чтобы запустить
проекты WorldCities и WorldCitiesAPI в режиме отладки — или щелкните правой кнопкой мыши WorldCitiesAPI.
проект и выберите «Отладка» > «Начать новый экземпляр», чтобы запустить только этот проект, и введите следующую команду:
URL-адрес в адресной строке браузера: https://localhost:40443/api/Cities/.
Если мы все сделали правильно, мы должны увидеть список городов, каждый из которых имеет уникальный идентификатор. Из этого списка,
мы можем легко выбрать идентификатор каждого города и добавить его в наш URL-адрес, чтобы получить только этот конкретный город: например, мы можем использовать 13, что в нашем конкретном сценарии соответствует городу Нью-Йорк.

![image](https://github.com/artemovsergey/Angular/assets/26972859/8492c941-d150-499f-978e-382d6aa13191)

Важное примечание: идентификаторы различных городов и стран, упомянутых в
книга может отличаться от тех, которые присутствуют в собственной базе данных читателя, в зависимости от различных
факторы: версия/прогресс файла городов мира, начальный автоматически увеличивающийся идентификатор
Таблица базы данных [Cities], которую мы использовали для хранения источника данных, и так далее. Не обращайте на это внимания: все
примеры кода должны по-прежнему работать, независимо от разницы в идентификаторе.

Соглашения и значения по умолчанию JSON
Как мы видим, JSON — это, по сути, сериализация нашего объекта City с некоторыми встроенными соглашениями.
например следующее:
- CamelCase вместо PascalCase: у нас есть name вместо Name, CountryId вместо CountryId,
и так далее, а это означает, что все имена и свойства классов PascalCase .NET будут автоматически преобразованы в CamelCase при их сериализации в JSON.
- Никаких отступов и перевода строки/возврата каретки (LF/CR): все сложено в один
строка текста
Эти соглашения являются параметрами по умолчанию, установленными ASP.NET при работе с выходными данными JSON. Большинство
их можно изменить, добавив некоторые параметры настройки в промежуточное программное обеспечение MVC. Однако мы
не нужно этого делать, поскольку они прекрасно поддерживаются Angular, и это то, что мы собираемся использовать для
разобраться с этими строками; нам просто нужно убедиться, что интерфейсы Angular, которые мы создадим, будут отражать
имена и свойства классов сущностей имеют значение CamelCase.

Любой, кто хочет знать, почему они выбрали CamelCase вместо PascalCase по умолчанию.
опция сериализации должна проверить следующую ветку GitHub: https://github.com/aspnet/MVC/проблемы/4283.

Тем не менее, если мы хотим повысить читаемость вывода JSON, мы можем добавить отступы, чтобы
что мы сможем понять больше этих результатов.
Для этого откройте файл Program.cs и добавьте следующие параметры в builder.Services.
Метод AddControllers (выделены новые/обновленные строки):

```Csharp
builder.Services.AddControllers()
 .AddJsonOptions(options =>
 {
 options.JsonSerializerOptions.WriteIndented = true;
 });
```
Сохраните файл, нажмите F5 и еще раз введите предыдущий URL-адрес, чтобы увидеть следующие изменения:

![image](https://github.com/artemovsergey/Angular/assets/26972859/52c168c5-5481-4173-9048-f8f604f2fcc1)

Начнем: как мы видим, включив эту опцию, JSON становится намного более читабельным, с
Angular все еще может получить к нему правильный доступ. Однако такое изменение также окажет (незначительное) влияние
на производительность, поскольку все эти переводы строк и пробелы немного увеличивают общий размер
всех HTTP-ответов, возвращаемых серверным API.
Если бы мы хотели переключиться с CamelCase (по умолчанию) на PascalCase, мы могли бы также добавить следующую опцию:

```Csharp
options.JsonSerializerOptions.PropertyNamingPolicy = null;
```
Тем не менее, ради этих примеров проектов мы предпочитаем сохранить соглашения по умолчанию (без отступов и верблюжьего регистра): именно по этой причине мы закомментируем эти два варианта.

Те, кто хочет раскомментировать эти параметры, могут это сделать: просто имейте в виду, что если
Вместо CamelCase используется PascalCase, примеры кода Angular, показанные в этой главе.
– и в последующих главах – необходимо будет соответствующим образом изменить.

# (Очень) длинный список
Давайте теперь перейдем к нашему приложению Angular и создадим образец компонента для отображения списка городов. Мы уже создали компонент в главе 4 «Взаимодействие с внешним и внутренним интерфейсом», поэтому знаем, что делать:
1. Откройте командную строку.
2. Перейдите в папку /src/app/ проекта WorldCities Angular.
3. Введите nggenerateComponent Cities --module=app --skip-tests, чтобы создать следующее:
новые файлы с помощью Angular CLI:
• /src/app/cities/cities.comComponent.ts
• /src/app/cities/cities.comComponent.html
• /src/app/cities/cities.comComponent.scss
4. В обозревателе решений создайте дополнительный файл city.ts в папке /src/app/cities/.
проекта WorldCities Angular
После этого заполните новые файлы следующим содержимым.

# city.ts
Откройте файл /src/app/cities/city.ts и добавьте следующее:

```ts
export interface City {
 id: number;
 name: string;
 lat: number;
 lon: number;
}
```
Этот небольшой файл содержит интерфейс нашего города, который мы будем использовать в файле класса CitiesComponent. С
в конечном итоге мы собираемся использовать его и в других компонентах, лучше создать его в отдельном
файл и украсьте его оператором экспорта, чтобы мы могли использовать его и там, когда
приходит время.

# cities.component.ts
Откройте файл /src/app/cities/cities.component.ts и замените его содержимое следующим:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public cities!: City[];
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.http.get<City[]>(environment.baseUrl + 'api/Cities')
 .subscribe(result => {
 this.cities = result;
 }, error => console.error(error));
 }
}
```
Как мы видим, мы добавили ссылку на импорт в интерфейс City, который создали недавно. Мы также
использовал метод перехвата жизненного цикла ngOnInit() для выполнения HTTP-запроса, который получит города,
точно так же, как мы это делали в главе 4 «Взаимодействие с внешним и внутренним интерфейсом» для нашего предыдущего приложения HealthCheck.

cities.component.html
Откройте файл /src/app/cities/cities.comComponent.html и добавьте следующее:

```html
<h1>Cities</h1>
<p>Here's a list of cities: feel free to play with it.</p>
<p *ngIf="!cities"><em>Loading...</em></p>
<table class='table table-striped' aria-labelledby="tableLabel"
[hidden]="!cities">
 <thead>
 <tr>
 <th>ID</th>
 <th>Name</th>
 <th>Lat</th>
 <th>Lon</th>
 </tr>
 </thead>
 <tbody>
 <tr *ngFor="let city of cities">
 <td>{{ city.id }}</td>
 <td>{{ city.name }}</td>
 <td>{{ city.lat }}</td>
 <td>{{ city.lon }}</td>
 </tr>
 </tbody>
</table>
```
Как мы видим, предыдущая структура HTML не имеет ничего особенного: это просто заголовок, абзац и
таблица с некоторой стандартной логикой загрузки, чтобы пользователь знал, что мы будем асинхронно загружать данные
через (надеюсь) короткое время. Однако есть как минимум два качества, заслуживающие пары слов.

# Базовый стиль таблицы
Если мы посмотрим на HTML-элемент <table>, то легко заметим, что применили несколько CSS-элементов.
классы там: столовые и столовые-полосатые. Это два наиболее широко используемых класса интерфейсной платформы Bootstrap, когда дело доходит до стилизации таблиц. Короче говоря, первый будет применять некоторые
основные правила интервалов и типографики, в то время как последние изменят цвет фона таблицы
нечетные ряды, воспроизводящие таким образом эффект «полосатости»; и то и другое значительно повысит читабельность таблицы

Чтобы узнать больше о Bootstrap, его компонентах пользовательского интерфейса и функциях стилизации макета, проверьте
официальную документацию можно найти по следующему URL-адресу: https://getbootstrap.com.

Поскольку мы не используем Bootstrap для этого проекта, нам придется создать эти классы самостоятельно в
файл города.компонент.scss. Однако, прежде чем сделать это, стоит обратить внимание еще на одну вещь.

# The [hidden] attribute
Если мы продолжим смотреть на HTML-код файла city.comComponent.html, то увидим, что вскоре после
В определении класса таблицы элемент <table> имеет странный [скрытый] атрибут. Почему оно там,
и почему это в квадратных скобках?
На самом деле скрытый атрибут — это атрибут контента, действительный для HTML5, который можно законно
устанавливается для любого элемента HTML. Роль, которую он должен играть, очень похожа на отображение CSS: нет
Настройка: указывает браузеру, что элемент и все его потомки не должны быть видимы или
понятен любому пользователю. Другими словами, это просто еще один способ скрыть контент от пользователя.

Что касается квадратных скобок, то это всего лишь синтаксис Angular, используемый для определения привязки свойства, то есть
Свойство или атрибут HTML в шаблоне компонента (наш HTML-файл), который получает свое значение из
переменная, свойство или выражение, определенные в классе компонента (наш файл .ts). Стоит отметить
что такая привязка протекает в одном направлении: от класса компонента (источника) к элементу HTML.
внутри шаблона компонента (целевого).
Как прямое следствие того, что мы только что сказали, каждый раз, когда исходное значение оказывается истинным,
Свойству HTML (или атрибуту) между квадратными скобками также будет присвоено значение true (и наоборот); этот
это отличный способ справиться со многими атрибутами HTML, которые работают с логическими значениями, потому что мы можем
динамически устанавливать их на протяжении всего жизненного цикла компонента. Именно это мы и делаем с
Элемент <table> в предыдущем блоке кода: его скрытый атрибут будет иметь значение false до тех пор, пока города
переменная компонента заполняется фактическими городами, полученными с сервера, что произойдет только тогда, когда
модуль HttpClient завершает свою задачу запроса/ответа. Неплохо, правда?
Подождите: разве это не то же самое поведение, что и структурная директива *ngIf, которую мы уже знаем из
Глава 4. Взаимодействие с внешним и внутренним интерфейсом? Почему вместо этого мы используем этот [скрытый] атрибут?
Это очень хороший вопрос, который дает нам возможность прояснить разницу между этими двумя похожими, но не идентичными подходами:
- Структурная директива *ngIf добавляет или удаляет элемент из объектной модели документа.
(DOM) на основе соответствующего условия или выражения; это означает, что элемент будет
инициализироваться и/или удаляться (вместе со всеми дочерними элементами, событиями и т. д.) каждый раз
меняется его статус.
- Скрытый атрибут, очень похожий на настройку CSS display: none, будет только указывать браузеру
показать элемент или скрыть элемент от пользователя; это означает, что элемент будет
все еще быть там, будучи полностью доступным и достижимым (например, с помощью JavaScript или другого
действия по манипулированию DOM).

Как мы видим, взглянув на предыдущий HTML-код, мы используем их оба: структурный элемент *ngIf.
Директива добавляет или удаляет элемент загрузки <p>, а привязка атрибута [hidden] показывает или
скрывает основную <таблицу>. Мы решили сделать это не просто так: у элемента <p> не будет дочерних элементов.
или зависящие от него события, а атрибут <table> вскоре станет сложным объектом с множеством
функций для инициализации и сохранения в DOM. Использование атрибута [hidden] для этого также будет
обеспечивает лучшую производительность, чем *ngIf, когда нам нужно показать/скрыть множество элементов DOM.

# cities.component.scss
Пришло время добавить эти классы таблиц в наш файл SCSS, как мы и планировали сделать недавно.
Откройте файл /src/app/cities/cities.comComponent.scss и добавьте следующий код SASS:

```scss
table.table {
 width: 100%;
 margin-bottom: 1rem;
 color: #212529;
 vertical-align: top;
 border-color: #dee2e6;
 &.table-striped > tbody > tr:nth-of-type(even) {
 background-color: rgba(0, 0, 0, 0.05);
 color: #212529;
 }
 &.table-hover > tbody > tr:hover {
 background-color: rgba(0, 0, 0, 0.075);
 color: #212529;
 }
}
```
Вот и все, по крайней мере, на данный момент. Наш CitiesComponent достаточно хорош для отправки: нам просто нужно интегрировать его.
это в нашем приложении Angular.

# app-routing.module.ts
Как мы уже знаем, этот компонент может быть загружен – и доступен только с помощью маршрутизации на стороне клиента Angular – если мы добавим его в файл app-routing.module.ts следующим образом (новые строки
выделено):

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { HomeComponent } from './home/home.component';
import { CitiesComponent } from './cities/cities.component';
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'cities', component: CitiesComponent }
];
@NgModule({
 imports: [RouterModule.forRoot(routes)],
 exports: [RouterModule]
})
export class AppRoutingModule { }
```
Начнем: теперь нам нужно разобраться с пользовательским интерфейсом.

# nav-component.html

Точнее, нам нужно добавить ссылку на новый маршрут компонента в навигаторе приложения.
компонент; в противном случае пользователь не сможет увидеть (и, следовательно, получить доступ) к нему через пользовательский интерфейс.
Для этого откройте файл nav-menu-comComponent.html и добавьте следующие (выделенные) строки:

```html
<header>
 <mat-toolbar color="primary">
 <button mat-icon-button [routerLink]="['/']">
 <mat-icon>
 home
 </mat-icon>
 </button>
 <a mat-flat-button color="primary" [routerLink]="['/cities']">
 Cities
 </a>
 </mat-toolbar>
</header>
```
Вот и все. Теперь мы можем запустить наше приложение, щелкнуть ссылку «Города», которая появится в правом верхнем углу.
экрана и получите следующий результат:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5c7aec4a-2c7f-4fed-a080-5ba0ba507730)

Как мы видим, глядя на вертикальную полосу прокрутки справа, мы были бы ошеломлены огромным
HTML-таблица, состоящая из более чем 41 000 строк!
Это еще один огромный стресс для производительности как для ASP.NET, так и для Angular, который должен пройти с
с честью на любой средней машине разработки, поскольку обе среды могут хорошо справляться со своими задачами.
соответствующие задачи.
Однако такой результат пользовательского интерфейса определенно бесполезен с точки зрения пользовательского опыта: мы не можем разумно
ожидаем, что наши конечные пользователи будут счастливы, если мы заставим их перемещаться по HTML-таблице размером примерно в 41 тысячу строк с помощью
браузер. Они бы сошли с ума, пытаясь найти город, который ищут!
Чтобы решить эти основные проблемы с удобством использования, нам необходимо реализовать несколько важных функций, которые часто
используется для работы с толстыми HTML-таблицами: разбиение на страницы, сортировка и фильтрация.

# Обслуживание данных с помощью Angular Material
Чтобы реализовать таблицу с функциями разбиения по страницам, сортировки и фильтрации, мы собираемся использовать Angular Material,
библиотека компонентов пользовательского интерфейса, которую мы уже представили в главе 4 «Взаимодействия с внешним и внутренним интерфейсом».
Однако, прежде чем добавлять новые компоненты Angular Material, мы воспользуемся возможностью применить немного
рефакторинг в соответствии с тем, как мы реализовали существующие.

# Добавление AngularMaterialModule
В обозревателе решений перейдите в папку /src/app/ и создайте новый angular-material.module.
ts и заполните его следующим содержимым:

```ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';
@NgModule({
 imports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule
 ],
 exports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule
 ]
})
export class AngularMaterialModule { }
```
Это совершенно новый модуль, который мы собираемся использовать для всех модулей Angular Material, которые хотим использовать.
реализовать в нашем приложении. Как мы видим, взглянув на предыдущий код, мы уже включили
каждый компонент Angular Material, который мы научились использовать до сих пор. Размещаем их здесь вместо использования
файл app.module.ts будет уменьшать размер этого файла, что отлично подходит для управления проектом.
Излишне говорить, что для правильной работы этого модуля-контейнера нам необходимо добавить его в существующее приложение.
файл модуль.ts. Откройте этот файл, удалите все ссылки на модули Mat* в файлах import, imports[] и
разделы Exports[] и замените их следующими (выделенными) строками:

```ts
//.. existing code
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AngularMaterialModule } from './angular-material.module';
//.. existing code
 imports: [
 BrowserModule,
 HttpClientModule,
AppRoutingModule,
 BrowserAnimationsModule,
 AngularMaterialModule
 ],
//.. existing code
```
Начнем: теперь все, что мы собираемся поместить в файл angular-material.module.ts, также будет
упоминается в нашем приложении.

# Представляем MatTable
Модуль Angular Material, который мы собираемся использовать, — это MatTable, который предоставляет интерфейс в стиле Material Design.
Таблица HTML, которую можно использовать для отображения строк данных. Мы кратко представили его еще в главе 4 «Внешний интерфейс».
и внутренние взаимодействия, когда мы обновили пользовательский интерфейс FetchDataComponent и HealthCheckComponent.
в нашем приложении HealthCheck. Теперь мы научимся правильно использовать его, чтобы заменить наши простые HTML-таблицы, которые
позволит нам воспользоваться его уникальными и удобными функциями.

# Обновление AngularMaterialModule
Поскольку мы планируем представить новый модуль Angular Material, первое, что нам нужно сделать, это добавить
его ссылки на наш новый AngularMaterialModule.
Откройте файл /src/app/angular-material.module.ts и добавьте следующие выделенные строки:

```ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTableModule } from '@angular/material/table';
@NgModule({
 imports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule,
 MatTableModule
 ],
 exports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule,
 MatTableModule
 ]
})
export class AngularMaterialModule { }
```
Теперь мы можем использовать преимущества MatTableModule во всех компонентах нашего приложения Angular.

# Обновление компонента Cities
Начнем с CitiesComponent.
Откройте файл /src/app/cities/cities.comComponent.ts и добавьте следующие (выделенные) строки:

```ts
// ...existing code...
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: City[];
 constructor(private http: HttpClient) {
 }
}
// ...existing code...

```

Сразу после этого откройте файл /src/app/cities/cities.comComponent.html и замените наш предыдущий
реализацию таблицы с новым MatTableModule следующим образом (обновленный код выделен):

```html
<h1>Cities</h1>
<p>Here's a list of cities: feel free to play with it.</p>
<p *ngIf="!cities"><em>Loading...</em></p>
<table mat-table [dataSource]="cities"
 class="mat-elevation-z8"
 [hidden]="!cities">
 <!-- Id Column -->
 <ng-container matColumnDef="id">
 <th mat-header-cell *matHeaderCellDef>ID</th>
 <td mat-cell *matCellDef="let city">{{city.id}}</td>
 </ng-container>
 <!-- Name Column -->
 <ng-container matColumnDef="name">
 <th mat-header-cell *matHeaderCellDef>Name</th>
 <td mat-cell *matCellDef="let city">{{city.name}}</td>
 </ng-container>
 <!-- Lat Column -->
 <ng-container matColumnDef="lat">
 <th mat-header-cell *matHeaderCellDef>Latitude</th>
 <td mat-cell *matCellDef="let city">{{city.lat}}</td>
 </ng-container>
 <!-- Lon Column -->
 <ng-container matColumnDef="lon">
 <th mat-header-cell *matHeaderCellDef>Longitude</th>
 <td mat-cell *matCellDef="let city">{{city.lon}}</td>
 </ng-container>
 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>
```
Как мы видим, MatTableModule в некотором роде имитирует поведение стандартной HTML-таблицы, но с подходом на основе шаблонов для каждого столбца; шаблон содержит ряд вспомогательных структурных директив
(применяется с использованием синтаксиса *<directiveName>), который можно использовать для обозначения определенных разделов шаблона и
определить фактическую роль раздела шаблона. Как мы видим, все эти директивы заканчиваются постфиксом Def.
Вот наиболее подходящие из тех, которые использовались в предыдущем коде:
- Привязка атрибута [скрытый] не является неожиданностью, поскольку она уже присутствовала в предыдущей таблице.
с той же целью: держать таблицу скрытой до тех пор, пока города не будут загружены.
- Директива matColumnDef идентифицирует данный столбец с помощью уникального ключа.
- Директива matHeaderCellDef определяет, как отображать заголовок для каждого столбца.
- Директива matCellDef определяет, как отображать ячейки данных для каждого столбца.
- Директива matHeaderRowDef, которую можно найти в конце предыдущего кода, определяет элемент конфигурации для строки заголовка таблицы и порядок отображения заголовка.
столбцы. Как мы видим, у нас было это выражение директивы, указывающее на переменную компонента.
называется displayColumns, который мы заранее определили в файле city.comComponent.ts; этот
переменная содержит массив, содержащий все ключи столбцов, которые мы хотим показать, которые должны быть
идентичны именам, указанным в различных директивах matColumnDef.
Прежде чем тестировать нашу новую реализацию на основе MatTable, нам необходимо обновить стиль нашего компонента.
правила.
Откройте файл /src/app/cities/cities.comComponent.scss и замените его содержимое следующим:

```scss
table.mat-table {
 width: 100%;
}
```

Как мы видим, большинство предыдущих правил CSS утеряны, поскольку нам больше не нужно стилизовать HTML.
table вручную: Angular Material выполнит за нас большую часть работы по стилизации.


Теперь мы можем нажать F5 и перейти к представлению «Города», чтобы увидеть, как выглядит наша новая таблица. Это может
можно увидеть на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/95741422-28ea-4e73-a7f4-c3580beb2397)

Хорошо, Material Design действительно существует, но у таблицы те же проблемы с UI/UX, что и раньше! Для одного,
это еще очень долго; давайте исправим это, реализовав функцию пейджинга.

# Добавление нумерации страниц с помощью MatPaginatorModule
Теперь, когда мы используем Angular Material, реализация нумерации страниц стала довольно простой задачей. Во-первых
нам нужно добавить ссылку на MatPaginatorModule в файл angular-material.module.ts, просто
как мы недавно сделали с MatTableModule.

Вот оператор импорта, который нужно добавить в конец уже существующих, сразу после MatTableModule:

```ts
import { MatPaginatorModule } from '@angular/material/paginator';
```
Не забудьте также добавить его в коллекции импорта и экспорта @NgModule.

# Пейджинг на стороне клиента
Теперь, когда мы сослались на новый модуль, мы можем открыть файл city.comComponent.ts и импортировать его.
сервисы MatPaginator, MatTableDataSource и ViewChild следующим образом (выделены новые и обновленные строки):

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: MatTableDataSource<City>;
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.http.get<City[]>(environment.baseUrl + 'api/Cities')
 .subscribe(result => {
 this.cities = new MatTableDataSource<City>(result);
 this.cities.paginator = this.paginator;
}, error => console.error(error));
 }
}
```

Как мы видим, мы использовали декоратор @ViewChild, чтобы задать запрос статического представления и сохранить его результат в
переменная пагинатора; уделим пару минут предназначению такого декоратора и зачем
нам это нужно.
Короче говоря, декоратор @ViewChild можно использовать для получения ссылки на элемент шаблона DOM.
изнутри компонента Angular, что делает его очень полезной функцией всякий раз, когда нам нужно манипулировать свойствами элемента. Как мы видим из предыдущего кода, декоратор определен
используя параметр селектора, который необходим для доступа к элементу DOM: этот селектор может быть классом
имя (если класс имеет декоратор @Component или @Directive), ссылочную переменную шаблона,
поставщик, определенный в дереве дочерних компонентов, и так далее.
В нашем конкретном сценарии мы использовали имя класса MatPaginator, поскольку у него есть @Component.
декоратор.

Пока мы этим занимаемся, может быть полезно знать, что декоратор @ViewChild также принимает
второй параметр, который был обязательным до Angular 8 и стал необязательным, начиная с Angular.
9: статический флаг, который может иметь значение true или false (начиная с Angular 9, по умолчанию он равен false).
Если для этого флага явно установлено значение true, @ViewChild извлекается из шаблона перед
выполняется фаза обнаружения изменений (то есть даже до жизненного цикла ngOnInit()); наоборот,
задача извлечения компонента/элемента решается либо после этапа обнаружения изменений
если элемент находится внутри вложенного представления (например, представления с условным отображением *ngIf)
директиву), или до обнаружения изменений, если это не так.
Поскольку мы использовали привязку атрибута [скрытый] в шаблоне вместо *ngIf
директиве, наш MatPaginator не столкнется с проблемами инициализации, даже без необходимости
установите этот флаг в значение true.
Для получения дополнительной информации о декораторе @ViewChild мы предлагаем вам посмотреть
в документации Angular: https://angular.io/api/core/ViewChild.

После этого откройте файл города.компонент.html и добавьте следующую директиву нумерации страниц (выделено) сразу после закрывающего тега ```</table>```:

```html
<!-- ...existing code... -->
 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>
<!-- Pagination directive -->
<mat-paginator [hidden]="!cities"
 [pageSize]="10"
[pageSizeOptions]="[10, 20, 50]"
 showFirstLastButtons></mat-paginator>
```
Как мы видим, мы снова использовали привязку атрибута [hidden], чтобы скрыть пагинатор до тех пор, пока не будет
города были загружены. Другие свойства, которые мы видим в элементе <mat-paginator> configure
некоторые параметры пользовательского интерфейса MatPaginatorModule, такие как размер страницы по умолчанию и массив всех страниц.
параметры размера, которые мы хотим сделать доступными для пользователей.
Теперь мы можем нажать F5 и посмотреть на наши усилия:

![image](https://github.com/artemovsergey/Angular/assets/26972859/f4dcc38d-53e4-4165-88b7-25818e250882)

Теперь в нашей таблице показаны только первые 10 городов. У него также есть аккуратный пагинатор в правом нижнем углу.
который можно использовать для навигации по различным страницам с помощью стрелок. Наш конечный пользователь может даже выбрать
сколько элементов на странице отображать с помощью аккуратного раскрывающегося списка (10, 20 или 50 городов на странице, как указано в свойстве [pageSizeOptions]). Похоже, что мы это сделали!

Однако, если мы подумаем об этом, мы легко можем признать, что мы еще не совсем достигли цели. Конечно, теперь наш
пользователи могут удобно просматривать таблицу, не прокручивая ее вверх и вниз целую вечность, но это не требует
гениально понимать, что все эти строки по-прежнему передаются в клиентский браузер: мы никогда
сообщил серверу, что он должен поддерживать постраничный запрос, поэтому мы по-прежнему извлекаем все города из наших данных
провайдера (и через API-контроллер ASP.NET), как и раньше: по сути, они просто
не отображается во внешнем интерфейсе.
По сути, это означает, что мы по-прежнему имеем то же влияние на производительность, что и раньше на сервере.
сторона (огромный результат SQL-запроса, массивный JSON) и лишь частичное улучшение производительности на клиенте
сторона: даже если теперь в DOM добавляется меньше элементов HTML, все равно остается много строк HTML, которые нужно
показать/скрыть при каждом действии пагинатора, что приводит к смене страницы.
Чтобы смягчить вышеупомянутые проблемы, нам необходимо перейти от подкачки на стороне клиента к подкачке на стороне сервера.
пейджинг – именно этим мы и займемся в следующем разделе.

# Пейджинг на стороне сервера
Реализация пейджинга на стороне сервера немного сложнее, чем его аналог на стороне клиента. Вот что
нам нужно сделать (и где):
- WorldCitiesAPI (проект ASP.NET). Измените наш класс CitiesController, чтобы он поддерживал
страничные HTTP-запросы GET
- WorldCitiesAPI (проект ASP.NET). Создайте новый класс ApiResult, который мы можем использовать для улучшения.
ответ JSON наших контроллеров ASP.NET
- WorldCities (проект Angular). Измените наш Angular-компонент city.controller.ts – и
текущая конфигурация MatPaginatorModule – чтобы он мог выдать новый запрос GET
и разобраться с новым ответом JSON
Давай сделаем это!

# CitiesController
The GetCities method of our CitiesController returns a JSON array of all the ~41,000 cities in our
database by default; that’s definitely a no-go in terms of server-side performance, so we need to change
it. Ideally, we would like to only return a small number of Cities, which is something we can easily
pull off by adding some (required) variables to the method signature, such as pageIndex and pageSize.
Here’s how we could change that to enforce such behavior (updated lines highlighted):

```Csharp
[HttpGet]
public async Task<ActionResult<IEnumerable<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10)
{
return await _context.Cities
 .Skip(pageIndex * pageSize)
 .Take(pageSize)
 .ToListAsync();
}
```
Вот и все; мы также указали некоторые разумные значения по умолчанию для этих переменных, чтобы избежать огромных затрат.
Ответы JSON по умолчанию.
Давайте быстро проверим то, что мы только что сделали: нажмите F5 и введите следующий URL-адрес в адресную строку браузера:
https://localhost:40443/api/Cities/?pageIndex=0&pageSize=10.
Вот что у нас должно получиться:

![image](https://github.com/artemovsergey/Angular/assets/26972859/14fca0aa-6cc4-4aec-a73a-6a43f40a66be)

Определенно кажется, что наш план работает!
Однако есть серьезная проблема, с которой нам придется разобраться: если мы просто вернем массив JSON из 10 городов,
у нашего приложения Angular не будет возможности узнать, сколько городов присутствует в нашей базе данных.
Без этой информации маловероятно, что пагинатор будет работать так, как он есть.
сделал, когда мы реализовали нумерацию страниц на стороне клиента на раннем этапе.
Короче говоря, нам нужно найти способ сообщить нашему Angular-приложению некоторую дополнительную информацию, например:
следующее:
- Общее количество доступных страниц (и/или записей).
- Текущая страница
- Количество записей на каждой странице.
По правде говоря, единственная необходимая информация — это первая, поскольку тогда клиент Angular сможет
следить за двумя другими; однако, поскольку нам нужно реализовать это, мы могли бы также вернуть
их всех, что делает нашу интерфейсную жизнь намного проще.

Для этого лучшее, что мы можем сделать, — это создать специальный класс типа ответа.
теперь буду много использовать.

# ApiResult
В обозревателе решений щелкните правой кнопкой мыши папку Data и добавьте новый файл класса ApiResult.cs C#. Затем,
заполните его следующим содержимым:

```Csharp
using Microsoft.EntityFrameworkCore;
namespace WorldCitiesAPI.Data
{
 public class ApiResult<T>
 {
 /// <summary>
 /// Private constructor called by the CreateAsync method.
 /// </summary>
 private ApiResult(
 List<T> data,
 int count,
 int pageIndex,
 int pageSize)
 {
 Data = data;
 PageIndex = pageIndex;
 PageSize = pageSize;
 TotalCount = count;
 TotalPages = (int)Math.Ceiling(count / (double)pageSize);
 }
 #region Methods
 /// <summary>
 /// Pages a IQueryable source.
 /// </summary>
 /// <param name="source">An IQueryable source of generic
 /// type</param>
 /// <param name="pageIndex">Zero-based current page index
 /// (0 = first page)</param>
 /// <param name="pageSize">The actual size of each
 /// page</param>
 /// <returns>
 /// A object containing the paged result
/// and all the relevant paging navigation info.
 /// </returns>
 public static async Task<ApiResult<T>> CreateAsync(
 IQueryable<T> source,
 int pageIndex,
 int pageSize)
 {
 var count = await source.CountAsync();
 source = source
 .Skip(pageIndex * pageSize)
 .Take(pageSize);
 var data = await source.ToListAsync();
 return new ApiResult<T>(
 data,
 count,
 pageIndex,
 pageSize);
 }
 #endregion
 #region Properties
 /// <summary>
 /// The data result.
 /// </summary>
 public List<T> Data { get; private set; }
 /// <summary>
 /// Zero-based index of current page.
 /// </summary>
 public int PageIndex { get; private set; }
 /// <summary>
 /// Number of items contained in each page.
 /// </summary>
 public int PageSize { get; private set; }
 /// <summary>
 /// Total items count
 /// </summary>
public int TotalCount { get; private set; }
 /// <summary>
 /// Total pages count
 /// </summary>
 public int TotalPages { get; private set; }
 /// <summary>
 /// TRUE if the current page has a previous page,
 /// FALSE otherwise.
 /// </summary>
 public bool HasPreviousPage
 {
 get
 {
 return (PageIndex > 0);
 }
 }
 /// <summary>
 /// TRUE if the current page has a next page, FALSE otherwise.
 /// </summary>
 public bool HasNextPage
 {
 get
 {
 return ((PageIndex +1) < TotalPages);
 }
 }
 #endregion
 }
}
```

Этот класс ApiResult содержит некоторые действительно интересные вещи. Попробуем обобщить самое актуальное.
вещи:
- Данные: свойство типа List<T>, которое будет использоваться для хранения выгружаемых данных (оно будет
переведено в массив JSON)
- PageIndex: возвращает индекс текущей страницы, начинающийся с нуля (0 для первой страницы, 1 для
второй и так далее)
- PageSize: возвращает общий размер страницы (TotalCount/PageSize).
- TotalCount: возвращает общее количество элементов.
- TotalPages: возвращает общее количество страниц с учетом общего количества элементов.
(Общее количество/Размер страницы)
-  HasPreviousPage: возвращает True, если текущая страница имеет предыдущую страницу, в противном случае — False.
-  HasNextPage: возвращает True, если у текущей страницы есть следующая страница, в противном случае — False.
Эти свойства — именно то, что мы искали; основная логика для расчета их значений
должно быть довольно легко понять, посмотрев на предыдущий код.
Помимо этого, класс в основном вращается вокруг статического метода CreateAsync<T>(IQueryable<T>
source, int pageIndex, int pageSize), который можно использовать для разбиения на страницы Entity Framework.
Объект IQueryable.

Стоит отметить, что класс ApiResult не может быть создан извне, поскольку
его конструктор помечен как частный; единственный способ создать его — использовать статический
Фабричный метод CreateAsync. Для этого есть веские причины: поскольку это невозможно
чтобы определить асинхронный конструктор, мы прибегли к использованию статического асинхронного метода, который
возвращает экземпляр класса; конструктор был установлен в приватный режим, чтобы разработчики не могли
от его прямого использования вместо фабричного метода, поскольку это единственный разумный способ
создать экземпляр этого класса.

Вот как мы можем использовать наш новый класс ApiResult в методе GetCities нашего
Контроллер городов:

```Csharp
// GET: api/Cities
// GET: api/Cities/?pageIndex=0&pageSize=10
[HttpGet]
public async Task<ActionResult<ApiResult<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10)
{
 return await ApiResult<City>.CreateAsync(
 _context.Cities.AsNoTracking(),
 pageIndex,
 pageSize
 );
}
```
Вот так! Теперь у нас должны быть 10 городов и вся информация, которую мы искали.

Ничего не стоит, поскольку мы выполняем задачу только для чтения, мы использовали
Метод расширения AsNoTracking(), который мы представили в главе 5 «Модель данных с
Entity Framework Core, чтобы предотвратить захват всех сущностей EF Core и тем самым избежать
нетривиальное влияние на производительность.

Давайте нажмем F5 и перейдем к тому же URL-адресу, что и раньше, чтобы увидеть, что изменилось: https://localhost:40443/
API/Cities/?pageIndex=0&pageSize=10.
Вот обновленный ответ в формате JSON:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5497e8c6-738c-469e-b556-65ee3117909a)

Если мы прокрутим результат вниз до нижней части, мы увидим, что конечная точка не возвращает JSON.
массив больше; новый результирующий контент представляет собой объект JSON, составляющий наш предыдущий массив (в данных
собственности), а также новые объекты недвижимости, необходимые нам для выполнения задач по разбиению страницы.
Давайте теперь перейдем ко всем Angular CitiesComponent и обновим его, чтобы использовать этот новый, безопасный способ.
получение наших городов с сервера.

# CitiesComponent
Единственные файлы Angular, которые нам нужно изменить, это следующие:
- Файл CitiesComponent TypeScript, в который мы помещаем всю логику извлечения данных,
теперь нам нужно обновить
- HTML-файл CitiesComponent для привязки определенного события к нашему элементу MatPaginator.
Давай сделаем это.
Откройте файл города.компонент.тс и внесите следующие изменения (новые/обновленные строки выделены):

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: MatTableDataSource<City>;
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 var pageEvent = new PageEvent();
 pageEvent.pageIndex = 0;
 pageEvent.pageSize = 10;
 this.getData(pageEvent);
 }
 getData(event: PageEvent) {
 var url = environment.baseUrl + 'api/Cities';
 var params = new HttpParams()
 .set("pageIndex", event.pageIndex.toString())
 .set("pageSize", event.pageSize.toString());
 this.http.get<any>(url, { params })
 .subscribe(result => {
 this.paginator.length = result.totalCount;
this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.cities = new MatTableDataSource<City>(result.data);
 }, error => console.error(error));
 }
}
```

Попробуем подвести итог тому, что мы здесь сделали:
- Мы удалили HttpClient из метода перехвата жизненного цикла ngOnInit() и поместили весь
вход для получения данных в отдельном методе getData(). Для этого нам пришлось определить
пара внутренних переменных класса для размещения HttpClient и baseUrl для их сохранения.
что мы сможем использовать их несколько раз (то есть при нескольких вызовах getData()).
- Мы изменили логику получения данных, чтобы она соответствовала нашему новому объекту ответа JSON.
- Мы изменили нашу стратегию настройки пагинатора, чтобы вручную задавать значения, которые мы получаем из
серверная часть вместо того, чтобы автоматически их определять; это необходимо сделать, иначе
он просто принял бы во внимание (и разбил на страницы) небольшую часть городов, которые мы получаем при каждом
HTTP-запрос вместо полного пакета.
Что касается файла города.компонент.html, нам просто нужно добавить одну строку в <mat-paginator>.
директива для привязки события getData() к каждому событию подкачки. Вот как это сделать (новая строка
выделено):

```html
<mat-paginator [hidden]="!cities"
 (page)="getData($event)"
 [pageSize]="10"
 [pageSizeOptions]="[10, 20, 50]"
 showFirstLastButtons></mat-paginator>
```
Эта простая привязка играет очень важную роль: она гарантирует, что событие getData() будет вызываться каждый раз.
время, когда пользователь взаимодействует с элементом пагинатора для изменения страницы, запроса предыдущей/следующей страницы, первой/последней страницы, изменения количества отображаемых элементов и т. д. Как мы можем легко
понимаете, такой вызов необходим для разбиения на страницы на стороне сервера, поскольку нам нужно получить обновленные данные
с сервера каждый раз, когда нам приходится отображать разные строки.

Закончив, давайте попробуем новое волшебство, нажав F5, а затем перейдя к представлению «Города». Если мы все сделали правильно, мы должны получить тот же пользовательский интерфейс, который видели раньше:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1e1399ce-3236-4f7d-85dc-6fad7425910f)

Однако на этот раз мы должны увидеть лучшую общую производительность и более быстрое время отклика для
начальная загрузка страницы. Это потому, что мы не имеем дело с тысячами элементов JSON и таблицами HTML.
ряды под капотом; мы получаем только некоторые из них одновременно (то есть те, которые мы видим), используя
наша улучшенная серверная логика.
В то же время навигация между страницами может быть немного медленнее, чем раньше, поскольку мы выдаем
новый HTTP-запрос (и выборка данных) для каждой страницы вместо получения данных в памяти. Однако,
такой недостаток производительности часто предпочтительнее загрузки всего набора данных за один раз, что
это то, что происходит при использовании подкачки на стороне клиента, если только мы не работаем с довольно небольшим набором данных. Как
всегда при решении таких проблем с производительностью не существует «лучшего подхода»: все зависит от
требования приложения, объем затронутых данных и то, чего мы хотим достичь.

Раз с разбиением по страницам покончено, можно наконец заняться сортировкой.

# Добавление сортировки с помощью MatSortModule
Чтобы реализовать сортировку, мы собираемся использовать MatSortModule, который можно реализовать просто
как модуль пагинатора.
На этот раз мы не будем проводить эксперименты с сортировкой на стороне клиента, как это было с ранним разбиением на страницы; собирались
для серверного шаблона с самого начала.

В общих чертах, всякий раз, когда мы имеем дело с разбиением на страницы и сортировкой, нам всегда следует использовать
реализацию на стороне сервера, так как это, вероятно, улучшит общую производительность наших приложений, часто избавляя от необходимости обрабатывать такого рода вещи с помощью
дополнительный клиентский код.

# Расширение APIResult
Начнем с серверной части ASP.NET — другими словами, с проекта WorldCitiesAPI.
Помните класс ApiResult, который мы создали ранее? Пришло время улучшить исходный код, добавив
поддержка сортировки.
В обозревателе решений откройте файл /Data/ApiResult.cs и соответствующим образом обновите его содержимое (новый/
обновленные строки выделены):

```Csharp
using Microsoft.EntityFrameworkCore;
using System.Linq.Dynamic.Core;
using System.Reflection;
namespace WorldCitiesAPI.Data
{
 public class ApiResult<T>
 {
 /// <summary>
 /// Private constructor called by the CreateAsync method.
 /// </summary>
 private ApiResult(
 List<T> data,
 int count,
 int pageIndex,
 int pageSize,
 string? sortColumn,
 string? sortOrder)
 {
 Data = data;
PageIndex = pageIndex;
 PageSize = pageSize;
 TotalCount = count;
 TotalPages = (int)Math.Ceiling(count / (double)pageSize);
 SortColumn = sortColumn;
 SortOrder = sortOrder;
 }
 #region Methods
 /// <summary>
 /// Pages and/or sorts a IQueryable source.
 /// </summary>
 /// <param name="source">An IQueryable source of generic
 /// type</param>
 /// <param name="pageIndex">Zero-based current page index
 /// (0 = first page)</param>
 /// <param name="pageSize">The actual size of each
 /// page</param>
 /// <param name="sortColumn">The sorting column name</param>
 /// <param name="sortOrder">The sorting order ("ASC" or
 /// "DESC")</param>
 /// <returns>
 /// A object containing the IQueryable paged/sorted result
 /// and all the relevant paging/sorting navigation info.
 /// </returns>
 public static async Task<ApiResult<T>> CreateAsync(
 IQueryable<T> source,
 int pageIndex,
 int pageSize,
 string? sortColumn = null,
 string? sortOrder = null)
 {
 var count = await source.CountAsync();
 if (!string.IsNullOrEmpty(sortColumn)
 && IsValidProperty(sortColumn))
 {
 sortOrder = !string.IsNullOrEmpty(sortOrder)
 && sortOrder.ToUpper() == "ASC"
 ? "ASC"
 : "DESC";
source = source.OrderBy(
 string.Format(
 "{0} {1}",
 sortColumn,
 sortOrder)
 );
 }
 source = source
 .Skip(pageIndex * pageSize)
 .Take(pageSize);

 var data = await source.ToListAsync();

 return new ApiResult<T>(
 data,
 count,
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder);
 }
 #endregion
 #region Methods
 /// <summary>
 /// Checks if the given property name exists
 /// to protect against SQL injection attacks
 /// </summary>
 public static bool IsValidProperty(
 string propertyName,
 bool throwExceptionIfNotFound = true)
 {
 var prop = typeof(T).GetProperty(
 propertyName,
 BindingFlags.IgnoreCase |
 BindingFlags.Public |
 BindingFlags.Instance);
 if (prop == null && throwExceptionIfNotFound)
 throw new NotSupportedException(
 string.Format(
$"ERROR: Property '{propertyName}' does not exist.")
 );
 return prop != null;
 }
 #endregion
 #region Properties
 /// <summary>
 /// The data result.
 /// </summary>
 public List<T> Data { get; private set; }
 /// <summary>
 /// Zero-based index of current page.
 /// </summary>
 public int PageIndex { get; private set; }
 /// <summary>
 /// Number of items contained in each page.
 /// </summary>
 public int PageSize { get; private set; }
 /// <summary>
 /// Total items count
 /// </summary>
 public int TotalCount { get; private set; }
 /// <summary>
 /// Total pages count
 /// </summary>
 public int TotalPages { get; private set; }
 /// <summary>
 /// TRUE if the current page has a previous page,
 /// FALSE otherwise.
 /// </summary>
 public bool HasPreviousPage
 {
 get
 {
 return (PageIndex > 0);
}
 }
 /// <summary>
 /// TRUE if the current page has a next page, FALSE otherwise.
 /// </summary>
 public bool HasNextPage
 {
 get
 {
 return ((PageIndex +1) < TotalPages);
 }
 }
 /// <summary>
 /// Sorting Column name (or null if none set)
 /// </summary>
 public string? SortColumn { get; set; }
 /// <summary>
 /// Sorting Order ("ASC", "DESC" or null if none set)
 /// </summary>
 public string? SortOrder { get; set; }
 #endregion
 }
}
```
Мы добавили два новых атрибута sortColumn и sortOrder в статический метод основного класса.
и реализовать их через код; пока мы были там, мы также воспользовались возможностью определить
два новых свойства с одинаковым именем (в верхнем регистре), чтобы сведения о сортировке были частью
Ответ JSON, как и пейджинговый.
Стоит отметить, что, поскольку сейчас мы собираем нашу систему языково-интегрированных запросов (LINQ)-to-SQL
запросы с литеральными данными, поступающими от клиента, мы также добавили новый метод IsValidProperty()
который проверит, что указанный sortColumn действительно существует как типизированное свойство универсального
<T> сущность, с которой мы имеем дело; как ясно сказано в комментарии к методу, на самом деле это мера безопасности против попыток внедрения SQL. Это очень важный вопрос безопасности, о котором мы поговорим.
примерно через некоторое время.

Если мы попытаемся собрать наш проект сразу после этих изменений, нас, скорее всего, встретит какой-нибудь компилятор.
ошибки, например следующие:

```
Error CS0246: The type or namespace name System.Linq.Dynamic could not be found
(are you missing a using directive or an assembly reference?).
```
Не волнуйтесь, это совершенно нормально: нам просто нужно добавить в наш проект новый пакет NuGet.

# Установка System.Linq.Dynamic.Core
Метод расширения IQueryable<T>.OrderBy(), который мы использовали в улучшенном исходном коде ApiResult.
для программного применения сортировки столбцов является частью пространства имен System.Linq.Dynamic.Core.
Благодаря этой библиотеке можно писать запросы Dynamic LINQ (на основе строк) в IQueryable.
это похоже на то, что мы сделали в предыдущем коде.
К сожалению, System.Linq.Dynamic.Core не является частью стандартных двоичных файлов ASP.NET; следовательно, в
чтобы использовать эти функции, нам нужно добавить их через NuGet.
Самый быстрый способ сделать это — открыть консоль диспетчера пакетов Visual Studio и выполнить следующую команду:
команда:

``` Install-Package System.Linq.Dynamic.Core```

ВАЖНО. Обязательно установите System.Linq.Dynamic.Core, а не System.Linq.Dynamic, который
его аналог .NET Framework 4.0; последний не будет работать с нашим проектом веб-приложения ASP.NET.
На момент написания последней версии пакета System.Linq.Dynamic.Core — 1.2.14.
который отлично работает для наших целей.
Для тех, кто хочет получить дополнительную информацию об этом замечательном пакете, мы предлагаем вам
обратите внимание на следующие ресурсы:
Веб-сайт NuGet: https://www.nuget.org/packages/System.Linq.Dynamic.Core/
Проект GitHub: https://github.com/StefH/System.Linq.Dynamic.Core

# Что такое ЛИНК?
Прежде чем двигаться дальше, давайте потратим пару минут на разговор о LINQ на тот маловероятный случай, когда вы
никогда ничего об этом не слышал.
LINQ, также известный как языково-интегрированный запрос, — это кодовое имя набора Microsoft .NET Framework.
технологий, которые добавляют возможности запроса данных в языки .NET, такие как C# и VB.NET. LINQ был
впервые выпущенный в 2007 году, он стал одной из основных новых функций .NET Framework 3.5.
Основная цель LINQ — дать разработчику возможность выражать структурированные запросы к данным.
использование первоклассной языковой конструкции без необходимости изучать разные языки запросов для каждого типа
источника данных (типы коллекций, SQL, XML, CSV и т. д.). Для каждого из этих основных типов источников данных
существует реализация LINQ, которая обеспечивает одинаковую обработку запросов к объектам (LINQ to Objects),
Сущности Entity Framework (LINQ to Entities), реляционные базы данных (LINQ to SQL), XML (LINQ to XML),
и так далее.

Структурированные запросы LINQ могут быть выражены с использованием двух альтернативных, но в то же время взаимодополняющих подходов:

- Lambda expressions, such as the following:

```Csharp
var city = _context.Cities.Where(c => c.Name == "New York").First();
```

- Query expressions, such as the following:
```Csharp
var city = (from c in _context.Cities where c.Name == "New York" select c).First();
```
Оба дают один и тот же результат с одинаковой производительностью, поскольку выражения запроса переводятся в
их эквиваленты лямбда-выражений перед компиляцией.

# Плюсы и минусы System.Linq.Dynamic.Core
Теперь, поскольку LINQ включен в .NET Framework начиная с версии 3.5 и поставляется с каждым
последующая версия ASP.NET с тех пор, что на самом деле делает пакет System.Linq.Dynamic.Core
делать и почему мы его используем?
Как мы видим из двух предыдущих примеров, как лямбда-выражения, так и выражения запроса
использовать строго типизированный подход: всякий раз, когда мы запрашиваем объект любого типа с помощью LINQ, источник
type – вместе со всеми свойствами, которые мы хотим проверить нашим запросом – должны быть известны компилятору. Это означает, что мы не сможем использовать эти методы с универсальными объектами (объектами) или
типы (<T>). Вот тут-то на помощь и приходит Linq.Dynamic, позволяющий разработчику писать лямбда-выражения.
выражения и выражения запроса с литеральными строками и переводить их в строго типизированный формат.
эквиваленты с использованием отражения.
Вот тот же запрос, что и раньше, написанный с использованием System.Linq.Dynamic.Core:

```Csharp
var city = _context.Cities.Where("Name = @1", "New York").First();
```
Мы сразу видим разницу, а также то огромное преимущество, которое мы можем получить, используя такие
подход: мы сможем строить наши запросы динамически, независимо от того, имеем ли мы дело
со строго типизированными объектами или универсальными типами, как мы это делали в исходном коде ApiResult a.
совсем недавно.

Однако у такого подхода будет и серьезный недостаток: наш код будет менее тестируемым и
слишком подвержен ошибкам, по крайней мере, по двум важным причинам:
- Мы окажемся на расстоянии буквальной строки от ошибок запроса, которые почти всегда приводят к серьезным
сбои
- Риск нежелательных запросов (включая атаки SQL-инъекций) может возрасти экспоненциально.
в зависимости от того, как мы строим эти запросы и/или откуда мы получаем наши динамические строки

Первая проблема плоха, но вторая еще хуже: открытость для атак с использованием SQL-инъекций может иметь разрушительные последствия, и поэтому этого следует избегать любой ценой, включая избавление от Системы.
Пакет Linq.Dynamic.Core.

# Предотвращение SQL-инъекции
К счастью, нам не нужно этого делать; хотя мы получаем две потенциально опасные переменные
строки, поступающие от клиента — sortColumn и sortOrder — мы уже внедрили эффективные
контрмеры для них обоих в предыдущем исходном коде ApiResult.
Вот что мы сделали для sortOrder:

```Csharp
sortOrder = !string.IsNullOrEmpty(sortOrder)
 && sortOrder.ToUpper() == "ASC"
 ? "ASC"
 : "DESC";
```
Как мы видим, мы преобразуем его либо в «ASC», либо в «DESC», прежде чем использовать где-либо, таким образом не оставляя никаких
возможности для SQL-инъекций.
Параметр sortColumn обрабатывать гораздо сложнее, поскольку теоретически он может содержать любые
возможное имя столбца, сопоставленное с любым из наших объектов: id, name, lat, lon, iso2, iso3... Если бы мы
проверьте их все, нам понадобится очень длинный условный блок! Не говоря уже о том, что это будет
также будет очень сложно поддерживать всякий раз, когда мы добавляем в наш проект новые объекты и/или свойства.
Именно по этой причине мы выбрали совершенно другой – и, возможно, лучший – подход, который опирается на
при использовании следующего метода IsValidProperty:

```Csharp
public static bool IsValidProperty(
 string propertyName,
 bool throwExceptionIfNotFound = true)
{
 var prop = typeof(T).GetProperty(
 propertyName,
 BindingFlags.IgnoreCase |
 BindingFlags.Public |
 BindingFlags.Instance);
 if (prop == null && throwExceptionIfNotFound)
 throw new NotSupportedException($"ERROR: Property '{propertyName}' does
not exist.");
 return prop != null;
}
```
Как мы видим, этот метод проверяет, что данное имя свойства соответствует существующему типизированному
Свойство в нашем универсальном классе сущностей <T>: если оно есть, оно возвращает True; в противном случае он выдает
NotSupportedException (или возвращает False, в зависимости от того, как мы его вызываем). Это отличный способ защититься
наш код против SQL-инъекции, потому что абсолютно невозможно, чтобы вредоносная строка совпадала
одно из свойств нашей сущности.

Проверка имени свойства реализована с помощью System.Reflection — метода, который используется для проверки и/или получения метаданных типов во время выполнения. Работать с
отражения, нам нужно включить пространство имен System.Reflection в наш класс, что
это именно то, что мы сделали в начале исходного кода нашего улучшенного ApiResult.

Как мы видим, взглянув на исходный код ApiResult, такой метод вызывается в
следующий путь

```Csharp
if (!string.IsNullOrEmpty(sortColumn)
 && IsValidProperty(sortColumn))
{
 /// if we are here, sortColumn is safe to use
}
```
Эти фигурные скобки определяют нашу зону безопасности SQL-инъекций: пока мы имеем дело с sortColumn внутри
их, нам не о чем беспокоиться.

По правде говоря, даже после реализации этого защитного подхода небольшая угроза все еще существует.
мы можем быть подвержены: если у нас есть зарезервированные столбцы/свойства, которые нам не нужны
клиент, с которым нужно взаимодействовать (например, системные столбцы), предыдущая контрмера
не помешает ему это сделать; хотя и не в состоянии признать их существование или
чтобы прочитать свои данные, опытный пользователь все равно может «упорядочить» результаты таблицы по
их – при условии, что пользователь каким-то образом знает их точное имя.
Если мы хотим предотвратить эту удаленную (но теоретически возможную) утечку, мы можем установить для этих свойств частные значения (поскольку мы указали нашему методу IsValidProperty проверять только общедоступные
свойства) и/или переосмыслить всю логику метода, чтобы она лучше соответствовала нашим потребностям безопасности.

# Обновление CitiesController
Теперь, когда мы улучшили наш класс ApiResult, мы можем реализовать его в нашем CitiesController.
Откройте файл /Controllers/CitiesController.cs и соответствующим образом измените его содержимое (обновлено).
строки выделены):

```Csharp
// GET: api/Cities
// GET: api/Cities/?pageIndex=0&pageSize=10
// GET: api/Cities/?pageIndex=0&pageSize=10&sortColumn=name&
// sortOrder=asc
[HttpGet]
public async Task<ActionResult<ApiResult<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null)
{
 return await ApiResult<City>.CreateAsync(
 _context.Cities,
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder);
}
```

Благодаря этим двум новым параметрам наш метод GetCities сможет сортировать города по назначению.
мы хотим.

Мы закончили с серверной частью; давайте теперь перейдем к интерфейсу

# Обновление приложения Angular
Как всегда, нам нужно изменить три файла:
- Файл angular-material.module.ts, куда нам нужно добавить новый @angular/material.
модуль
- Файл cities.component.ts для реализации бизнес-логики сортировки.
- Файл cities.component.html для привязки новых переменных, методов и ссылок, определенных
в файле .ts в шаблоне пользовательского интерфейса
Давайте сделаем это.

# angular-material.module.ts
Откройте файл /src/app/angular-material.module.ts и добавьте ссылки на MatSortModule:

```ts
import { MatSortModule } from '@angular/material/sort';
```
Не забудьте также обновить массивы импорта и экспорта @NgModule.
С этого момента мы сможем импортировать классы, связанные с MatSortModule, в любой компонент Angular.

# cities.component.ts
После этого откройте файл города.компонент.тс и внесите следующие изменения (обновленные строки
выделены):

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from './../../environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: MatTableDataSource<City>;
 defaultPageIndex: number = 0;
defaultPageSize: number = 10;
 public defaultSortColumn: string = "name";
 public defaultSortOrder: "asc" | "desc" = "asc";
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 @ViewChild(MatSort) sort!: MatSort;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.loadData();
 }
 loadData() {
 var pageEvent = new PageEvent();
 pageEvent.pageIndex = this.defaultPageIndex;
 pageEvent.pageSize = this.defaultPageSize;
 this.getData(pageEvent);
 }
 getData(event: PageEvent) {
 var url = environment.baseUrl + 'api/Cities';
 var params = new HttpParams()
 .set("pageIndex", event.pageIndex.toString())
 .set("pageSize", event.pageSize.toString())
 .set("sortColumn", (this.sort)
 ? this.sort.active
 : this.defaultSortColumn)
 .set("sortOrder", (this.sort)
 ? this.sort.direction
 : this.defaultSortOrder);
 this.http.get<any>(url, { params })
 .subscribe(result => {
 console.log(result);
 this.paginator.length = result.totalCount;
 this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.cities = new MatTableDataSource<City>(result.data);
 }, error => console.error(error));
}
}
```

Вот разбивка наиболее важных изменений:
- Мы импортировали ссылку MatSort из пакета @angular/material.
- Мы добавили четыре новые переменные класса для установки значений по умолчанию для разбиения на страницы и сортировки: defaultPageIndex,
defaultPageSize, defaultSortColumn и defaultSortOrder. Два из них определены
как общедоступные, поскольку нам нужно использовать их из шаблона HTML посредством двусторонней привязки данных.
- Мы перенесли первоначальный вызов getData() из конструктора класса в новый централизованный вызов loadData().
функцию, чтобы мы могли привязать ее к таблице (как мы вскоре увидим).
- Мы добавили параметры HTTP GET sortColumn и sortOrder в наш объект HttpParams, поэтому
что мы можем отправить информацию о сортировке на сервер.
Теперь мы можем перейти к файлу шаблона HTML.

# cities.component.html
Откройте файл города.компонент.html и внесите следующие изменения (обновленные строки выделены):

```html
<table mat-table [dataSource]="cities"
 class="mat-elevation-z8"
 [hidden]="!cities"
 matSort (matSortChange)="loadData()"
 [matSortActive]="defaultSortColumn"
 [matSortDirection]="defaultSortOrder">
 <!-- Id Column -->
 <ng-container matColumnDef="id">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>ID</th>
 <td mat-cell *matCellDef="let city"> {{city.id}} </td>
 </ng-container>
 <!-- Name Column -->
 <ng-container matColumnDef="name">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
 <td mat-cell *matCellDef="let city"> {{city.name}} </td>
 </ng-container>
 <!-- Lat Column -->
 <ng-container matColumnDef="lat">
<th mat-header-cell *matHeaderCellDef mat-sort-header>Latitude
 </th>
 <td mat-cell *matCellDef="let city"> {{city.lat}} </td>
 </ng-container>
 <!-- Lon Column -->
 <ng-container matColumnDef="lon">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Longitude
 </th>
 <td mat-cell *matCellDef="let city"> {{city.lon}} </td>
 </ng-container>
 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>
```

Вот что мы сделали вкратце:
- Мы добавили следующие атрибуты в элемент ```<table mat-table>```:
- matSort: ссылка на локальную переменную matSort, которую мы добавили в city.comComponent.
ts файл на ранней стадии
- (matSortChange): привязка события, которая будет выполнять метод sortData() (также
определенный ранее в файле .ts) при каждой попытке сортировки пользователя
- matSortActive и matSortDirection: две привязки данных к defaultSortColumn.
и переменные defaultSortOrder, которые мы ранее определили в файле .ts.
- Мы добавили атрибут mat-sort-header к каждому элементу ```<th mat-header-cell>``` (по одному для
каждый столбец таблицы)

Теперь мы можем понять, почему мы не использовали изящный URL-адрес, который мы определили ранее в нашем ASP.NET.
CitiesController и вместо этого выбрал стандартные параметры GET: этот подход
позволяет нам программно добавлять неопределенное количество параметров HTTP GET в нашу
запрос благодаря классу HttpParams из пакета @angular/common/http.

Давайте быстро проверим это, нажав F5 и перейдя к представлению «Города». Вот что мы должны уметь
чтобы увидеть:

![image](https://github.com/artemovsergey/Angular/assets/26972859/b1e85abb-f4d0-4022-8908-fa0f7d3b6dc5)

Города теперь отсортированы в алфавитном порядке по возрастанию. Если мы нажмем на различные заголовки столбцов,
мы можем изменить их порядок по своему усмотрению: первый щелчок отсортирует содержимое по возрастанию, а
второй сделает наоборот.

Стоит отметить, что функции разбиения на страницы и сортировки могут без проблем сосуществовать;
разумеется, всякий раз, когда мы пытаемся изменить сортировку таблицы, подкачка просто откатывается назад.
на первую страницу.

Теперь, когда сортировка реализована, осталась только одна недостающая функция: фильтрация.

# Добавление фильтрации
Если мы думаем, что нам удастся обойтись другим компонентом, на этот раз мы будем разочарованы: Angular Material не предоставляет специального модуля, который можно было бы использовать для целей фильтрации. Этот
означает, что мы не можем полагаться на стандартный подход для добавления фильтрации в нашу таблицу; мы должны выяснить
разумный подход самостоятельно.
В общих чертах, лучшее, что можно сделать всякий раз, когда нам нужно написать код функции самостоятельно, — это начать
визуализируем то, как мы хотим, чтобы оно выглядело: например, мы можем представить поле ввода «Поиск», лежащее поверх
нашу таблицу, которая заставит наш CitiesComponent перезагрузить данные городов с сервера – через
его метод getData() — всякий раз, когда мы что-то в него вводим. Как это звучит?

Попробуем составить план действий:
1. Как всегда, нам нужно расширить наш класс ApiResult, чтобы программно обрабатывать фильтрацию.
задача на стороне сервера
2. Нам также потребуется изменить сигнатуру метода действия GetCities() нашего .NET.
CitiesController, чтобы мы могли получить дополнительную информацию от клиента.
3. Сразу после этого нам нужно будет реализовать логику фильтрации в нашем Angular CitiesComponent.
4. В конце концов нам нужно будет добавить текстовое поле ввода в HTML-файл шаблона CitiesComponent.
и привязать к нему событие, чтобы запустить процесс получения данных при вводе чего-либо
5. Прежде чем двигаться дальше, мы поговорим о влиянии наших решений на производительность.
функция фильтрации и как мы можем ее решить
Теперь, когда мы это сделали, давайте сделаем все возможное, чтобы воплотить этот план в жизнь.

# Расширение ApiResult (снова)
Похоже, нам нужно выполнить еще одно обновление нашего любимого класса ApiResult, чтобы добавить фильтрацию.
поддержка уже существующей логики разбиения на страницы и сортировки.
По правде говоря, нас не заставляют делать все в классе ApiResult: мы можем пропустить эту часть.
полностью и просто добавьте следующее в наш существующий CitiesController:

```Csharp
[HttpGet]
public async Task<ActionResult<ApiResult<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 // first we perform the filtering...
 var cities = _context.Cities;
 if (!string.IsNullOrEmpty(filterColumn)
 && !string.IsNullOrEmpty(filterQuery))
 {
 cities= cities.Where(c => c.Name.StartsWith(filterQuery));
 }
 // ... and then we call the ApiResult
 return await ApiResult<City>.CreateAsync(
 cities,
pageIndex,
 pageSize,
 sortColumn,
 sortOrder);
}
```
Это определенно жизнеспособный подход. На самом деле, если бы мы не использовали System.Linq.Dynamic.
Базовая библиотека пакетов, скорее всего, это будет единственно возможный подход; у нас не было бы возможности
программно установить фильтр столбца, используя внешний класс, который работает с универсальным IQueryable<T>
объекты, поскольку такой класс не будет знать о типе сущности и именах свойств.
К счастью, у нас есть этот пакет, поэтому мы можем избежать выполнения предыдущих изменений (или
откатите их, если мы это уже сделали) и измените наш файл класса /Data/ApiResult.cs в
вместо этого следующим образом:

```Csharp
using Microsoft.EntityFrameworkCore;
using System.Linq.Dynamic.Core;
using System.Reflection;
namespace WorldCitiesAPI.Data
{
 public class ApiResult<T>
 {
 /// <summary>
 /// Private constructor called by the CreateAsync method.
 /// </summary>
 private ApiResult(
 List<T> data,
 int count,
 int pageIndex,
 int pageSize,
 string? sortColumn,
 string? sortOrder,
 string? filterColumn,
 string? filterQuery)
 {
 Data = data;
 PageIndex = pageIndex;
 PageSize = pageSize;
 TotalCount = count;
TotalPages = (int)Math.Ceiling(count / (double)pageSize);
 SortColumn = sortColumn;
 SortOrder = sortOrder;
 FilterColumn = filterColumn;
 FilterQuery = filterQuery;
 }
 #region Methods
 /// <summary>
 /// Pages, sorts and/or filters a IQueryable source.
 /// </summary>
 /// <param name="source">An IQueryable source of generic
 /// type</param>
 /// <param name="pageIndex">Zero-based current page index
 /// (0 = first page)</param>
 /// <param name="pageSize">The actual size of
 /// each page</param>
 /// <param name="sortColumn">The sorting column name</param>
 /// <param name="sortOrder">The sorting order ("ASC" or
 /// "DESC")</param>
 /// <param name="filterColumn">The filtering column
 /// name</param>
 /// <param name="filterQuery">The filtering query (value to
 /// lookup)</param>
 /// <returns>
 /// A object containing the IQueryable paged/sorted/filtered
 /// result
 /// and all the relevant paging/sorting/filtering navigation
 /// info.
 /// </returns>
 public static async Task<ApiResult<T>> CreateAsync(
 IQueryable<T> source,
 int pageIndex,
 int pageSize,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
 {
 if (!string.IsNullOrEmpty(filterColumn)
 && !string.IsNullOrEmpty(filterQuery)
&& IsValidProperty(filterColumn))
 {
 source = source.Where(
 string.Format("{0}.StartsWith(@0)",
 filterColumn),
 filterQuery);
 }
 var count = await source.CountAsync();
 if (!string.IsNullOrEmpty(sortColumn)
 && IsValidProperty(sortColumn))
 {
 sortOrder = !string.IsNullOrEmpty(sortOrder)
 && sortOrder.ToUpper() == "ASC"
 ? "ASC"
 : "DESC";
 source = source.OrderBy(
 string.Format(
 "{0} {1}",
 sortColumn,
 sortOrder)
 );
 }
 source = source
 .Skip(pageIndex * pageSize)
 .Take(pageSize);
 var data = await source.ToListAsync();

 return new ApiResult<T>(
 data,
 count,
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
 }
/// <summary>
 /// Checks if the given property name exists
 /// to protect against SQL injection attacks
 /// </summary>
 public static bool IsValidProperty(
 string propertyName,
 bool throwExceptionIfNotFound = true)
 {
 var prop = typeof(T).GetProperty(
 propertyName,
 BindingFlags.IgnoreCase |
 BindingFlags.Public |
 BindingFlags.Static |
 BindingFlags.Instance);
 if (prop == null && throwExceptionIfNotFound)
 throw new NotSupportedException($"ERROR: Property
'{propertyName}' does not exist.");
 return prop != null;
 }
 #endregion
 #region Properties
 /// <summary>
 /// IQueryable data result to return.
 /// </summary>
 public List<T> Data { get; private set; }
 /// <summary>
 /// Zero-based index of current page.
 /// </summary>
 public int PageIndex { get; private set; }
 /// <summary>
 /// Number of items contained in each page.
 /// </summary>
 public int PageSize { get; private set; }
 /// <summary>
 /// Total items count
/// </summary>
 public int TotalCount { get; private set; }
 /// <summary>
 /// Total pages count
 /// </summary>
 public int TotalPages { get; private set; }
 /// <summary>
 /// TRUE if the current page has a previous page,
 /// FALSE otherwise.
 /// </summary>
 public bool HasPreviousPage
 {
 get
 {
 return (PageIndex > 0);
 }
 }
 /// <summary>
 /// TRUE if the current page has a next page, FALSE otherwise.
 /// </summary>
 public bool HasNextPage
 {
 get
 {
 return ((PageIndex +1) < TotalPages);
 }
 }
 /// <summary>
 /// Sorting Column name (or null if none set)
 /// </summary>
 public string? SortColumn { get; set; }
 /// <summary>
 /// Sorting Order ("ASC", "DESC" or null if none set)
 /// </summary>
 public string? SortOrder { get; set; }
/// <summary>
 /// Filter Column name (or null if none set)
 /// </summary>
 public string? FilterColumn { get; set; }
 /// <summary>
 /// Filter Query string
 /// (to be used within the given FilterColumn)
 /// </summary>
 public string? FilterQuery { get; set; }
 #endregion
 }
}
```

Вот и все. Как мы видим, нам удалось программно реализовать IQueryable<T>.Where().
метод, который фактически выполняет задачу фильтрации, благодаря другому полезному методу расширения.
предоставляется пакетом System.Linq.Dynamic.Core.
Излишне говорить, что мы снова воспользовались возможностью использовать метод IsValidProperty, чтобы защитить наш код.
против возможных попыток внедрения SQL: логика, связанная с фильтрацией (и динамический запрос LINQ), будет
выполняться только в том случае, если он возвращает True, то есть если значение параметра filterColumn соответствует существующему
общественная собственность субъекта.
Пока мы были там, мы также добавили два дополнительных свойства (FilterColumn и FilterQuery), поэтому
что мы разместим их в объекте ответа JSON, и изменили сигнатуру метода конструктора.
соответственно.

# CitiesController
Теперь мы можем открыть файл /Controllers/CitiesController.cs и внести следующие изменения:

```Csharp
[HttpGet]
public async Task<ActionResult<ApiResult<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<City>.CreateAsync(
 _context.Cities.AsNoTracking(),
 pageIndex,
 pageSize,
 sortColumn,
sortOrder,
 filterColumn,
 filterQuery);
}
```
Приведенный выше код очень похож на альтернативную реализацию, которую мы предполагали в предыдущем примере.
раздел; как мы упоминали ранее, оба подхода жизнеспособны, в зависимости от наших вкусов. Однако, поскольку
мы собираемся использовать эту же реализацию для стран в ближайшее время, эффективно используя
System.Linq.Dynamic.Core и централизация всей логики IQueryable, возможно, является лучшим подходом.
поскольку он сохраняет наш исходный код максимально СУХИМ.

Часть .NET готова; давайте перейдем к Angular.

# CitiesComponent
Откройте файл /src/app/cities/cities.comComponent.ts и обновите его содержимое следующим образом.
(измененные строки выделены):

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: MatTableDataSource<City>;
 defaultPageIndex: number = 0;
 defaultPageSize: number = 10;
 public defaultSortColumn: string = "name";
 public defaultSortOrder: "asc" | "desc" = "asc";
 defaultFilterColumn: string = "name";
 filterQuery?:string;
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 @ViewChild(MatSort) sort!: MatSort;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.loadData(null);
 }
 loadData(query?: string) {
 var pageEvent = new PageEvent();
 pageEvent.pageIndex = this.defaultPageIndex;
 pageEvent.pageSize = this.defaultPageSize;
 this.filterQuery = query;
 this.getData(pageEvent);
 }
 getData(event: PageEvent) {
 var url = environment.baseUrl + 'api/Cities';
 var params = new HttpParams()
 .set("pageIndex", event.pageIndex.toString())
 .set("pageSize", event.pageSize.toString())
 .set("sortColumn", (this.sort)
 ? this.sort.active
 : this.defaultSortColumn)
 .set("sortOrder", (this.sort)
 ? this.sort.direction
 : this.defaultSortOrder);
 if (this.filterQuery) {
 params = params
 .set("filterColumn", this.defaultFilterColumn)
 .set("filterQuery", this.filterQuery);
 }
this.http.get<any>(url, { params })
 .subscribe(result => {
 this.paginator.length = result.totalCount;
 this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.cities = new MatTableDataSource<City>(result.data);
 }, error => console.error(error));
 }
}
```
На этот раз новый код состоит всего из нескольких дополнительных строк; мы только что изменили подпись
loadData() (с типом string? необязательным, чтобы ничего не сломать) и условно
добавили пару параметров в наш HTTP-запрос — всё.

# Файл шаблона CitiesComponent (HTML)
Давайте посмотрим, что нам нужно добавить в файл шаблона /src/app/cities/cities.comComponent.html:

```html
<h1>Cities</h1>
<p>Here's a list of cities: feel free to play with it.</p>
<p *ngIf="!cities"><em>Loading...</em></p>
<mat-form-field [hidden]="!cities">
 <input matInput #filter (keyup)="loadData(filter.value)"
 placeholder="Filter by name (or part of it)...">
</mat-form-field>
<table mat-table [dataSource]="cities"
 class="mat-elevation-z8"
 [hidden]="!cities"
 matSort (matSortChange)="loadData()"
 [matSortActive]="defaultSortColumn"
 [matSortDirection]="defaultSortOrder">

```

Как мы видим, мы только что добавили элемент <mat-form-field> с обычной привязкой атрибута [скрытый]
(чтобы оно появлялось только после загрузки наших городов) и привязку события (keyup), которая запускает
метод loadData() при каждом нажатии клавиши; этот вызов также будет содержать входное значение, которое будет
обрабатывается нашим классом компонента средствами, которые мы только что там реализовали.

Единственное, что стоит отметить, это то, что мы представили новую функцию Angular в приведенном выше коде: ссылочную переменную шаблона (#filter), которая позволяет нам использовать данные из одного элемента в другой части.
шаблона. Мы сделали это для того, чтобы передать обновленное значение элемента MatInput нашему
метод ЗагрузитьДанные().

Теоретически мы могли бы использовать $event.target.value вместо того, чтобы полагаться на
в ссылочной переменной шаблона: однако мы будем использовать этот #filter в дальнейшем в
следующих главах, поэтому мы воспользовались возможностью представить его сейчас.

# CitiesComponent style (SCSS) file
Прежде чем тестировать его, нам нужно внести небольшие изменения в компонент /src/app/cities/cities.comment.
scss-файл:

```scss
table.mat-table {
 width: 100%;
}
.mat-form-field {
 font-size: 14px;
 width: 100%;
}
```
Это необходимо для того, чтобы наш новый MatInputModule охватывал все доступное пространство (оно ограничено).
по умолчанию до 180 пикселей).

# Модуль AngularMaterialModule
Подождите: мы только что сказали MatInputModule? Это верно: на самом деле кажется, что мы
в конце концов, мы действительно использовали модуль Angular Material в нашей реализации фильтрации – и навсегда
Причина в том, что оно выглядит намного лучше, чем обычное текстовое поле ввода HTML!
Однако, поскольку мы это сделали, нам нужно ссылаться на него в нашем контейнере AngularMaterialModule или
мы получим ошибку компилятора. Для этого откройте файл /src/app/angular-material.module.ts и добавьте
необходимое заявление об импорте…

```ts
import { MatInputModule } from '@angular/material/input';
```
и две ссылки в массивах импорта и экспорта @NgModule.

Вот и все: теперь мы можем нажать F5 и перейти к представлению «Города», чтобы протестировать новую функцию фильтрации. Если бы мы сделали
все правильно, мы должны увидеть что-то похожее на следующий снимок экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/227a6cf5-cfdf-4003-8091-1355952f1b13)

Если мы попытаемся ввести что-то в текстовое поле фильтра, мы должны увидеть таблицу и обновление пагинатора.
соответственно в реальном времени. Посмотрите, что произойдет, если мы введем Нью-Йорк в текстовое поле фильтра:

![image](https://github.com/artemovsergey/Angular/assets/26972859/3eac6271-fa19-4a15-a53a-faf69adaab04)

Это определенно хорошая функция фильтрации в реальном времени.

# Вопросы производительности
Прежде чем двигаться дальше, было бы разумно потратить несколько минут на обсуждение влияния на производительность.
фильтра, который мы только что реализовали.
Как мы видим, вызов метода loadData напрямую связан с событием keyup ввода HTML:
это означает, что он будет срабатывать при нажатии клавиши каждым пользователем. Это здорово с точки зрения пользовательского опыта, потому что
наши пользователи сразу же получат отфильтрованные данные по мере их ввода; однако этот фильтр реального времени также имеет
серьезный недостаток с точки зрения влияния на производительность: каждый раз, когда текст фильтра меняется (т. е. при
каждое нажатие клавиши), Angular отправляет HTTP-запрос на серверную часть для получения обновленного списка результатов.
Такое поведение по своей сути является ресурсоемким и может легко стать огромной проблемой производительности.
особенно если мы имеем дело с большими таблицами и/или неиндексированными столбцами.
Есть ли способы улучшить этот подход без ущерба для результатов, полученных с точки зрения пользователя?
опыт? По сути, ответ — да, но мы сейчас этого делать не будем: поговорим об этом подробнее.
в главе 7 «Формы и проверка данных», когда мы знакомим с понятиями устранения дребезга и регулирования.

# Добавление стран в цикл
Прежде чем двигаться дальше, как насчет того, чтобы ввести страны в курс дела? Да, это означало бы переделывать все, что мы только что сделали, во второй раз; однако теперь, когда мы знаем, как это сделать, возможно, мы будем
способен сделать это в мгновение ока... а может и нет.

Тем не менее, нам определенно следует потратить на это разумное количество времени сейчас, потому что это
будет отличным способом закрепить все, что мы узнали до сих пор, в нашей мышечной памяти.
Давайте сделаем это сейчас, чтобы мы могли перейти к чему-то еще. Чтобы не тратить страницы зря, мы просто
сосредоточьтесь здесь на наиболее важных шагах, оставив все остальное тому, что мы только что сделали с городами – и
в наш репозиторий GitHub, где находится полный исходный код того, что нам нужно сделать.

# ASP.NET
Начнем с части ASP.NET.

# CountriesController
У нас уже должен быть готов наш CountryController из главы 5 «Модель данных с Entity Framework Core», верно? Откройте этот файл и замените метод действия GetCountries() по умолчанию следующим кодом:

```Csharp
[HttpGet]
public async Task<ActionResult<ApiResult<Country>>> GetCountries(
 int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<Country>.CreateAsync(
 _context.Countries.AsNoTracking(),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
}
```
К счастью, наш класс ApiResult не зависит от типа; следовательно, мы можем использовать его там без проблем.
Кроме того, поскольку мы централизовали всю тяжелую работу, серверная часть .NET уже выполнена.

# Странная проблема с именованием JSON
Прежде чем двигаться дальше, давайте быстро протестируем компонент: нажмите F5 и введите следующий URL-адрес в поле браузера.
адресная строка: https://localhost:40443/api/Countries/?pageIndex=0&pageSize=5.
Как только мы нажмем Enter, мы увидим следующий интерфейс:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1f9d1bda-582a-4fea-8003-7499107b4e42)

Кажется, все это г... Эй, подожди: что случилось с этими именами свойств isO2 и isO3? Они
не следует так писать с большой буквы!
Чтобы понять, что там произошло, нам нужно сделать шаг назад и кое-что признать.
мы, возможно, до сих пор недооценили: преобразование CamelCase, которое совершенно новый System.Text.Json
API (представленный в .NET Core 3) автоматически делает это при сериализации всех наших классов .NET в JSON.
Мы уже говорили об этой проблеме в начале этой главы, когда видели .NET CitiesController.
JSON выводится впервые, и мы сказали, что это не имеет большого значения, поскольку Angular также ориентирован на CamelCase — нам просто нужно будет также определить различные интерфейсы с использованием CamelCase.
К сожалению, такое автоматическое преобразование в CamelCase может вызвать нежелательные побочные эффекты при работе с
со свойствами, написанными только заглавными буквами, такими как эти два; всякий раз, когда это происходит, нам нужно адаптировать наш источник
код, чтобы правильно справиться с этим:
- Самым очевидным решением было бы просто определить их в интерфейсе Angular в точном
таким же образом, то есть с использованием именно этого регистра; однако это означало бы иметь дело с этими isO2
и имена переменных isO3 во всем нашем коде Angular, что довольно уродливо и может
также может ввести в заблуждение.
- Если мы не хотим использовать эти отвратительные имена свойств, есть альтернативный – и, возможно, лучший – обходной путь, который мы можем использовать: мы можем украсить наши оскорбительные свойства с помощью
аннотация данных [JsonPropertyName], которая позволяет нам принудительно указывать имя свойства JSON независимо от соглашения о регистре по умолчанию (будь то CamelCase или PascalCase), указанного в
Стартап-класс.
Обходной путь [JsonPropertyName] кажется наиболее разумным решением, которое мы можем применить к нашим конкретным
сценарий; давайте просто согласимся и избавимся от этой проблемы навсегда!
Откройте файл /Data/Models/Country.cs и добавьте следующие строки в существующий код (новые строки
выделены):

```Csharp
/// <summary>
/// Country code (in ISO 3166-1 ALPHA-2 format)
/// </summary>
[JsonPropertyName("iso2")]
public string ISO2 { get; set; }
/// <summary>
/// Country code (in ISO 3166-1 ALPHA-3 format)
/// </summary>
[JsonPropertyName("iso3")]
public string ISO3 { get; set; }
```
Атрибут [JsonPropertyName] требует наличия следующей ссылки в верхней части файла:

```Csharp
using System.Text.Json.Serialization;
```
Теперь мы можем увидеть, будут ли эти свойства учитывать такое поведение, нажав F5 и набрав то же самое.
URL-адрес, как и раньше, в адресную строку браузера: https://localhost:40443/api/Countries/?pageInd
ex=0&pageSize=5

![image](https://github.com/artemovsergey/Angular/assets/26972859/bfadc22d-98f6-4617-bc51-4ebbcc9575e8)

Кажется, так оно и есть; благодаря этой неожиданной проблеме у нас появилась возможность добавить мощный
новое оружие в нашем арсенале ASP.NET.
Теперь нам просто нужно создать и настроить компонент Angular.

# Angular
Реализация Angular будет менее простой, чем реализация ASP.NET, поскольку нам придется
иметь дело с несколькими аспектами:
- Создание нового компонента Countrys.
- Реализация таблицы «Страны», а также функций разбиения на страницы, сортировки и фильтрации, как мы
сделал с городами
- Обновление NavComponent для добавления навигационной ссылки.

Мы уже знаем, что нам нужно делать, поскольку только что сделали это с нашим CitiesComponent.
1. Откройте командную строку.
2. Перейдите в папку /src/app/.
3. Введите nggenerateComponentCountries --module=app --skip-tests, чтобы создать ts, html,
и scss-файлы, а также новую папку /src/app/countries/.
4. В обозревателе решений создайте дополнительный файл Country.ts внутри каталога /src/app/countries/.
папка проекта WorldCities
После этого заполните новые файлы следующим содержимым.

# country.ts
Вот исходный код файла интерфейса /src/app/countries/country.ts:

```ts
export interface Country {
 id: number;
 name: string;
 iso2: string;
 iso3: string;
}
```
Здесь нет ничего нового — код очень похож на тот, что мы делали, когда создавали файл интерфейса city.ts.

# countries.component.ts
Вот исходный код файла /src/app/countries/countries.comComponent.ts:

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { Country } from './country';
@Component({
selector: 'app-countries',
templateUrl: './countries.component.html',
styleUrls: ['./countries.component.scss']
})
export class CountriesComponent implements OnInit {
public displayedColumns: string[] = ['id', 'name', 'iso2', 'iso3'];
public countries!: MatTableDataSource<Country>;
defaultPageIndex: number = 0;
defaultPageSize: number = 10;
public defaultSortColumn: string = "name";
public defaultSortOrder: "asc" | "desc" = "asc";
defaultFilterColumn: string = "name";
 filterQuery?: string;
@ViewChild(MatPaginator) paginator!: MatPaginator;
@ViewChild(MatSort) sort!: MatSort;
constructor(private http: HttpClient) {
 }
ngOnInit() {
 this.loadData();
 }
loadData(query?: string) {
 var pageEvent = new PageEvent();
 pageEvent.pageIndex = this.defaultPageIndex;
 pageEvent.pageSize = this.defaultPageSize;
 this.filterQuery = query;
 this.getData(pageEvent);
 }
getData(event: PageEvent) {
 var url = environment.baseUrl + 'api/Countries';
 var params = new HttpParams()
 .set("pageIndex", event.pageIndex.toString())
 .set("pageSize", event.pageSize.toString())
 .set("sortColumn", (this.sort)
 ? this.sort.active
 : this.defaultSortColumn)
 .set("sortOrder", (this.sort)
 ? this.sort.direction
 : this.defaultSortOrder);
 if (this.filterQuery) {
 params = params
 .set("filterColumn", this.defaultFilterColumn)
 .set("filterQuery", this.filterQuery);
}
 this.http.get<any>(url, { params })
 .subscribe(result => {
 this.paginator.length = result.totalCount;
 this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.countries = new MatTableDataSource<Country>(result.data);
 }, error => console.error(error));
 }
}
```
Опять же, это по сути зеркало файла city.commponent.ts.

# countries.component.html
Вот исходный код файла /src/app/countries/countries.comComponent.html:

```html
<h1>Countries</h1>
<p>Here's a list of countries: feel free to play with it.</p>
<p *ngIf="!countries"><em>Loading...</em></p>
<mat-form-field [hidden]="!countries">
 <input matInput #filter (keyup)="loadData(filter.value)"
 placeholder="Filter by name (or part of it)...">
</mat-form-field>
<table mat-table [dataSource]="countries"
 class="mat-elevation-z8"
 [hidden]="!countries"
 matSort (matSortChange)="loadData()"
 [matSortActive]="defaultSortColumn"
 [matSortDirection]="defaultSortOrder">
 <!-- Id Column -->
 <ng-container matColumnDef="id">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>ID</th>
 <td mat-cell *matCellDef="let country"> {{country.id}} </td>
 </ng-container>
 <ng-container matColumnDef="name">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
 <td mat-cell *matCellDef="let country"> {{country.name}} </td>
 </ng-container>
 <!-- ISO2 Column -->
 <ng-container matColumnDef="iso2">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>ISO 2</th>
 <td mat-cell *matCellDef="let country"> {{country.iso2}} </td>
 </ng-container>
 <!-- ISO3 Column -->
 <ng-container matColumnDef="iso3">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>ISO 3</th>
 <td mat-cell *matCellDef="let country"> {{country.iso3}} </td>
 </ng-container>
 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>
<!-- Pagination directive -->
<mat-paginator [hidden]="!countries"
 (page)="getData($event)"
 [pageSize]="10"
 [pageSizeOptions]="[10, 20, 50]"
 showFirstLastButtons></mat-paginator>
```
Шаблон, как и ожидалось, практически идентичен файлу шаблона города.компонент.html.

# countries.component.scss
Вот исходный код файла /src/app/countries/countries.comComponent.scss:

```scss
table.mat-table {
 width: 100%;
}
.mat-form-field {
 font-size: 14px;
 width: 100%;
}
```
Предыдущий файл настолько похож на файл city.comComponent.scss, что мы могли бы даже сослаться на него.
вместо создания нового; однако работа с отдельными файлами почти всегда является лучшим выбором,
учитывая, что нам, возможно, придется позже применить различные изменения к таблицам «Города» и «Страны».

# AppModule
Поскольку мы создали наш компонент с помощью Angular CLI, нам не нужно вносить какие-либо изменения в
Конфигурационный файл AppModule, поскольку новый компонент должен был быть зарегистрирован автоматически:
все, что нам нужно сделать, это обновить модуль маршрутизации и компонент навигации.

# Модуль AppRoutingModule
Правило маршрутизации, которое нам нужно добавить, очень похоже на то, которое мы недавно добавили в CitiesComponent:

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { CitiesComponent } from './cities/cities.component';
import { CountriesComponent } from './countries/countries.component';
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'cities', component: CitiesComponent },
 { path: 'countries', component: CountriesComponent }
];
@NgModule({
 imports: [RouterModule.forRoot(routes)],
 exports: [RouterModule]
})
export class AppRoutingModule { }
```
Новое правило маршрутизации позволит Angular обслуживать наш новый компонент CountrysComponent, когда клиент
браузер указывает на выделенный маршрут /countries. Однако наши пользователи не будут знать, что такой маршрут
существует, если мы не добавляем видимую ссылку на него в меню NavComponent; именно поэтому мы
собираюсь добавить его дальше.

# NavComponent
Откройте файл /src/app/nav-menu/nav-menu.comComponent.html и добавьте следующие выделенные строки.
к существующему коду:

```html
<header>
 <mat-toolbar color="primary">
 <button mat-icon-button [routerLink]="['/']">
 <mat-icon>
home
 </mat-icon>
 </button>
 <a mat-flat-button color="primary" [routerLink]="['/cities']">
 Cities
 </a>
 <a mat-flat-button color="primary" [routerLink]="['/countries']">
 Countries
 </a>
 </mat-toolbar>
</header>
```
вот и все!
Наш CountryComponent готов, и – если мы не допустили ошибок – он должен работать примерно так же.
как и наш любимый CitiesComponent, на доработку которого ушло так много времени.

# Тестирования CountriesComponent

Пришло время увидеть результаты нашей тяжелой работы: нажмите F5, перейдите к представлению «Страны» и ожидайте увидеть
следующее:

![image](https://github.com/artemovsergey/Angular/assets/26972859/b72e3b70-0032-43de-b76f-940b1462963d)

Если вам удалось получить тот же результат с первой попытки, это определенно означает, что вы научились
что делать; если вы этого не сделали, не волнуйтесь: вам просто нужно будет проверить, что вы сделали не так, и исправить это. Упражняться
делает совершенным.
ВАЖНО: Не обманывайтесь внешностью; обязательно проверьте, что разбиение по страницам, сортировка и фильтрация включены.
работать должным образом, прежде чем идти дальше.

Журнал консоли браузера может быть очень полезным инструментом для отладки ошибок на стороне сервера и клиента; большинство ошибок Angular сопровождаются хорошо документированным текстом исключения и
контекстная ссылка на соответствующий файл и строку исходного кода, что упрощает задачу
чтобы разработчик мог понять, что происходит под капотом.

# Краткое содержание
В этой главе речь шла о чтении данных из серверной части ASP.NET и поиске способа правильного отображения данных.
его в браузер с интерфейсом Angular.
Мы начали с использования существующего CitiesController для получения большого количества городов с помощью Angular.
компоненты; хотя обе платформы прекрасно справляются с большими объемами данных, мы быстро поняли, что нам необходимо улучшить весь процесс запроса, ответа и рендеринга данных, чтобы предоставить
нашим пользователям достойный пользовательский опыт.
Именно по этой причине мы решили использовать пакет System.Linq.Dynamic.Core .NET для обновления нашего
серверная бизнес-логика и пакет Angular Material npm, которые значительно улучшают наш клиентский пользовательский интерфейс.
Объединив мощные возможности этих двух пакетов, нам удалось реализовать множество интересных
функции: пейджинг, сортировка и фильтрация. В процессе разработки мы также воспользовались возможностью
выявлять, устранять и смягчать некоторые важные проблемы безопасности, такие как риск вредоносного внедрения SQL.
Сразу после завершения работы с городами мы перешли к странам, воспользовавшись возможностью проследить
наши шаги и закрепляют то, что мы только что узнали, в нашей мышечной памяти.
После всей нашей тяжелой работы мы можем с уверенностью сказать, что мы проделали большую работу и выполнили свою цель: сумев
читать наши данные из серверной части .NET и корректно представлять их через интерфейс с помощью Angular,
таким образом, давая конечным пользователям полную возможность видеть его и взаимодействовать с ним.
Теперь мы готовы добавить в наше приложение еще один уровень сложности: дать нашим пользователям возможность
изменять существующие данные и/или добавлять новые данные с помощью HTML-форм; эти функции необходимы для
большинство интерактивных веб-приложений, таких как CMS, форумы, социальные сети, чаты и т.п.
В следующей главе, главе 7, «Формы и проверка данных», мы увидим, как мы можем решать такие задачи.
использование реактивных форм, основного модуля Angular, который обеспечивает управляемый моделью подход к обработке
формируют входные данные, значения которых меняются со временем.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: JSON, соглашения RESTful, команды HTTP,
Статус HTTP, перехватчики жизненного цикла, подкачка на стороне клиента, подкачка на стороне сервера, сортировка, фильтрация, зависимости
инъекция и SQL-инъекция.

## ASP.NET
System.Linq, System.Linq.Dynamic.Core, IQueryable, and Entity Framework Core.

## Angular
Components, routing, modules, AppModule, HttpClient, ngIf, hidden, data binding, property binding,
attribute binding, ngFor, directives, structural directives, interpolations, templates, and template
reference variables.












































































