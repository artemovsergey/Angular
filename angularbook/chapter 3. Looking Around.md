# Настройка

Теперь, когда наш проект создан, пришло время быстро осмотреться и попытаться понять часть тяжелой работы, которую проделали шаблоны .NET и Angular SPA, чтобы заставить его работать.
Эй, подожди минутку! Не следует ли нам пропустить все эти тонкости настройки и сразу перейти к кодированию? На самом деле, да, через некоторое время мы обязательно приступим к кодированию.
Однако прежде при этом разумно выделить пару аспектов кода, которые уже были введены в действие что мы заранее будем знать, как эффективно двигаться внутри нашего проекта: где найти серверную часть
и клиентский код, куда поместить новый контент, как изменить параметры инициализации и т. д. Это также будет хорошей возможностью проверить наши базовые знания о среде Visual Studio и
пакеты, которые нам понадобятся.

Именно этим мы и собираемся заняться в этой главе. В частности, основными являются следующие
темы, которые мы собираемся затронуть:

- Обзор решения: общее описание того, с чем нам придется иметь дело.-
- Серверная часть ASP.NET: обзор проекта веб-API ASP.NET Core (HealthCheckAPI):
контроллеры, файлы конфигурации и т. д.
- Интерфейс Angular: обзор проекта Angular (HealthCheck): рабочая область, папка /src/, цикл инициализации Angular и т. д.
- Создание нового внешнего приложения с помощью Angular CLI: установка, создание и тестирование.
- Приступаем к работе: изменение конечных точек веб-API, добавление новых компонентов Angular, реализация базовой системы навигации и маршрутизации и т. д.

# Технические требования

В этой главе будут применяться все предыдущие технические требования, перечисленные в главе 2 «Подготовка» без каких-либо дополнительных ресурсов, библиотек или пакетов.
Файлы кода для этой главы можно найти здесь: https://github.com/PacktPublishing/ASP.NETCore-6-and-Angular/tree/master/Chapter_03/.


# Серверная часть ASP.NET

Внутренний стек ASP.NET содержится в следующих папках:
- Виртуальная папка «Зависимости», которая по сути заменяет старую папку «Ссылки» и содержит все внутренние, внешние и сторонние ссылки, необходимые для сборки и запуска нашего проекта.
Туда же будут помещены все ссылки на пакеты NuGet, которые мы добавим в наш проект.
- Папка /Controllers/, поставляемая с любым приложением ASP.NET на основе MVC, начиная с предыдущего выпуска платформы MVC: такая папка содержит один контроллер —
WeatherForecastController.cs – отвечает за предоставление примера прогноза погоды.
- Файлы корневого уровня — Program.cs и appsettings.json — которые будут определять конфигурацию нашего веб-приложения, включая модули и промежуточное ПО, настройки компиляции и
правила публикации; мы рассмотрим их все через некоторое время.

# Конфигурационные файлы

Начнем с рассмотрения файлов конфигурации корневого уровня и их назначения: Program.cs и appsettings.json. Эти файлы содержат конфигурацию нашего веб-приложения, включая модули
и промежуточное программное обеспечение, а также настройки и правила, специфичные для среды.

Файл WeatherForecast.cs содержит строго типизированный класс, предназначенный для возврата из метода Get.
метод WeatherForecastController: эту модель можно рассматривать как модель представления, поскольку она будет сериализована в JSON с помощью ASP.NET Core Framework. По нашему скромному мнению, авторы шаблонов должны поместил его в папку /ViewModel/ (или что-то в этом роде), а не оставлял на корневом уровне.
В любом случае, давайте пока просто проигнорируем его, поскольку это не файл конфигурации, и сосредоточимся на остальном.

# Program.cs

Файл Program.cs, скорее всего, заинтригует большинство опытных программистов ASP.NET, поскольку мы обычно не видим его в проекте веб-приложения. Впервые представленный в ASP.NET Core 1.0, файл Program.

Основная цель файла cs — создать построитель: фабричный объект, используемый средой выполнения .NET Core для настройки
и создайте интерфейс, в котором будет размещаться наше веб-приложение.
В первых версиях ASP.NET Core (до 2.2) сборщик назывался WebHostBuilder, а хостинг интерфейс был известен как IWebHost; в .NET 3.0 они стали HostBuilder и IHost соответственно,
благодаря введению универсального хоста, более универсального хоста, который может поддерживать другие рабочие нагрузки, такие как
рабочие службы, службы gRPC и службы Windows.

Замечание: Приятно это знать, но что такое хост? В нескольких словах это контекст выполнения
любое приложение ASP.NET Core. В веб-приложении хост должен реализовать IHost.
интерфейс, который предоставляет набор веб-функций и сервисов, которые будут
используется для обработки HTTP-запросов.
Предыдущее утверждение может привести к предположению, что веб-хост и веб-сервер
это одно и то же. Однако очень важно понимать, что это не так, поскольку они
служат совершенно разным целям. Проще говоря, за запуск приложения отвечает хост.
и управление временем жизни, в то время как сервер отвечает за прием HTTP-запросов.
Часть ответственности хоста включает обеспечение того, чтобы службы приложения и
сервер доступен и правильно настроен.
Мы можем думать о хосте как о обертке вокруг сервера: хост настроен на
использовать конкретный сервер, в то время как сервер не знает своего хоста.

В .NET 6 по-прежнему можно использовать подход общего хоста, но рекомендуемым способом настройки веб-приложения является новая модель хостинга, представленная в этой версии, о которой мы кратко упомянули только что.
Новый подход основан на новом классе WebApplicationBuilder со встроенной реализацией
IHostBuilder и IHost: это небольшое, но эффективное улучшение делает общую логику Program.cs
гораздо проще для новых разработчиков понять, не меняя базовый подход на основе хоста.
Если мы откроем файл Program.cs и посмотрим на код, мы увидим, что представляет собой новый минимальный шаблон.
выглядит как:

```Csharp
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/
swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
 app.UseSwagger();
 app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();
```
Как мы легко видим, новый код в основном предназначен для выполнения следующих задач:
• Создайте экземпляр WebApplicationBuilder (строка 1).
• Добавьте некоторые услуги (строки 5–8).
• Используйте конструктор для создания объекта WebApplication (строка 10).
• Настройте приложение с необходимым промежуточным программным обеспечением (строки 13–23).
• Запустите приложение (строка 25).
Интерфейс IHost, о котором мы только что говорили, реализуется объектом WebApplication и
Доступ к нему можно получить через общедоступное свойство Host (app.Host).

Как мы видим, старый подход выглядит намного сложнее новой версии: нам пришлось иметь дело с
с целой кучей вложенных лямбда-выражений, обратите внимание на множество перегрузок, учитывающих конфигурацию, и
самое главное, было огромное количество исходного кода; возможно, слишком много для начальной загрузки
класс, особенно для новичка. Неудивительно, что команда ASP.NET Core приложила все усилия, чтобы упростить
Все это.
Давайте вернемся к этому новому подходу и более подробно рассмотрим, что делает улучшенный файл Program.cs.
после создания экземпляра WebApplication в локальной переменной приложения:

```Csharp
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
 app.UseSwagger();
 app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();
```
Код очень читабелен, поэтому мы легко можем понять, что здесь происходит: первая строка комментария
ясно объясняет это: мы настраиваем конвейер HTTP-запросов, загружая необходимое промежуточное программное обеспечение.
и сервисы, которые будут использоваться нашим веб-приложением.

Оператор if, который регистрирует пару промежуточных программ только в том случае, если приложение запускается в среде разработки: оба этих промежуточных программного обеспечения «разработки» связаны с Swagger, который
это то, о чем мы поговорим через некоторое время.
- Еще один блок промежуточного программного обеспечения, который будет использоваться в любой среде: HttpsRedirection,
который будет обрабатывать перенаправления HTTP-to-HTTPS; Авторизация, которая позволяет получить доступ к некоторым API
запросы должны быть доступны только авторизованным пользователям. Обратите внимание, как эти методы вызываются без
параметры: это всего лишь означает, что их настроек по умолчанию нам более чем достаточно, так что есть
здесь нечего настраивать или переопределять.
- После специфичного для среды и постоянно включенного промежуточного программного обеспечения следует вызов MapControllers.
метод, который добавляет конечные точки, необходимые методам действий контроллера для обработки
входящие HTTP-запросы. Мы подробно поговорим об этом в следующих главах, когда будем
иметь дело с аспектами маршрутизации на стороне сервера. А пока отметим, что метод вызывается без
любые параметры, что означает, что мы не указываем здесь какой-либо собственный маршрут: это означает, что
мы просто используем правила маршрутизации по умолчанию, предусмотренные соглашениями об именах платформы,
по крайней мере на данный момент.
- И последнее, но не менее важное: вызов метода Run, который запускает приложение и блокирует
вызывающий поток до завершения работы IHost.

Замечание. Стоит отметить, что промежуточное ПО и сервисы, добавленные в HTTP-конвейер, будут
обрабатывать входящие запросы в порядке регистрации сверху вниз. Это означает
что HttpsRedirection будет иметь приоритет над авторизацией, которая займет
поместите перед методом MapControllers и т. д. Такое поведение очень важно и может привести к неожиданным результатам, если к нему относиться несерьезно, как показано ниже.
Поток переполнения стека: https://stackoverflow.com/questions/52768852/

Стоит отметить, что файл Program.cs не содержит никаких ссылок на промежуточное программное обеспечение StaticFiles, а это означает, что наш веб-API не сможет обслуживать статические файлы, такие как TXT, CSS, JS, изображения и т. д.
и видео. Это неудивительно, поскольку мы планируем предоставлять все эти файлы из приложения Angular (или через
третья сторона, например сеть доставки контента). Это еще одно большое отличие от однопроектного
подход, при котором нам пришлось бы добавить поддержку статических файлов для обслуживания всех файлов Angular,
пакеты и ресурсы – по крайней мере, на этапе разработки.

# appsettings.json

Файл appsettings.json — это просто замена старого доброго файла Web.config; синтаксис XML
был заменен более читаемым и значительно менее подробным форматом JSON. Более того,
новая модель конфигурации основана на настройках «ключ-значение», которые можно получить из широкого спектра
источников, включая, помимо прочего, файлы JSON, используя централизованный интерфейс.
После получения к ним можно легко получить доступ в нашем коде, используя внедрение зависимостей через литерал.
строки (с использованием интерфейса IConfiguration).

Это можно продемонстрировать, открыв файл WeatherForecastController.cs и изменив
конструктор следующим образом (новые/обновленные строки выделены):

```Csharp
public WeatherForecastController(
 ILogger<WeatherForecastController> logger,
 IConfiguration configuration
 )
{
 _logger = logger;
 var defaultLogLevel = configuration["Logging:LogLevel:Default"];
}
```
Если мы поместим точку останова в конце конструктора и запустим наш проект в режиме отладки, мы сможем
проверьте, что переменная defaultLogLevel будет содержать строку «Информация», что именно
значение, указанное в файле appsettings.json.

Замечание: Те, кто не любит иметь дело со строковыми литералами для доступа к файлам конфигурации, могут воспользоваться
возможность определить собственный класс POCO, который будет внутренне читать значения IConfiguration
и вернуть их как именованные свойства: однако, поскольку нам не понадобится доступ к этим значениям
часто, ради простоты, мы будем избегать реализации таких строго типизированных
логику и просто используйте буквальный подход, показанный выше.

# appsettings.Development.json

Стоит отметить, что существует также файл appsettings.Development.json, вложенный ниже основного.
Такой файл служит той же цели, что и старый файл Web.Debug.config, который широко использовался во времена
период ASP.NET 4.x. Короче говоря, эти дополнительные файлы можно использовать для указания дополнительных пар конфигураций ключ/значение (и/или переопределения существующих) для конкретных сред.
Чтобы лучше понять концепцию, давайте немного изменим поведение ведения журнала по умолчанию.
среды разработки.
Откройте файл appsettings.Development.json и обновите следующие строки:

```json
{
 "Logging": {
 "LogLevel": {
 "Default": "Debug",
 "Microsoft.AspNetCore": "Warning"
 }
 }
}
```
После внесения этого изменения каждый раз, когда наш проект веб-API запускается в среде разработки, для уровня журнала по умолчанию будет установлено значение «Отладка», а не «Информация», которое по-прежнему будет значением по умолчанию.
уровень журнала для других сред – пока мы не создадим другие настройки приложения.<EnvironmentName>.json
файлы, чтобы переопределить его.

Предполагая, что здесь мы все поняли, перейдем к основным игрокам любого ядра ASP.NET.
проект: Контроллеры.

# Контроллеры

Контроллеры являются основой большинства приложений ASP.NET Core, поскольку они имеют право обрабатывать
входящие HTTP-запросы. Более конкретно, контроллер используется для определения набора действий (или действий).
методы), которые по сути представляют собой методы, вызываемые промежуточным программным обеспечением маршрутизации для обработки
запросы, сопоставленные с ними посредством правил маршрутизации.
Контроллеры логически группируют схожие действия: такие механизмы агрегирования позволяют разработчикам
удобно определять общие наборы правил не только для маршрутизации, но и для кэширования, авторизации,
и другие настройки, коллективное применение которых может принести пользу.

В типичном проекте ASP.NET MVC контроллеры в основном используются для предоставления представлений клиенту, который
содержит статический или динамический HTML-контент. Это не относится к проектам веб-API, где их основной
Целью является предоставление вывода JSON (REST API), ответов на основе XML (веб-службы SOAP), статических или
динамически создаваемый ресурс (файлы JPG, JS и CSS) или даже простой HTTP-ответ (например,
перенаправление HTTP 301) без тела содержимого.
В типичном проекте ASP.NET MVC все контроллеры наследуются от класса Controller, что добавляет
поддержка просмотров; в проектах веб-API, поскольку им не нужно обслуживать представления, лучше их иметь
вместо этого расширите класс ControllerBase, который является более легким.

Замечание: Этому подходу также соответствует шаблон проекта ASP.NET Core Web API, который мы используем:
если мы посмотрим на исходный код WeatherForecastController, мы увидим, что он является производным
из класса ControllerBase.

Единственным исключением из этой хорошей практики является случай, когда мы планируем использовать один и тот же контроллер для обслуживания обоих
представления и веб-API: в этом случае получение их от контроллера является наиболее логичным и удобным выбором.

# Контроллер прогноза погоды

Признавая все это, мы уже можем сделать вывод, что единственный образец WeatherForecastController
Содержащийся в папке /Controllers/ предназначен для предоставления набора веб-API, которые будут использоваться
Угловой фронтенд. Чтобы быстро это проверить, нажмите F5, чтобы запустить наши проекты в режиме отладки и выполнить
маршрут по умолчанию, введя следующий URL-адрес: https://localhost:40443/weatherforecast.
Если мы помним, что делали в предыдущих главах, мы уже знаем, что это конечная точка URL.
для локального веб-сервера Kestrel (или IISExpress), на котором размещаются проекты веб-API.

Замечание: Фактический номер порта может отличаться в зависимости от URL-адреса прокси-сервера SPA, назначенного
Visual Studio и хранится в файлах конфигурации проекта. Если вы хотите использовать разные
Порты HTTP и/или HTTPS следуйте инструкциям, которые мы предоставили в Главе 2, Получение
Готовый.

При этом будет выполнен метод Get(), определенный в файле WeatherForecastController.cs. Как мы можем видеть
посмотрев исходный код, такой метод имеет возвращаемое значение IEnumerable<WeatherForecast>,
это означает, что он вернет несколько объектов типа WeatherForecast.
Если мы скопируем предыдущий URL-адрес в браузер и выполним его, мы должны увидеть массив JSON случайных чисел.
сгенерированные данные, как показано на следующем снимке экрана:

# Представляем OpenAPI (Swagger)

Прежде чем перейти к проекту внешнего интерфейса Angular, нам следует ознакомиться с еще одной внутренней функцией: OpenAPI, ранее известный как Swagger.
Те, кто имеет некоторый опыт работы с веб-сервисами, наверняка уже слышали такое имя: в очень
Короче говоря, спецификация OpenAPI (OAS) — это независимая от языка спецификация для документирования и
описать REST API. Его основная роль — позволить компьютерам, как и людям, однозначно понимать
возможности REST API без прямого доступа к исходному коду.

Добавление поддержки OpenAPI в проект веб-службы RESTful предоставит некоторые важные преимущества, такие как:
- Минимизация объема работы, необходимой для подключения развязанных услуг.
- Сокращение времени, необходимого для точного документирования услуги.
Если мы примем во внимание, насколько важными стали эти аспекты за последние несколько лет, мы легко сможем понять, насколько важными стали эти аспекты за последние несколько лет.
почему OpenAPI может быть включен по умолчанию в большинство шаблонов API Visual Studio: тот, который мы использовали
Создание нашего проекта HealthCheckAPI не является исключением, как мы видели в главе 2 «Подготовка», и
в начале этой главы, когда мы рассматривали промежуточное программное обеспечение, включенное в файл Program.cs.
Точнее, реализация OpenAPI по умолчанию, добавленная нашим шаблоном, называется Swashbuckle.
и доступен в пакете NuGet Swashbuckle.AspNetCore. Однако, поскольку мы проверили
Включите поддержку OpenAPI, когда мы создавали наш проект еще в главе 2 «Подготовка», нам не нужно
чтобы добавить его явно: он уже включен в наш проект.
Чтобы проверить, установлен ли пакет NuGet Swashbuckle.AspNetCore, щелкните правой кнопкой мыши
Узел проекта HealthCheckAPI в обозревателе решений и выберите «Управление пакетами NuGet». Пакет
должно быть четко видно на вкладке «Установлено», как показано на следующем снимке экрана:

Добавление Swashbuckle в наш проект позволяет нам использовать три разных компонента:
- Swashbuckle.AspNetCore.Swagger: промежуточное программное обеспечение, которое можно использовать для предоставления объектов SwaggerDocument в качестве конечных точек JSON.
- Swashbuckle.AspNetCore.SwaggerGen: генератор, создающий объекты SwaggerDocument.
непосредственно из маршрутов, контроллеров и моделей приложения.
- Swashbuckle.AspNetCore.SwaggerUI: пользовательский интерфейс, который использует Swagger JSON для создания
богатый и настраиваемый пользовательский интерфейс для визуального документирования веб-API
Если мы снова посмотрим на существующий исходный код Program.cs, мы увидим, что эти компоненты уже
присутствует в конвейере инициализации нашего приложения: однако SwaggerUI в настоящее время доступен только в нашем
Среда разработки – какой смысл имеет смысл, поскольку мы не знаем, хотим ли мы ее публиковать
(еще). Публичное документирование службы веб-API может быть полезным, если нам нужны сторонние службы.
использовать его, но это может стать серьезным недостатком безопасности, конфиденциальности и/или производительности, если мы хотим сохранить наши
конечные точки (и данные) только для наших глаз.
На самом деле, сохранение SwaggerUI доступным только во время разработки кажется хорошей идеей.
по крайней мере сейчас: давайте воспользуемся этой возможностью, чтобы хорошенько на это взглянуть.
Для этого нажмите F5, чтобы запустить наши проекты в режиме отладки и выполнить конечную точку Swagger UI по умолчанию:
https://localhost:40443/сваггер


Как мы видим, SwaggerEndpoint, который мы настроили в файле Program.cs, упоминается внутри
гиперссылка прямо под основным заголовком. Если мы нажмем на эту гиперссылку, мы сможем увидеть автоматически сгенерированный файл swagger.json, который содержит подробное описание нашего сингла (на данный момент)
Метод действия /WeatherForecast: принятые методы HTTP, входные параметры, типы возвращаемых данных.
различные значения JSON и т. д.
Мы можем легко понять, почему такая функция автоматического документирования может быть бесценным ресурсом.
для других разработчиков серверной части, у которых нет большого опыта работы с базой кода проекта – не
упомянуть любую третью сторону, которая хочет (или нуждается) интегрироваться с нашим веб-API, не имея доступа
к исходному коду.
На данный момент достаточно: мы вернемся к Swagger/OpenAPI в следующих главах, когда добавим
больше контроллеров и методов действий в нашем проекте веб-API.
Теперь, когда мы закончили проверку серверной части ASP.NET Core, мы можем, наконец, перейти к Angular.
фронтенд-проект.

# Интерфейс Angular

Фронтенд-проект Angular включает в себя следующее:
- Папка /src/, содержащая файлы исходного кода приложения Angular, а также некоторые статические файлы.
активы (HTML, CSS и т. п.). Если мы посмотрим на файлы исходного кода, мы увидим, что они имеют
расширение .ts, что означает, что мы будем использовать язык программирования TypeScript (скажем
об этом чуть позже)
- Набор корневых файлов, которые содержат параметры конфигурации Angular, необходимые пакеты npm для запуска приложения и сценарии для создания пакетов разработки и производства для его размещения.
Интерфейсная часть шаблона, вероятно, будет восприниматься как более сложная для понимания, поскольку Angular, как и большинство клиентских фреймворков, развивался быстрыми темпами, испытывая таким образом множество проблем.
критические изменения в его базовой архитектуре, управлении цепочкой инструментов, синтаксисе кодирования, шаблонах и настройке.
Именно по этой причине очень важно уделить время пониманию роли различных файлов.
поставляется вместе с шаблоном. Этот краткий обзор начнется с файлов конфигурации корневого уровня, которые
также будет обновлен последними версиями пакетов Angular (и их зависимостей), которые
нам нужно будет использовать.

# Корневые файлы

Рабочая область Angular — это место файловой системы, содержащее файлы Angular: коллекцию приложений.
файлы, библиотеки, ресурсы и т. д. В большинстве шаблонов проектов ASP.NET Core и Angular этот тип
рабочая область находится в папке /ClientApp/: однако, поскольку мы выбрали автономный Angular
шаблон, наша рабочая область находится в корневой папке проекта.

Замечание: Рабочая область создается и инициализируется командой Angular CLI, используемой для создания
приложение. Поскольку мы использовали графический интерфейс Visual Studio, мы не видели эту часть своими глазами.
потому что он был выполнен в фоновом режиме. Однако мы собираемся ощутить это в полной мере.
позже, когда мы вручную создадим новое приложение с помощью Angular CLI.

Любые команды CLI, работающие с приложением и/или его библиотеками (например, добавление или обновление новых пакетов), будут выполняться из рабочей области.

# angular.json

Важнейшую роль в рабочей области играет файл angular.json, созданный CLI.
в корне рабочей области. Это файл конфигурации рабочей области, который содержит
настройки по умолчанию для конкретного проекта для всех инструментов сборки и разработки, предоставляемых Angular CLI.
Первые несколько свойств в верхней части файла определяют параметры конфигурации рабочей области и проекта:
- версия: версия файла конфигурации.
- newProjectRoot: путь создания новых проектов относительно корневой папки рабочей области.
Мы видим, что это значение присвоено папке проектов, которой даже не существует (нет необходимости
беспокойтесь об этом: мы все равно не будем создавать новые проекты Angular)
проекты: элемент контейнера, в котором содержится подраздел для каждого проекта в рабочей области, содержащий параметры конфигурации для конкретного проекта.
- defaultProject: имя проекта по умолчанию — любая команда CLI, в которой не указан проект.
имя будет выполнено в этом проекте

Замечание: Стоит отметить, что файл angular.json соответствует стандартному правилу каскадирования от общего к конкретному. Все значения конфигурации, установленные на уровне рабочей области, будут
значения по умолчанию для любого проекта и могут быть заменены значениями, установленными в проекте.
уровень. Они, в свою очередь, могут быть переопределены значениями командной строки, доступными при
с помощью интерфейса командной строки.
Также стоит упомянуть, что до Angular 8 ручное изменение файла angular.
json был единственным способом внести изменения в конфигурацию рабочей области.

Это все, что нам нужно знать, по крайней мере, на данный момент. Все значения конфигурации уже хороши
достаточно для нашего сценария, поэтому мы пока просто оставим их такими, какие они есть.

# package.json

Файл package.json — это файл конфигурации Node Package Manager (npm). В основном он содержит
список пакетов npm, которые разработчик хочет восстановить перед запуском проекта. Те, кто
уже знаете, что такое npm и как он работает, могут перейти к следующему разделу, а те, кто не знает, должны
обязательно продолжайте читать.
npm начал свою жизнь как менеджер пакетов по умолчанию для среды выполнения JavaScript, известной как
Node.js. Однако в последние годы он также использовался для размещения ряда независимых JavaScript-платформ.
проекты, библиотеки и фреймворки любого типа, включая Angular. В конце концов, это стало де-факто
менеджер пакетов для фреймворков и инструментов JavaScript. Те, кто никогда не использовал его, могут подумать
это как NuGet для мира JavaScript.
Хотя npm — это в основном инструмент командной строки, самый простой способ использовать его из Visual Studio — правильно
настройте файл package.json, содержащий все пакеты npm, которые мы хотим получить, восстановить и поддерживать в актуальном состоянии.
на сегодняшний день позже. Эти пакеты загружаются в папку /node_modules/ в каталоге нашего проекта, которая по умолчанию скрыта в Visual Studio; однако все полученные пакеты можно увидеть
из виртуальной папки npm. Как только мы добавим, удалим или обновим файл package.json, Visual Studio
автоматически обновит эту папку соответствующим образом

В шаблоне Angular SPA, который мы использовали, поставляемый файл package.json содержит огромное количество
пакетов — все пакеты Angular — плюс хорошая связка зависимостей, инструментов и сторонних утилит.
например Karma (отличный инструмент для запуска тестов JavaScript/TypeScript).
Прежде чем двигаться дальше, давайте еще раз взглянем на наш файл package.json и постараемся извлечь из него максимальную пользу.
это. Мы видим, как все пакеты перечислены в стандартном объекте JSON, полностью состоящем из ключей и значений.
пары. Имя пакета является ключом, а значение используется для указания номера версии. Мы можем либо
введите точные номера сборок или используйте стандартный синтаксис npmJS, чтобы указать правила автоматического обновления, привязанные к
пользовательские диапазоны версий с использованием поддерживаемых префиксов, например следующие:
• Тильда (~): значение «~1.1.4» будет соответствовать всем версиям 1.1.x, за исключением 1.2.0, 1.0.x и т. д.
• Каретка (^): значение «^1.1.4» будет соответствовать всему, что выше 1.1.4, за исключением 2.0.0 и выше.
Это еще один сценарий, в котором IntelliSense может пригодиться, поскольку он также визуально объяснит фактическую
значение этих префиксов.

# Обновление (или понижение версии) Angular

Как мы видим, шаблон Angular SPA использует фиксированные номера версий для всех пакетов, связанных с Angular;
это определенно разумный выбор, поскольку у нас нет гарантий, что новые версии будут легко интегрироваться с нашим существующим кодом без каких-либо потенциально критических изменений и/или ошибок компилятора.
Разумеется, номер версии со временем будет увеличиваться, поскольку разработчики шаблонов
определенно постараюсь поддерживать свою хорошую работу в актуальном состоянии.
Тем не менее, вот наиболее важные пакеты и выпуски Angular, которые будут использоваться повсюду.
эта книга (не включая небольшую кучу дополнительных пакетов, которые будут добавлены позже):

```json
"@angular/animations": "13.0.1",
"@angular/common": "13.0.1",
"@angular/compiler": "13.0.1",
"@angular/core": "13.0.1",
"@angular/forms": "13.0.1",
"@angular/platform-browser": "13.0.1",
"@angular/platform-browser-dynamic": "13.0.1",
"@angular/router": "13.0.1",
"@angular-devkit/build-angular": "13.0.1",
"@angular/cli": "13.0.1",
"@angular/compiler-cli": "13.0.1"

```
Первую группу можно найти в разделе зависимостей, а вторая является частью
раздел devDependities. Как мы видим, номер версии практически одинаков для всех пакетов и
соответствует последней финальной версии Angular, доступной на момент написания.

# Обновление (или понижение версии) других пакетов

Как и следовало ожидать, если мы обновим (или понизим версию) Angular до последней доступной версии (на тот момент
написания), нам также необходимо позаботиться о ряде других пакетов npm, которые, возможно, потребуется обновить.
(или пониженный).
Вот полный список пакетов (включая пакеты Angular), которые мы будем использовать в нашем файле package.json.
на протяжении всей книги разделены на разделы «зависимости» и «devDependities». Соответствующие пакеты
обобщены в следующем фрагменте — обязательно проверьте их трижды!

```json
"dependencies": {
 "@angular/animations": "13.0.1",
 "@angular/common": "13.0.1",
 "@angular/compiler": "13.0.1",
 "@angular/core": "13.0.1",
 "@angular/forms": "13.0.1",
 "@angular/platform-browser": "13.0.1",
 "@angular/platform-browser-dynamic": "13.0.1",
 "@angular/router": "13.0.1",
 "rxjs": "7.4.0",
 "tslib": "2.3.1",
 "zone.js": "0.11.4",
 "jest-editor-support": "*"
},
"devDependencies": {
 "@angular-devkit/build-angular": "13.0.1",
 "@angular/cli": "13.0.1",
 "@angular/compiler-cli": "13.0.1",
 "@types/jasmine": "3.8.0",
 "@types/node": "^12.11.1",
 "jasmine-core": "3.8.0",
 "karma": "6.3.0",
 "karma-chrome-launcher": "3.1.0",
 "karma-coverage": "2.0.3",
 "karma-jasmine": "4.0.0",
 "karma-jasmine-html-reporter": "1.7.0",
 "typescript": "4.4.4"
}
```

# tsconfig.json

Файл tsconfig.json — это файл конфигурации TypeScript. Опять же те, кто уже знает, что
TypeScript все это читать не нужно будет, хотя тем, кому не надо.
Менее чем в 100 словах: TypeScript — это бесплатный язык программирования с открытым исходным кодом, разработанный и
поддерживается Microsoft и действует как расширенный набор JavaScript; это означает, что любая программа JavaScript
также действующая программа TypeScript. TypeScript также компилируется в JavaScript, а это означает, что он может легко
работать в любом браузере, совместимом с JavaScript, без внешних компонентов.

Основная причина его использования — преодоление синтаксических ограничений и общих недостатков JavaScript.
при разработке крупномасштабных приложений или сложных проектов. Проще говоря, это заставляет разработчика
жизнь упрощается, когда они вынуждены иметь дело с нетривиальным кодом.
В этом проекте мы обязательно будем использовать TypeScript по ряду веских причин. Самое важное
они следующие:
- TypeScript имеет несколько преимуществ по сравнению с JavaScript, таких как статическая типизация,
классы и интерфейсы. Использование его в Visual Studio также дает нам возможность извлечь выгоду из
встроенный IntelliSense, который является большим преимуществом и часто приводит к значительному повышению производительности.
- Для крупного клиентского проекта TypeScript позволит нам создавать более надежный код, который будет
также быть полностью развертываемым в любом месте, где будет запускаться простой файл JavaScript.
Не говоря уже о том, что выбранный нами шаблон Angular SPA уже использует TypeScript. Следовательно, мы
можно сказать, что мы уже одной ногой в воде!
Если отбросить шутки, мы не единственные, кто хвалит TypeScript; это было признано Angular
самой командой, учитывая тот факт, что исходный код Angular был написан с использованием TypeScript с тех пор, как
Angular 2, о чем Microsoft с гордостью объявила в следующем сообщении блога MDSN в марте 2015 года:
https://devblogs.microsoft.com/typescript/angular-2-built-on-typescript/.
Это еще раз подчеркнул в этом замечательном посте Виктор Савкин (сооснователь Narwhal Technologies).
и признанный консультант Angular) в своем личном блоге в октябре 2016 года: https://vsavkin.com/
написание-угловое-2-в-типописном-1fa77c78d8e8.
Возвращаясь к файлу tsconfig.json, сказать особо нечего; значения параметров, используемые Angular
шаблон — это именно то, что нам нужно для настройки Visual Studio и компилятора TypeScript (TSC).
чтобы правильно перенести файлы кода TypeScript, включенные в папку /src/, поэтому нет необходимости
Измени это.

# Другие файлы уровня рабочей области

Есть также другие примечательные файлы, созданные CLI в корне рабочей области. Поскольку мы не будем меняться
их, мы лишь кратко упомянем их в следующем списке:
- .browserlistrc: файл, используемый системой сборки для настройки вывода CSS и JS для поддержки различных
браузеры.
- .editorconfig: конфигурация редакторов кода, специфичная для рабочей области.
- .gitignore: текстовый файл, который сообщает Git — системе контроля версий, которую вы, скорее всего, хорошо знаете —
какие файлы или папки игнорировать в рабочей области. Это намеренно неотслеживаемые файлы, которые
не следует добавлять в репозиторий контроля версий.
- /node_modules/: (скрытая) папка, содержащая все пакеты npm для всей рабочей области.
Эта папка будет заполнена пакетами, определенными в файле package.json, расположенном на
корень рабочей области; поскольку по умолчанию он исключен из проекта, мы сможем увидеть его только если щелкнуть
на кнопке «Показать все файлы» в верхней части обозревателя решений.
- aspnetcore-https.js: сценарий, настраивающий HTTPS для приложения с использованием ASP.NET Core.
HTTPS-сертификат. Помните всплывающее окно авторизации HTTPS, которое появилось в главе 2?
Готовитесь во время нашего первого тестового запуска? Мы только что нашли, что спровоцировало это.
- karma.conf.js: конфигурация Karma для конкретного приложения. Карма – это инструмент, используемый для управления
Тесты на основе жасмина. На данный момент мы можем смело игнорировать всю эту тему, поскольку мы вернемся к ней позже.
- nuget.config: файл конфигурации NuGet: мы можем его спокойно игнорировать.
- package-lock.json: предоставляет информацию о версии для всех пакетов, установленных в /node_.
папку groups/ с помощью клиента npm. Если вы планируете заменить npm на Yarn, можете смело удалить
этот файл (вместо него будет создан файл Yarn.lock).

Замечание: Yarn — менеджер пакетов для языка программирования JavaScript, разработанный
и выпущен Facebook в октябре 2016 года для устранения некоторых ограничений.
который был у npm в то время и должен был стать полной заменой npm. Для
дополнительную информацию читайте здесь: https://yarnpkg.com/.

- README.md: вводная документация для рабочей области. Расширение .md означает
Markdown — легкий язык разметки, созданный Джоном Грубером и Аароном Шварцем в 2004 году.
-  tsconfig.*.json: параметры конфигурации для различных аспектов нашего приложения, специфичные для проекта: .app.
json для уровня приложения, .server.json для уровня сервера и .spec.json для тестов. Эти варианты
переопределит те, которые установлены в общем файле tsconfig.json в корне рабочей области.

Теперь, когда мы знаем основы различных файлов уровня рабочей области, мы можем перейти к изучению Angular.
файлы исходного кода.


# Папка /src/

Пришло время посетить приложение Angular и посмотреть, как оно работает, просмотрев файлы его исходного кода. Отдых
уверен, мы не останемся надолго; мы просто хотим взглянуть на то, что находится под капотом.
Раскрыв каталог /src/, мы увидим, что существуют следующие подпапки:
- Папка /src/app/ вместе со всеми ее подпапками содержит все файлы TypeScript, связанные с
в наше приложение Angular; другими словами, весь исходный код клиентского приложения предназначен для
поместить сюда.
- Папка /src/assets/ предназначена для хранения всех изображений приложения и других файлов ресурсов.
Эти файлы будут копироваться и/или обновляться в папке развертывания без изменений при каждой сборке приложения.
- Папка /src/environments/ содержит параметры конфигурации сборки, предназначенные для конкретных сред; этот шаблон, как и любой новый проект Angular по умолчанию, включает в себя среду.
ts (для разработки) и файл Environment.prod.ts (для производства).

favicon.ico: файл, содержащий один или несколько маленьких значков, которые будут отображаться в окне веб-браузера.
адресная строка, когда мы посещаем приложение Angular, а также рядом с заголовком страницы в различных браузерах.
компоненты (вкладки, закладки, история и т. д.).
- index.html: основная HTML-страница, которая отображается при доступе к приложению Angular. Интерфейс командной строки
автоматически добавляет все файлы JavaScript и CSS при создании нашего приложения, поэтому мы обычно не
необходимо добавить сюда теги <script> или <link> вручную.
- karma.conf.js: конфигурация Karma для конкретного приложения. Karma — это инструмент, используемый для запуска тестов на основе Jasmine. На данный момент мы можем смело игнорировать всю эту тему, поскольку мы вернемся к ней позже.
- main.ts: основная точка входа для нашего приложения. Компилирует приложение с помощью JIT-компилятора и загружает корневой модуль приложения (AppModule) для запуска в браузере. Мы можем
также используйте компилятор AOT, не меняя никакого кода, добавив флаг --aot в сборку CLI.
и подавать команды.
- Polyfills.ts: предоставляет сценарии полифилла для улучшения поддержки браузеров.
- proxy.conf.ts: настройки конфигурации прокси-сервера Angular Live Development Server. У нас есть
мы уже видели это в главе 2 «Подготовка», когда мы изменили порт HTTPS на единственный
правило, существующее в настоящее время: то, которое перенаправляет все HTTP-запросы к /weatherforecast на
веб-сервер API. Короче говоря, мы собираемся обновить это правило, чтобы сделать его более общим, чтобы оно
перенаправит все HTTP-запросы API на сервер веб-API.
- Styles.css: список файлов CSS, содержащих стили для проекта.
- test.ts: основная точка входа для модульных тестов проекта.
Давайте начнем наш обзор кода с содержимого папки /src/app/.

# Папка /src/app/

Папка /src/app/ нашего шаблона соответствует лучшим практикам структуры папок Angular и содержит наши
логику и данные проекта, включая все модули, сервисы и компоненты Angular, а также
шаблоны и стили. Это также единственная подпапка, которую стоит изучить, по крайней мере, на данный момент.

# AppModule
Как мы кратко предполагали в главе 1 «Введение в ASP.NET и Angular», основные строительные блоки
Приложение Angular — это NgModules, которые предоставляют контекст компиляции для компонентов. 
Роль NgModules — собрать связанный код в функциональные наборы: поэтому все приложение Angular
определяется набором из одного или нескольких NgModules.

Замечание: NgModules были представлены в Angular 2 RC5 и представляют собой отличный и мощный способ организации
и загрузите любое приложение Angular; они помогают разработчикам консолидировать свой собственный набор
компонентов, директив и каналов в многоразовые блоки. Как мы уже говорили ранее, каждый
Приложение Angular начиная с v2 RC5 должно иметь хотя бы один модуль, что условно считается
называется корневым модулем и поэтому получает имя класса AppModule.

Любому приложению Angular требуется корневой модуль, обычно называемый AppModule, который сообщает Angular, как
собрать приложение, что позволит выполнить загрузку и запустить жизненный цикл инициализации (см.
следующую схему). Остальные модули известны как функциональные модули и служат другому
цель. Корневой модуль также содержит справочный список всех доступных компонентов.
Ниже приведена схема стандартного цикла инициализации Angular, которая поможет нам лучше.
представьте, как это работает:

![image](https://github.com/artemovsergey/Angular/assets/26972859/40368722-1cc9-475e-b0c6-ee335b3863cf)


Как мы видим, файл main.ts загружает app.module.ts (AppModule), который затем загружает приложение.
файл компонент.ts (AppComponent); последний, как мы вскоре увидим, затем загрузит все остальные
компоненты всякий раз, когда они нужны приложению.
Корневой модуль примера приложения Angular, созданного по нашему шаблону, можно найти в каталоге /src/app/.
папка и определяется в файле app.module.ts. Если мы посмотрим на исходный код, то увидим, что наш
AppModule разделен на два основных блока кода:
- Список операторов импорта, указывающий на все ссылки (в виде файлов TypeScript).
требуется приложением
- Корневой блок NgModule, который по сути представляет собой набор именованных массивов, каждый из которых содержит
набор объектов Angular, которые служат общей цели: директивы, компоненты, каналы, модули,
провайдеры и так далее. Последний содержит компонент, который мы хотим загрузить, который, в
в большинстве сценариев, включая наш, используется основной компонент приложения AppComponent.

# AppComponent
Если NgModules являются строительными блоками Angular, компоненты можно определить как кирпичики, используемые для размещения
приложение вместе, в той степени, в которой мы можем сказать, что приложение Angular представляет собой, по сути, дерево компонентов.
работаем вместе.

Компоненты определяют представления, которые представляют собой наборы элементов экрана, между которыми Angular может выбирать.
изменять в соответствии с логикой и данными вашей программы и использовать сервисы, которые предоставляют конкретную функциональность
не имеет прямого отношения к просмотрам. Поставщики услуг также могут быть внедрены в компоненты в виде зависимостей.
таким образом делая код приложения модульным, многоразовым и эффективным.
Краеугольный камень этих компонентов условно называется AppComponent, который также является единственным
компонент, который, согласно соглашениям о структуре папок Angular, должен быть помещен в каталог /app/
Корневая папка. Все остальные компоненты следует поместить в подпапку, которая будет выступать в качестве выделенного пространства имен.

Замечание: Как мы можем легко заметить, AppComponent также является единственным компонентом, присутствующим в нашем шаблоне Standalone Angular: это означает, что в настоящее время приложение предлагает только одно представление. На
кроме того, ему также не хватает нормального меню и системы навигации. Другими словами, это буквально
одностраничное приложение! Но не волнуйтесь: скоро мы добавим и другие компоненты.
а также выполнить некоторые настройки пользовательского интерфейса и UX, чтобы улучшить его внешний вид.

Как мы видим, наш AppComponent состоит из четырёх файлов:
- app.comComponent.ts: определяет логику компонента, то есть исходный код класса компонента.
- app.comComponent.html: определяет шаблон HTML, связанный с AppComponent. Любой
Вместо этого компонент Angular может иметь дополнительный HTML-файл, содержащий структуру макета пользовательского интерфейса.
определения его внутри самого файла компонента. Это почти всегда хорошая практика, если только
Компонент поставляется с очень минимальным пользовательским интерфейсом.
- app.comComponent.css: определяет базовую таблицу стилей CSS для компонента. Как и в случае с файлом .html,
этот файл не является обязательным, но его следует использовать всегда, если только компонент не требует стилизации пользовательского интерфейса.
- app.comComponent.spec.ts: содержит модульные тесты для исходного файла app.comComponent.ts и может
запускаться с использованием среды тестирования Jasmine JavaScript через средство запуска тестов Karma.
Давайте кратко рассмотрим каждый из них.

# Файл класса TypeScript

Начнем с файла app.comComponent.ts, который поможет нам начать знакомство с
исходный код типичного класса компонента Angular:

```typescript
import { HttpClient } from '@angular/common/http';
import { Component } from '@angular/core';
@Component({
 selector: 'app-root',
 templateUrl: './app.component.html',
 styleUrls: ['./app.component.css']
})
export class AppComponent {
 public forecasts?: WeatherForecast[];
constructor(http: HttpClient) {
 http.get<WeatherForecast[]>('/weatherforecast').subscribe(result => {
 this.forecasts = result;
 }, error => console.error(error));
 }
 title = 'HealthCheck';
}
interface WeatherForecast {
 date: string;
 temperatureC: number;
 temperatureF: number;
 summary: string;
}
```

Как мы видим, класс содержит следующие блоки кодирования:
- Список операторов импорта, очень похожий на класс AppModule.
- Декоратор @Component, определяющий селектор, а также templateUrl и styleUrls.
компонента. селектор — самая важная вещь, определенная там, поскольку он сообщает Angular
создать экземпляр этого компонента везде, где он находит соответствующий тег в HTML-шаблоне. В этом
В этом случае экземпляр AppComponent будет создан везде, где Angular находит тег <app-root>.

- Класс TypeScript для компонента, который включает конструктор, локальные свойства,
методы и так далее.
- Интерфейс для хранения данных прогноза погоды в формате JSON, поступающих из веб-API ASP.NET Core.
типизированным образом: в идеале эти интерфейсы должны требовать своих собственных выделенных и отдельных
файл – однако для простоты шаблон, который мы используем, помещает его сюда.
Давайте теперь переключимся на файл шаблона HTML.

# Файл HTML-шаблона
Файл /src/app/app.comComponent.html содержит HTML-код, необходимый для отображения компонента на
экран браузера. В этих шаблонах мы можем использовать код HTML, CSS и JS, а также некоторые специальные
Синтаксис Angular, который можно использовать для добавления мощных функций, таких как интерполяция, операторы шаблонов,
синтаксис привязки, привязка свойств, директивы и ссылочные переменные.
Мы поговорим об этих функциях подробнее в главе 4 «Взаимодействия с внешним и внутренним интерфейсом», когда будем создавать
пользовательский компонент с табличным шаблоном, очень похожим на этот.

# Файл таблицы стилей
Как мы видим, стиль /src/app/app.comComponent.css в настоящее время пуст: это просто означает, что к компоненту не применены стили (пока). Пока можем оставить всё как есть: к этому файлу мы ещё вернёмся позже.
on, когда мы начнем стилизовать наше приложение Angular.

# Файл spec.ts
Прежде чем идти дальше, давайте потратим некоторое время и внимательно рассмотрим app.comComponent.spec.
ts-файл. Эти файлы, согласно соглашению об именах Angular, должны содержать модульные тесты для своих проектов.
соответствующие исходные файлы и запускаются с использованием тестовой среды Jasmine JavaScript через Karma.
тестовый бегун.

Пока мы там, было бы полезно дать им возможность проверить, работает ли тестирование Жасмин + Карма.
Фреймворк, настроенный по нашему шаблону, действительно работает.


# Наш первый тестовый запуск
Прежде чем запускать тест, возможно, будет полезно узнать немного больше о Жасмин и Карме. Если
вы ничего о них не знаете, не волнуйтесь — скоро узнаете. А пока просто знай, что Жасмин
среда тестирования с открытым исходным кодом для JavaScript, которую можно использовать для определения тестов, а Karma — это тест
инструмент запуска, который автоматически создает веб-сервер, который будет выполнять исходный код JavaScript против
Тесты, созданные Jasmine, и вывод их соответствующих (и объединенных) результатов в командную строку.
В этом быстром тесте мы по сути запустим Karma для выполнения исходного кода нашего примера приложения Angular.
против тестов Jasmine, определенных шаблоном в файле app.comComponent.spec.ts; это на самом деле
гораздо более простая задача, чем может показаться.
Откройте командную строку, перейдите в корневую папку проекта Angular и выполните следующую команду:
команда:
> npm запускает тест ng
Это вызовет Angular CLI с помощью npm.

В том маловероятном случае, когда команда npm вернет ошибку «Программа не найдена», убедитесь, что файл Node.
двоичная папка js/npm правильно установлена в переменной PATH. Если его там нет, обязательно добавьте его, и
затем закройте и снова откройте окно командной строки и повторите попытку.

# Первая попытка тестирования
Сразу после того, как мы нажмем Enter, должно открыться новое окно браузера с консолью Karma и списком
результаты тестов Jasmine показаны на следующем рисунке:

![image](https://github.com/artemovsergey/Angular/assets/26972859/62398952-10b9-4ab3-9c7e-49ac465ee49a)

Как мы видим, у нас три проваленных теста из трёх: это довольно неожиданно, поскольку мы используем сгенерированный шаблоном код, который должен работать сразу!
Фактически, файл app.comComponent.spec.ts поставляется с автономным TypeScript Angular.
шаблон не был обновлен должным образом, чтобы отразить HTML-шаблон компонента, по крайней мере, на
время написания: другими словами, оно сломано.
Чтобы это исправить, нам необходимо внести следующие изменения в исходный код (новые и обновленные строки
выделено):

```ts
import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { AppComponent } from './app.component';
describe('AppComponent', () => {
 beforeEach(async () => {
 await TestBed.configureTestingModule({

imports: [
 HttpClientTestingModule
 ],
 declarations: [
 AppComponent
 ],
 }).compileComponents();
 });
 it('should create the app', () => {
 const fixture = TestBed.createComponent(AppComponent);
 const app = fixture.componentInstance;
 expect(app).toBeTruthy();
 });
 it('should have as title 'HealthCheck'', () => {
 const fixture = TestBed.createComponent(AppComponent);
 const app = fixture.componentInstance;
 expect(app.title).toEqual('HealthCheck');
 });
 it('should render title', () => {
 const fixture = TestBed.createComponent(AppComponent);
 fixture.detectChanges();
 const compiled = fixture.nativeElement as HTMLElement;
 expect(compiled.querySelector('h1')?.textContent).toContain('Weather
forecast');
 });
});

```

Вкратце, вот что мы сделали:
- Добавлен HttpClientTestingModule в список импорта модуля тестирования, как того требует приложение.
его запустить (и пройти три теста)
- Изменен тест "следует отображать заголовок" (последний), чтобы он правильно соответствовал названию приложения.
После этого мы можем попытаться запустить тест еще раз и посмотреть, удалось ли нам исправить эти ошибки.

# Вторая попытка тестирования
Снова перейдите в корневую папку проекта Angular и выполните команду npm run ng test. Если мы
если все сделали правильно, мы должны увидеть что-то вроде следующего скриншота:

![image](https://github.com/artemovsergey/Angular/assets/26972859/2eabaa42-52a2-4c42-bdda-5317d9de9783)

Все три испытания пройдены успешно: молодцы!

# Приступаем к работе
Теперь, когда у нас есть общее представление о наших проектах, пришло время что-то сделать. Начнем с двух
простые упражнения, которые тоже пригодятся в будущем. Первый из них будет включать серверную часть
конечные точки нашего проекта веб-API, а второй повлияет на взаимодействие с пользователем нашего веб-интерфейса на стороне клиента.
Угловое приложение. И то, и другое поможет нам убедиться, что мы действительно поняли все, что нужно знать, прежде чем
переходим к последующим главам.

# Изменение конечных точек API
Если мы еще раз посмотрим на файл proxy.conf.js Angular, мы легко увидим, что единственное существующее правило
явно отображает метод действия одного веб-API нашего веб-API:

```json
const PROXY_CONFIG = [
 {
 context: [
 "/weatherforecast",
 ],
 target: "https://localhost:40443",
secure: false
 }
]
module.exports = PROXY_CONFIG;
```

Это может быть хорошо для наших первоначальных целей тестирования, но это может оказаться очень непрактичным подходом, поскольку
как только мы начнем добавлять контроллеры и методы действий: мы, конечно же, не хотим обновлять их вручную.
правила каждый раз.
Лучшее, что мы можем сделать, чтобы это исправить, — это определить единое правило, которое будет работать для всех наших конечных точек API:
это можно сделать, определив префикс (например, /api/), который будет использоваться всеми нашими методами действий.
конечные точки. Такое изменение нужно выполнить в трех файлах:
• Файл Angular app.comComponent.ts (проект HealthCheck), в котором выдается HTTP-запрос.
• Файл конфигурации прокси-сервера Angular (проект HealthCheck), в котором перенаправляется HTTP-запрос.
на веб-сервер веб-API
• Файл WeatherForecastController.cs (проект HealthCheckAPI), который будет отвечать на
HTTP-запрос с данными прогноза погоды в формате JSON
Начнем с проекта Angular.
Откройте файл /src/app/app.comComponent.ts и обновите существующее значение /weatherforecast в
следующим образом:

```ts
constructor(http: HttpClient) {
 http.get<WeatherForecast[]>('/api/weatherforecast').subscribe(result => {
 this.forecasts = result;
 }, error => console.error(error));
}
```

Теперь нам нужно изменить прокси-сервер, чтобы новый URL-адрес был правильно адресован приложению веб-API. Откройте файл /src/proxy.conf.json и обновите существующую конечную точку следующим образом:

```json
const PROXY_CONFIG = [
 {
 context: [
 "/api",
 ],
 target: "https://localhost:40443",
 secure: false
 }
]
```

Аспекты Angular нашей работы выполнены: теперь каждый HTTP-запрос, начинающийся с /api, включая
обновленный /api/weatherforecast – будет перенаправлен в наше серверное приложение веб-API.

Однако наше приложение веб-API еще не знает об этом: если мы теперь попытаемся запустить наше приложение Angular, нажав
F5, мы больше не получим данных прогноза погоды, поскольку старая конечная точка /weatherforecast будет возвращать
Ошибка HTTP 404 (не найден). Чтобы решить эту проблему, нам просто нужно изменить его на /api/weatherforecast.
чтобы обновленное правило подействовало на него.
Переключитесь на проект HealthCheckAPI, откройте файл /Controllers/WeatherForecastController.cs,
и добавьте префикс api/ к существующему значению атрибута [Route] (строка 6 или около того) следующим образом:

```Csharp
[Route("api/[controller]")]
```

Теперь мы можем запустить наши проекты в режиме отладки и посмотреть, сможет ли приложение Angular получить информацию о погоде.
данные прогноза еще раз.
В этом изменении хорошо то, что наш прокси Angular теперь имеет общее правило, которое будет
действителен для любой конечной точки API – при условии, что мы включаем префикс api/ в маршрут контроллера – без
каждый раз приходится добавлять новое правило.

Изменения, которые мы только что применили к URL-адресам наших конечных точек, достаточно хороши при запуске наших приложений в
Режим разработки, поскольку мы можем положиться на прокси Angular, и они будут отлично работать, даже если
публикацию наших приложений в производственной среде, если мы можем обслуживать веб-API через
прокси с использованием аналогичных методов.
Однако что, если наша служба хостинга (или стратегия) не позволяет этого? Что, если мы хотим опубликовать
наше приложение HealthCheck Angular и серверная часть HealthCheckAPI в двух совершенно разных доменах
не имея возможности проксировать последнее через папку /api/ первого? Это типичный
сценарий большинства современных методов развертывания: например, если мы хотим разместить наше приложение Angular
в сети доставки контента (CDN) вместо использования реального HTTP-сервера.
Если мы хотим, чтобы наши приложения поддерживали такое поведение, лучшее, что мы можем сделать, — это реализовать дополнительный
baseUrl и использовать его в качестве «префикса» для всех наших вызовов API: давайте воспользуемся шансом и сделаем это.

# Реализация свойства baseUrl
Лучшим местом для реализации свойства baseUrl будет папка /src/environments/, которую мы
кратко упомянуто ранее. Эта папка содержит два файла — Environment.ts и Environment.prod.
ts — его можно использовать для определения настроек, специфичных для среды, а это именно то, что нам нужно.

Замечание: Файлы Environment.*.ts являются аналогом ASP.NET Core в Angular.
appsettings.*.json, и их можно использовать для выполнения тех же требований: set
значения конфигурации, которые будут автоматически переопределены в зависимости от версии приложения.
среда исполнения.

Откройте файл /src/environments/environment.ts и добавьте свойство baseUrl следующим образом:

```ts
export const environment = {
 production: false,
 baseUrl: "/"
};
```
Это значение, которое мы собираемся использовать в среде разработки, поскольку мы можем положиться на
Угловой прокси.
Давайте теперь откроем файл /src/environments/environment.prod.ts и настроим свойство baseUrl.
с немного другим значением:

```ts
export const environment = {
 production: false,
 baseUrl: "https://localhost:40443/"
};

```

Как мы видим, на этот раз мы настроили целый URL-адрес с протоколом и портом. Мы использовали localhost для
на данный момент мы понятия не имеем о конечной точке производства нашего веб-API (пока); однако,
теперь, когда у нас есть готовая переменная baseUrl, мы легко сможем заменить это значение полным доменным именем.
как только он у нас появится. Собственно говоря, мы собираемся сделать это в главе 15 «Windows, Linux,
и развертывание Azure, когда мы научимся публиковать наши приложения в рабочей среде.

# Рефакторинг приложения Angular
Следующее, что мы собираемся сделать, это реорганизовать наше текущее приложение Angular, чтобы сделать его более универсальным.
и удобный для пользователя. Точнее, вот что мы собираемся сделать:
- Добавьте два новых компонента: один для «экрана приветствия» приложения, а другой для существующего.
пример получения данных (куда мы перенесем существующую реализацию прогноза погоды)
- Добавьте меню навигации верхнего уровня, чтобы пользователь мог перемещаться между новыми
компоненты из пользовательского интерфейса
- Внедрить систему маршрутизации на стороне клиента, чтобы каждый выбор, выбранный пользователем через
меню навигации будет обрабатываться путем отображения правильных компонентов
Давай приступим к работе.

# Добавление HomeComponent
Начнем с добавления HomeComponent, в котором будет размещаться содержимое домашней страницы нашего приложения. Учитывая наше рабочее пространство разработки, существует два основных подхода к этому:
• Используйте Angular CLI.
• Используйте функцию Visual Studio «Добавить новый элемент».
Метод Angular CLI считается наиболее удобным выбором, поскольку он автоматически генерирует
все необходимые файлы и ссылки: вот почему мы собираемся его использовать.

Откройте командную строку и перейдите в корневую папку проекта Angular. Это должно быть /Проекты/
HealthCheck/HealthCheck/, если вы следовали нашим соглашениям об именах путей, и введите следующую команду:
команда:
> ng сгенерировать компонент Главная
Предыдущая команда выполнит следующие задачи, как показано на следующем снимке экрана:
- Создайте новую папку /src/app/home/ для размещения новых файлов компонентов.
- Создайте файлы ts, css, html и spec.ts компонента и заполните их образцами данных.
- Обновите файл app.module.ts, добавив ссылку на новый компонент.

![image](https://github.com/artemovsergey/Angular/assets/26972859/032a0f97-d2c4-41e8-9062-4fab872806a1)

После этого мы можем перейти к следующим шагам.

Замечание: С этого момента мы всегда будем создавать файлы компонентов с помощью Angular CLI на протяжении всего процесса разработки.
остальная часть книги. Однако те, кто предпочитает использовать ручной подход, могут свободно это сделать.
вот что: просто не забудьте добавить необходимые ссылки на AppModule Angular, который будет
показано через короткое время.

# The dry run switch
Если мы хотим увидеть, что делает предыдущая команда ng, не внося никаких изменений, мы можем использовать
переключатель --dry-run следующим образом:

> ng сгенерировать компонент Home --dry-run
Этот переключатель не позволит CLI вносить какие-либо изменения в файловую систему.
посмотрите, что делает команда ng, не создавая и не изменяя какой-либо файл. Это может быть полезно всякий раз, когда
мы не уверены в том, что может сделать команда, поскольку мы сможем увидеть, что она делает, без
риск что-то сломать в нашем приложении.

Замечание: Также стоит отметить, что ключ --dry-run не ограничивается функцией nggenerate.
компонент: его можно использовать с любой командой Angular CLI.

# Пропуск файла spec.ts
Если мы хотим предотвратить создание файла для модульных тестов, мы можем добавить --skip-tests
переключитесь на команду CLI следующим образом:
> ng генерировать компонент Home --skip-tests
Этот переключатель не позволит Angular CLI создать файл spec.ts для компонента: мы
файлы spec.ts мы видели в главе 2 «Подготовка», когда мы проводили наш первый модульный тест. С
мы не будем использовать эти файлы до главы 10 «ASP.NET Core и модульное тестирование Angular», когда мы
поговорим о тестировании на стороне клиента и на стороне сервера, для простоты мы просто пропустим их, используя
--skip-tests переключается с этого момента. Именно по этой причине, если мы уже создали дом.
компонент.spec.ts, мы можем удалить его, прежде чем продолжить.

# Добавление компонента FetchDataComponent
Следующее, что мы собираемся сделать, это создать FetchDataComponent, куда мы поместим пример автоматически сгенерированной выборки данных, который в настоящее время находится в AppComponent.
Снова используйте командную строку из корневого пути проекта HealthCheck, чтобы ввести следующее:
консольная команда:
ng сгенерировать компонент FetchData --skip-tests
Опять же, команда добавит необходимые файлы и соответствующим образом обновит AppModule.
Теперь у нас есть два (в основном пустых) компонента, с которыми можно поиграться: однако в настоящее время нет возможности
пользователь может добраться до них, поскольку в нашем приложении Angular отсутствует правильное меню навигации, а также механизм маршрутизации, который позволяет работать такой навигации.
Давайте решим эту проблему навсегда.

# Добавляем меню навигации
В типичном пользовательском интерфейсе на основе HTML меню навигации представляет собой элемент, содержащий несколько гиперссылок.
(или кнопки или вкладки), позволяющие пользователю перемещаться между различными разделами, страницами или
Просмотры.
Если мы подумаем об этом с точки зрения Angular, мы легко увидим, что он ничем не отличается от компонента.
точно так же, как Home и FetchData. Именно по этой причине мы собираемся создать его в той же технике.
что мы использовали до сих пор:
ng сгенерировать компонент NavMenu --skip-tests
Теперь мы наконец можем начать программировать!
Прежде всего, откройте файл /src/app/app.module.ts, чтобы подтвердить (выделенные) изменения, автоматически выполняемые Angular CLI:

```ts
import { HttpClientModule } from '@angular/common/http';
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { HomeComponent } from './home/home.component';
import { FetchDataComponent } from './fetch-data/fetch-data.component';
import { NavMenuComponent } from './nav-menu/nav-menu.component';
@NgModule({
 declarations: [
 AppComponent,
 HomeComponent,
 FetchDataComponent,
 NavMenuComponent
 ],
 imports: [
 BrowserModule, HttpClientModule
 ],
 providers: [],
 bootstrap: [AppComponent]
})
export class AppModule { }
```

Здесь нам не нужно ничего делать, но может быть полезно понять, что нам следовало бы сделать, если бы мы
не использовал Angular CLI и вместо этого решил создать эти компоненты вручную.
Давайте теперь создадим наше навигационное меню. В обозревателе решений Visual Studio откройте HealthCheck.
проекта, перейдите в папку /src/app/nav-menu/, выберите файл nav-menu.comComponent.html и заполните
его с помощью следующего HTML-кода, перезаписывающего существующий пример содержимого:

```html
<header>
 <nav>
 <a [routerLink]="['/']">Home</a>
 |
 <a [routerLink]="['/fetch-data']">Fetch Data</a>
 </nav>
</header>
```

Как мы видим, мы сделали не так уж много: только минимальное количество HTML-кода для реализации механизма навигации на основе гиперссылок внутри стандартного элемента <header>.
Единственное, что здесь стоит отметить, это то, что каждый элемент гиперссылки содержит ссылку на RouterLink.
– директива Angular, которая делает этот элемент ссылкой, инициирующей навигацию по маршруту. Навигационная система, которую мы собираемся создать, откроет маршрутизируемые компоненты в выделенном <router-outlet>.
контейнер присутствует на странице.

# Обновление AppComponent
Лучшее место для размещения этого местоположения <router-outlet> — AppComponent, который также должен содержать
NavMenuComponent: таким образом AppComponent действительно станет основой нашего приложения Angular, содержащим как навигационный компонент, так и контейнер, в котором будут открываться маршрутизируемые компоненты.
Однако прежде чем сделать это, нам нужно «переместить» текущее поведение AppComponent, показав
данные прогноза погоды — в специальный компонент FetchDataComponent, который мы добавили минуту назад: поскольку
поведение компонента обрабатывается исходным кодом, содержащимся в его файлах TypeScript и HTML.
означает, что нам также нужно переместить содержимое этих файлов.

Для простоты мы можем пока игнорировать файл StyleSheet, поскольку в настоящее время он
пустой.

Откройте файл /src/app/fetch-data.comComponent.ts и обновите его следующим образом (добавлен/обновлен
код выделен):

```ts
import { HttpClient } from '@angular/common/http';
import { Component, OnInit } from '@angular/core';
import { environment } from '../../environments/environment';
@Component({
 selector: 'app-fetch-data',
 templateUrl: './fetch-data.component.html',
 styleUrls: ['./fetch-data.component.css']
})
export class FetchDataComponent implements OnInit {
 public forecasts?: WeatherForecast[];
 constructor(http: HttpClient) {
 http.get<WeatherForecast[]>(environment.baseUrl + 'api/weatherforecast').
subscribe(result => {
 this.forecasts = result;
 }, error => console.error(error));
 }
 ngOnInit(): void {
 }
}
interface WeatherForecast {
 date: string;
 temperatureC: number;
 temperatureF: number;
 summary: string;
}
```

Как мы видим, все обновленные строки кода взяты из файла app.comComponent.ts, что и ожидалось.
поскольку мы фактически переносим исходное поведение AppComponent в этот компонент.

Замечание: Мы также воспользовались возможностью использовать свойство baseUrl, которое мы добавили ранее, в качестве префикса для
конечную точку api/weatherforecast, чтобы подготовить ее как для среды разработки, так и для производственной среды.

То же самое необходимо сделать с файлом /src/app/fetch-data.comComponent.html, который содержит
HTML-шаблон для компонента. На этот раз мы можем просто скопировать и вставить из приложения.
компонент.html, поскольку у нас нет имен классов, которые нужно сохранять. Вот обновленный код:

```html
<h1 id="tableLabel">Weather forecast</h1>
<p>This component demonstrates fetching data from the server.</p>
<p *ngIf="!forecasts"><em>Loading... Please refresh once the ASP.NET backend
has started.</em></p>
<table *ngIf="forecasts">
 <thead>
 <tr>
 <th>Date</th>
 <th>Temp. (C)</th>
 <th>Temp. (F)</th>
 <th>Summary</th>
 </tr>
 </thead>
 <tbody>
 <tr *ngFor="let forecast of forecasts">
 <td>{{ forecast.date }}</td>
 <td>{{ forecast.temperatureC }}</td>
 <td>{{ forecast.temperatureF }}</td>
 <td>{{ forecast.summary }}</td>
 </tr>
 </tbody>
</table>
```
Теперь, когда мы «перенесли» поведение извлечения данных в FetchDataComponent, мы наконец можем обновить
Исходный код AppComponent, чтобы он мог выполнять свою новую «магистральную» работу.
Вот обновленный файл /src/app/app.comComponent.ts:

```ts
import { Component } from '@angular/core';
@Component({
 selector: 'app-root',
 templateUrl: './app.component.html',
 styleUrls: ['./app.component.css']
})
export class AppComponent {
 title = 'HealthCheck';
}
```
А вот соответствующий измененный файл /src/app/app.comComponent.html:

```ts
<app-nav-menu></app-nav-menu>
 <div class="container">
 <router-outlet></router-outlet>
 </div>
```
Как и ожидалось, обновленный AppComponent — это просто контейнер для элементов NavMenuComponent и <routeroutlet> Angular.

Замечание: Стоит отметить, что для добавления ссылки на NavMenuComponent нам пришлось использовать
тег <app-nav-menu>, который соответствует значению свойства селектора, указанного в
файл nav-menu.comComponent.ts.

# Обновление тестовых файлов
Теперь, когда мы переместили поведение AppComponent (и исходный код) в FetchDataComponent,
тест, определенный в файле app.comComponent.spec.ts, который ищет заголовок приложения, завершится неудачей; это может быть
легко протестировать, запустив Karma с помощью команды ng test и просмотрев результат.
Чтобы это исправить, у нас есть два варианта:
- Удалите файл /src/app.comComponent.spec.ts.
- Закомментируйте код этого теста, поскольку он нам больше не нужен.
Для простоты мы выберем последний вариант. Вот как мы можем это сделать:

```ts
// Test removed in Chapter 3,
// since the AppComponent doesn't contain the app's title anymore.
// it('should render title', () => {
// const fixture = TestBed.createComponent(AppComponent);
// fixture.detectChanges();
// const compiled = fixture.nativeElement as HTMLElement;
// expect(compiled.querySelector('h1')?.textContent).toContain('Weather
forecast');
// });
```

На этом все наши компоненты готовы: нам просто нужно добавить RouterModule в наше приложение Angular.
чтобы все работало.

# Добавление AppRoutingModule
Angular RouterModule — это дополнительная служба, которую можно использовать для отображения другого компонента при
URL-адрес клиента изменится: будет создан экземпляр отображаемого компонента и показан в <routeroutlet>, теге, который мы только что добавили в наш HTML-файл шаблона AppComponent.
RouterModule может быть реализован внутри AppModule или в отдельном модуле: однако, поскольку
использование специального модуля считается лучшей практикой (подробнее об этом позже), мы будем следовать этому подходу.
В обозревателе решений перейдите в папку /src/app/ и создайте новый файл TypeScript, назвав его
приложение-routing.module.ts. После этого заполните его следующим содержимым:

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { FetchDataComponent } from './fetch-data/fetch-data.component';
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'fetch-data', component: FetchDataComponent }
];
@NgModule({
 imports: [RouterModule.forRoot(routes)],
 exports: [RouterModule]
})
export class AppRoutingModule { }
```
Once done, open the app.module.ts file and update it in the following way (new/updated lines are
highlighted):

```ts
import { HttpClientModule } from '@angular/common/http';
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { HomeComponent } from './home/home.component';
import { FetchDataComponent } from './fetch-data/fetch-data.component';
import { NavMenuComponent } from './nav-menu/nav-menu.component';
@NgModule({
 declarations: [
 AppComponent,
 HomeComponent,
 FetchDataComponent,
 NavMenuComponent
 ],
 imports: [
 BrowserModule,
 HttpClientModule,
 AppRoutingModule
 ],
 providers: [],
 bootstrap: [AppComponent]
})
export class AppModule { }

```

То, что мы сделали, должно быть довольно простым: мы добавили новую ссылку на импорт, указывающую на наш новый
Путь к файлу AppRoutingModule и добавил его к импортированным модулям (массив импортов).


# Причины использования выделенного модуля маршрутизации
Мы только что сказали, что использование отдельного выделенного модуля маршрутизации считается лучшей практикой Angular.
но мы до сих пор не знаем причин этого. Какие льготы компенсируют дополнительные
работа, необходимая для поддержки исходного кода?
На самом деле, нет никаких реальных преимуществ для небольших и/или образцовых приложений. В этом случае большинство
разработчики, вероятно, предпочтут пропустить модуль маршрутизации и объединить конфигурацию маршрутизации.
непосредственно в самом AppModule, как это было в первом примере приложения VS.
Однако такой подход удобен только в том случае, если конфигурация приложения минимальна. Когда
приложение начинает расти, его логика маршрутизации со временем станет намного сложнее, благодаря некоторым
расширенные функции (такие как специализированные службы защиты и распознавания), которые рано или поздно нам понадобятся (или
надо) реализовать. Когда что-то подобное произойдет, нам поможет специальный модуль маршрутизации.
поддерживать чистоту исходного кода, упрощать и оптимизировать деятельность по тестированию, а также повышать общую эффективность
согласованность нашего приложения.
Единственным недостатком использования нескольких модулей является то, что Angular CLI генерирует
Команда не сможет определить, к какому модулю мы хотим добавить ссылки на компонент.
Например, если мы теперь попытаемся создать новый компонент, используя следующую команду:

ng генерировать тест компонента --skip-tests
Команда вернет следующую ошибку:
Ошибка: соответствует более одного модуля.
Используйте опцию пропуска импорта, чтобы пропустить импорт компонента в ближайший модуль.
Чтобы избежать вышеуказанной ошибки, у нас есть два варианта:
- Используйте ключ --skip-import и добавьте ссылки вручную.
- Используйте ключ --module=app, чтобы настроить таргетинг на определенный модуль.
В следующих главах мы будем часто использовать последний вариант всякий раз, когда нам понадобится добавить дополнительные компоненты.

# Последние штрихи
Наконец-то мы готовы протестировать наши новые компоненты, а также нашу минимальную систему навигации и маршрутизации.
Однако, прежде чем сделать это, давайте потратим еще пару минут на изменение ультраминималистичного значения по умолчанию.
HTML-шаблон HomeComponent с более приятным приветственным сообщением.
Откройте файл /src/app/home/home.comComponent.html и замените все его содержимое следующим:
<h1>Привет, незнакомец!</h1>
<p>Вот что вы получите за путаницу с ASP.NET и Angular.</p>
Сохраните все файлы, запустите проект в режиме отладки и будьте готовы увидеть следующее:

![image](https://github.com/artemovsergey/Angular/assets/26972859/0600d9be-436b-49c6-8c73-c4aa099beba2)

Это по-прежнему выглядит довольно просто и скучно, но эй… это только начало пути, верно?

# Тестовый забег
Теперь мы можем выполнить последний тестовый запуск, чтобы проверить, работают ли наши новые компоненты, а также маршрутизация и
навигационная система – действительно работает. Если бы у нас получилось что-то похожее на то, что мы видели в предыдущем
На скриншоте мы уже видим, что новый AppComponent работает, поскольку на нем показаны NavComponent и
Домашний компонент.

Нам просто нужно нажать ссылку «Извлечь данные» вверху, чтобы проверить, работает ли навигация и маршрутизация.
система тоже работает: если все сделано правильно, мы сможем увидеть наш новый
DataFetchComponent вместе с полученными данными API, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/70e28aad-5a3e-4803-8562-bb6b084b9a86)

Вот и все. Будьте уверены, мы легко можем добиться большего с точки зрения пользовательского интерфейса, UX и в целом.
функции: мы значительно улучшим внешний вид наших примеров приложений в следующих главах, где
начнем использовать таблицы стилей (которых мы еще даже не трогали!), добавим новые компоненты и так далее. Однако, по крайней мере на данный момент, мы можем быть довольны тем, что сделали: понимая, насколько легко
добавлять компоненты и обновлять их содержимое, а также насколько быстро Visual Studio, ASP.NET и Angular
будет реагировать на наши изменения — это достаточно хорошо.

# Краткое содержание
В этой главе мы потратили некоторое драгоценное время на изучение и понимание сути нашего примера проекта.
компоненты, то, как они работают вместе, и их отличительные роли. Для простоты мы разделили
анализ разделен на две части: серверная экосистема .NET, где мы проверили ядро ASP.NET.
проект веб-API (HealthCheckAPI) и интерфейсную архитектуру Angular, посвященную
Автономный проект Angular (HealthCheck). Мы видели, что каждый проект имеет свои собственные файлы конфигурации, структуру папок, соглашения об именах и общую область применения.
В конце концов, мы достигли конечной цели этой главы и узнали немало полезных вещей:
мы знаем расположение и назначение файлов исходного кода как на стороне сервера, так и на стороне клиента; мы предупреждены
большинства настроек и параметров конфигурации ASP.NET Core и Angular; мы также узнали, как
измените эти настройки в соответствии с нашими потребностями, такими как конечные точки маршрутизации веб-API, и вставьте новые элементы,
как мы это сделали с компонентами Angular и модулем маршрутизации.
Часть главы была посвящена Angular CLI: мы потратили много времени на изучение того, как
создавать новые компоненты, следуя лучшим практикам Angular. Такое время было проведено с пользой, так как
теперь мы знаем, как настроить новый проект ASP.NET Core и Angular, не полагаясь на
Шаблоны Visual Studio по умолчанию или используйте ручной подход.
И последнее, но не менее важное: мы также нашли время провести быстрый тестовый прогон, чтобы увидеть, готовы ли мы удерживать
наша основа против того, что будет в следующих главах: настройка улучшенного запроса-ответа
цикл, создание собственных контроллеров, определение дополнительных стратегий маршрутизации и многое другое.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: Razor Pages, разделение ответственности,
принцип единой ответственности, JSON, веб-хосты, Kestrel, промежуточное ПО ASP.NET, внедрение зависимостей, рабочее пространство Angular, Jasmine, Karma, модульные тесты, рендеринг на стороне сервера (SSR), TypeScript,
Архитектура Angular, цикл инициализации Angular и модуль Angular Router.

