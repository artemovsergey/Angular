# Beyond REST – Web API with GraphQL

До этого момента мы всегда предполагали, что веб-интерфейсы ASP.NET, используемые для передачи данных в наше приложение Angular, будут выполнять свою работу, используя архитектурный стиль Representational State Transfer (REST). Такое
предположение полностью оправдано тем, что REST является наиболее популярным вариантом доступа к
веб-сервисам на протяжении десятилетий, навязав себя всем предыдущим альтернативам (таким как SOAP) благодаря
неоспоримым преимуществам в плане надежности, производительности и использования пропускной способности.
Однако, несмотря на то, что REST стал стандартом де-факто для большинства задач по поиску данных, подход
не всегда идеален в любых обстоятельствах и может страдать от некоторых неоспоримых недостатков, таких как
например, неспособность поспевать за быстро меняющимися требованиями клиентов.
В этой главе мы познакомимся с современным языком запросов, созданным с конкретной целью
предоставить более эффективную и гибкую альтернативу традиционной архитектуре REST API: название этого языка - GraphQL.
GraphQL, и, как сообщается, его уже используют тысячи компаний в своих технологических
стеках, включая Facebook, Shopify, Instagram, GitHub, Twitter, PayPal, Airbnb, Atlassian, Pinterest,
и многие другие.

Если говорить более конкретно, то вот что мы сделаем:
- Представим GraphQL, объясним его отличительные особенности и преимущества перед традиционной
REST-архитектурой
- Добавим поддержку GraphQL в наш ASP.NET Core Web API с помощью стороннего пакета NuGet
- Добавьте поддержку GraphQL в наше приложение Angular с помощью стороннего клиента GraphQL.
- Выполните несколько интеграционных тестов, чтобы увидеть, как работает новая архитектура GraphQL и как мы
как мы можем использовать ее для улучшения нашего существующего приложения
Мы готовы? Давайте начнем!

Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах,
а также следующие дополнительные пакеты ASP.NET Core NuGet:
- HotChocolate.AspNetCore
- HotChocolate.Data.EntityFramework
И следующие пакеты Angular npm:
- @apollo/client
- apollo-angular
- graphql
Как всегда, рекомендуется избегать их установки сразу; мы будем вводить их в течение
этой главы, чтобы лучше понять их назначение в нашем проекте.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/main/Chapter_13/.

# GraphQL в сравнении с REST
Как мы уже говорили, GraphQL - это язык запросов и манипулирования данными с открытым исходным кодом, который предоставляет
набор правил и стандартов для создания эффективных и гибких веб-интерфейсов. Язык был разработан
Facebook в 2012 году в качестве внутреннего проекта, а в 2015 году был выпущен в открытый доступ.
и сразу же привлек внимание многих разработчиков благодаря своему инновационному подходу.
Сравнение GraphQL с REST практически неизбежно, поскольку первый был разработан с
с целью устранить некоторые из наиболее заметных недостатков REST: именно по этой причине лучше всего
Чтобы понять плюсы и минусы этих двух подходов, лучше всего кратко описать отличительные особенности каждого из них, начиная с технологии, которая появилась первой.

# REST
Representational State Transfer, более известный как REST, - это архитектурный стиль, специально разработанный для
сетевых приложений, использующих стандартные методы запросов HTTP get post put и delete
для доступа к данным и манипулирования ими.

Эти методы HTTP были определены в RFC 2616 (июнь 1999 г.), который содержит
спецификации для протокола HTTP/1.1: https://www.w3.org/Protocols/rfc2616/
rfc2616.html.

Концепция REST была впервые представлена и определена в 2000 году Роем Томасом Филдингом, сооснователем проекта Apache HTTP Server и одним из главных авторов спецификации HTTP.
Рой Томас Филдинг, сооснователь проекта Apache HTTP Server и один из основных авторов спецификации HTTP, в своей докторской диссертации
диссертации "Архитектурные стили и проектирование сетевых программных архитектур".

В отличие от того, что многие считают, в этой диссертации Филдинг не представил новый набор методологий для создания веб-интерфейсов: он в основном обобщил основные архитектурные принципы, использованные при разработке протокола и спецификаций HTTP, в создании которых он принимал участие (HTTP/1.0) и был одним из авторов (HTTP/1.1).
HTTP-протокола и спецификаций, в разработке которых он принимал участие (HTTP/1.0) и был соавтором (HTTP/1.1).
По сути, архитектурный стиль REST - это не что иное, как дистилляция этих принципов,
которые (по его мнению) могут быть использованы в качестве руководства для реализации любого распределенного приложения через веб,
включая, но не ограничиваясь, теми сервисами, специально созданными для обмена данными между клиентами и
серверами, которые мы сегодня называем Web API.
О том, что интуиция Филдинга оказалась верной, свидетельствуют миллионы веб-сервисов RESTful, созданных
за последние 20 лет для решения самых разных задач: веб-сайты, настольные и мобильные приложения, онлайн-игры,
операционных систем, IoT-устройств и так далее.

Наши приложения HealthCheckAPI и WorldCitiesAPI ASP.NET Core также входят в этот список.
поскольку они были разработаны на основе REST-подхода.


Если учесть, что одной из важнейших функций Интернета является обмен данными, то
мы можем признать важность этой архитектуры, поскольку большая часть информации в настоящее время
передается с помощью REST.
Руководящие ограничения
Основные архитектурные принципы HTTP, определенные Филдингом, определяют шесть руководящих ограничений REST, которые,
при правильной реализации обеспечивают системе набор желаемых нефункциональных свойств,
включая производительность, масштабируемость, простоту, модифицируемость, видимость, переносимость и надежность.
Вот краткий список этих шести направляющих ограничений и свойств, которых они позволяют нам достичь:
1. Клиент-серверная архитектура. В RESTful API должен соблюдаться принцип разделения забот,
тем самым отделяя пользовательский интерфейс от хранилища данных. Разделение этих задач улучшает
переносимость, а также простоту, масштабируемость и модифицируемость всей системы.
2. Нестационарность. Сервер должен обрабатывать все сообщения между клиентами, не сохраняя
данных от предыдущих вызовов. Это означает, что сервер не должен хранить состояние сессии
содержащее информацию, связанную с контекстом (например, ключи аутентификации). Это означает, что если клиентам необходимо
аутентификации и/или авторизации, сервер должен предоставить им средства
для этого при каждом обращении. Идеальным примером этого может служить JWT, о котором мы говорили в
Глава 11, Аутентификация и авторизация, который хранится в локальном хранилище клиента и
аутентифицируется сервером без необходимости хранить какую-либо дополнительную информацию. Отсутствие статичности
позволяет снизить накладные расходы сервера на каждый запрос, что может значительно
что может значительно повысить производительность и масштабируемость всей системы, особенно при высокой нагрузке.
3. Кэшируемость. Серверы и клиенты должны использовать возможности кэширования, изначально заложенные в протокол HTTP. В основном это означает, что все HTTP-ответы должны содержать
соответствующие кэширующие (или некэширующие) заголовки, чтобы уменьшить размер передаваемых данных,
а также минимизировать риск предоставления неактуального или устаревшего содержимого.

Хорошая стратегия кэширования может оказать огромное влияние на масштабируемость и производительность всей системы.
системы.
4. Многоуровневая система. Сервер, вместо того чтобы быть доступным напрямую, должен находиться за одним или несколькими промежуточными HTTP-сервисами или фильтрами (NAT, прокси-серверы, балансировщики нагрузки).
или несколькими промежуточными HTTP-сервисами или фильтрами (NAT, прокси, балансировщики нагрузки и т. п.).
Опосредование входящих вызовов не только улучшит общие аспекты безопасности Web
API, но и повысит его производительность, масштабируемость и надежность.
5. Код по требованию. Сервер должен предоставлять клиентам исполняемый код или скрипты, которые можно
которые могут быть использованы для принятия пользовательского поведения. Это единственное необязательное ограничение REST, которое редко используется
в настоящее время, поскольку при неправильной реализации оно создает очевидные проблемы с безопасностью. Кроме того,
сценарий использования несколько ограничен: одним из возможных примеров применения могут быть распределенные
вычисления, где сервер может захотеть делегировать клиентам часть своей работы, или удаленные
удаленные методы оценки, когда серверу требуется, чтобы клиент выполнил некоторые локальные проверки, например
например, проверить, установлены ли некоторые приложения или драйверы. В этих крайних сценариях
Code on Demand, скорее всего, повысит производительность и масштабируемость системы, но при этом
однако это также может снизить ее общую заметность.
6. Единый интерфейс. Это ограничение определяет четыре фундаментальных требования, которые должен реализовать RESTful
интерфейс должен быть реализован, чтобы отделить требования клиента (обмен данными) от
базовой реализации (например, получение, обновление и удаление данных). К этим требованиям относятся:
1. Идентификация ресурсов. Каждый ресурс должен быть однозначно идентифицирован с помощью
уникальный URI.
2. Манипулирование ресурсами через представления. Клиенты должны иметь возможность выполнять
основные операции с ресурсами, используя URI ресурса и соответствующий HTTP
без необходимости получения дополнительной информации.
3. Самоописывающиеся сообщения. Каждое сообщение отправителя должно содержать всю информацию.
необходимую получателю для его правильного понимания и обработки. Такое требование
легко реализовать в протоколе HTTP благодаря HTTP-заголовкам, которые могут быть
включать как в запросы, так и в ответы.
4. Hypermedia As The Engine Of Application State (HATEOAS). Сервер должен предоставлять
клиентам информацию об использовании с помощью стандартизированного набора гиперссылок и URI. Такое
требование отделяет сервер от его клиентов и позволяет ему развиваться
независимо развиваться, снижая риск возникновения проблем с обратной совместимостью.
Если веб-сервис реализует все вышеперечисленные ограничения, его условно называют RESTful.
Недостатки
Несмотря на неоспоримый успех, REST-подход по своей сути имеет ряд известных ограничений
которые в большинстве случаев могут практически не влиять на работу системы, но могут стать проблемой при работе с
нетривиальными задачами поиска данных. Давайте попробуем выявить их, рассмотрев REST API, предоставляемый
нашим приложением WorldCitiesAPI и используемый нашим текущим клиентом Angular для взаимодействия с базой данных
базой данных WorldCities.
Каждый раз, когда наш клиент хочет получить данные о стране, он должен обратиться к следующей конечной точке API: /api/
Countries/{id}.

Этот вызов также позволяет клиенту получить количество городов, благодаря свойству TotCities, которое
которое мы добавили в главе 8 "Настройки кода и службы данных".
Однако в настоящее время мы не можем получить некоторые свойства этих городов, такие как их название или id.
Эта конечная точка не может этого сделать. Более того, в настоящее время у нас нет конечной точки, возвращающей список
городов для заданного идентификатора страны. Единственная конечная точка, которая возвращает список городов, /api/Cities, не будет
не принимает такой фильтр.
Это означает, что если бы мы хотели это сделать, то должны были бы выполнить одно из следующих действий:
- Обновить существующую конечную точку /api/Countries/{id}, добавив дополнительное свойство Cities в
в полученный CountryDTO, содержащий список всех городов, принадлежащих этой стране, со всеми
свойствами, которые могут нам понадобиться
- Обновите существующую конечную точку /api/Cities, заставив ее принимать параметр CountryId (или фильтр).
- Реализовать новую конечную точку, например /api/Countries/{countryId}/Cities или что-то подобное.
Мы можем легко увидеть, что все вышеперечисленные альтернативы имеют свои недостатки:
Мы можем легко увидеть, что все вышеперечисленные альтернативы имеют свои недостатки:
- Обновление конечной точки /api/Countries/{id}, чтобы она возвращала список городов, значительно увеличит размер HTTP-ответа, что может иметь нетривиальные последствия для производительности;
Кроме того, обновление может привести к неожиданным ошибкам регрессии и/или потребовать
изменения его интерфейса, что заставит нас обновить приложение Angular. Кроме того, в конечном итоге мы получим множество данных Cities, которые нам не нужны для наших целей - нежелательное
явление, известное как избыточная выборка, или проблема N+1.
- Обновление существующего метода /api/Cities может смягчить проблему избыточной выборки, но не
минимизирует риски возникновения регрессионных ошибок; кроме того, это заставит нас совершить дополнительный
обходной путь (новый HTTP-запрос) для получения нужных нам данных.
- Добавление дополнительной конечной точки убережет нас от ошибок регрессии, но все равно потребует
дополнительного обхода. Кроме того, это, вероятно, повлияет на время разработки внутреннего интерфейса
и усложнит наш API.
Приведенный выше пример позволяет выявить некоторые важные недостатки архитектурного стиля REST:
риск чрезмерной выборки и частая необходимость многократного обхода, что связано с недостаточной гибкостью
таких подходов. Что касается регрессионных ошибок, то, хотя они и не являются недостатком, характерным только для REST, риск их возникновения
часто увеличивается из-за неизбежного рефакторинга, требуемого при каждом новом запросе на изменение
Что, если нам нужно получить города только в определенном диапазоне широт и длин волн? Или страны, в которых больше
(или меньше), чем N городов? И так далее.
Как мы можем легко понять, решение подобных проблем может оказаться не таким уж простым, особенно если нам требуется
высокий уровень универсальности в плане требований к получению данных на стороне клиента.

# GraphQL
После 15 лет неоспоримого превосходства - и миллионов веб-сервисов RESTful, созданных по всему миру
После 15 лет неоспоримого господства - и миллионов веб-сервисов REST, разработанных по всему миру, - архитектурному стилю REST бросил вызов новичок.

14 сентября 2015 года компания Facebook решила выложить в открытый доступ спецификации своего внутреннего языка запросов.
а также широкий набор инструментов реализации для большинства популярных языков программирования,
включая JavaScript, Go, PHP, Java, Python, Ruby и другие.
Выпуск GraphQL позволил сообществу разработчиков воспользоваться отличительными особенностями
нового языка, который позволяет клиентам отправлять и получать данные совершенно иначе, чем
REST. Точнее, вместо того, чтобы выполнять несколько HTTP-запросов к различным конечным точкам
и получать несколько HTTP-ответов, содержащих различные наборы данных, клиенты могли запрашивать то, что им нужно
что им нужно, с помощью одного запроса к одной конечной точке и получать именно то, что им нужно, с помощью одного,
динамически структурированным ответом.
Преимущества по сравнению с REST
Основные различия между REST и GraphQL можно наглядно представить, взглянув на следующую схему:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c089c2b8-4bf6-4629-84aa-e9bdc7995762)

Как мы видим, при использовании REST нам приходится иметь дело с множеством конечных точек API, каждая из которых извлекает
данные из нашей СУБД, используя свою собственную стратегию реализации (которая может быть стандартизированной, специфической или
смесь того и другого). Добавление большего числа конечных точек снижает риск переизбытка выборки и регрессионных ошибок, но при этом
неизбежно потребует многократных обходов, а также усложнит задачу и увеличит время разработки.
И наоборот, GraphQL дает нам возможность работать с одной конечной точкой, которая примет наш запрос на получение данных
запрос, выполнит его в СУБД и вернет "объединенный" набор JSON-данных, без избыточной выборки и
избегая многочисленных обходов. Стоит отметить, что и запрос, и результирующие данные будут иметь
одинаковую JSON-структуру, построенную с использованием стандартов, заданных спецификацией GraphQL, которая будет обрабатываться
специальная серверная среда выполнения.

Ограничения
Хотя GraphQL обладает рядом неоспоримых преимуществ по сравнению с традиционными REST API, ему присущ и ряд
ключевых недостатков. Давайте вкратце обсудим наиболее значимые из них:
- GraphQL требует наличия клиентского модуля для создания запросов и серверной среды выполнения для выполнения
этих запросов (или чтобы совместимая ORM могла их обрабатывать). Эти требования
неизбежно добавят сложности клиенту и серверу и/или увеличат время разработки.
- Запросы на GraphQL часто возвращают HTTP-код состояния 200, независимо от того, был ли запрос успешным.
успешным. Точнее, если запрос завершился неудачей, в JSON-ответе будет верхний уровень errors
с сообщением (сообщениями) об ошибке. Это усложнит обработку ошибок для клиента и
также может привести к дополнительным сложностям в задачах протоколирования и мониторинга. Однако такое
ограничение в основном связано с тем, что инструменты, которые мы обычно используем для решения этих задач, предназначены для
получать и обрабатывать ответы на основе HTTP, в то время как GraphQL был разработан для работы поверх
этого протокола.
- GraphQL не имеет встроенной поддержки кэширования. В отличие от REST API, которые могут использовать встроенное HTTP-кэширование благодаря тому, что несколько конечных точек возвращают одни и те же данные для
одни и те же запросы, GraphQL требует от разработчика реализации пользовательской (и часто не RESTful)
поддержку кэширования или использовать клиентскую библиотеку, поддерживающую такую возможность.
- Запросы GraphQL, безусловно, сложнее в реализации, чем конечные точки REST. Это верно
на уровне клиента, когда нам нужно собрать запрос, и еще более верно на стороне сервера,
где нужно выполнить запрос к СУБД.
Вышеперечисленные ограничения являются основной причиной того, что GraphQL в настоящее время не может победить REST, по крайней мере
по крайней мере, на сегодняшний день. На самом деле, когда нам приходится иметь дело с простыми наборами данных и/или с данными, которые
относительно постоянны во времени, подход REST по-прежнему остается наиболее эффективным и удобным.
идти. И наоборот, если нам нужно работать со сложными сценариями с быстро меняющимися данными, GraphQL может
решить некоторые болезненные недостатки REST и помочь нам создать более надежное, эффективное и удобное в обслуживании приложение.
Для целей этой книги, учитывая общую простоту наших примеров HealthCheckAPI и
WorldCitiesAPI (и лежащей в их основе СУБД), мы можем сказать, что REST API - это определенно путь
для использования. Тем не менее, в следующем разделе мы кратко рассмотрим, как можно реализовать полнофункциональный GraphQL
API поверх существующей кодовой базы WorldCities.

# Реализация GraphQL
Обеспечение поддержки GraphQL в приложении WorldCities требует некоторой работы на уровне back-end и front-end.
Вот задачи, которые мы рассмотрим в этом разделе:
- Добавить поддержку GraphQL в ASP.NET Core с помощью сторонней библиотеки HotChocolate
- Добавить поддержку GraphQL в Angular с помощью клиента Apollo Angular GraphQL
- Протестировать интеграцию на стороне сервера и клиента с помощью Visual Studio.
Давайте воплотим этот план в жизнь.

# Добавление GraphQL в ASP.NET Core
Если мы хотим обеспечить наше существующее приложение ASP.NET Core поддержкой GraphQL, нам нужно добавить слой GraphQL
слой в HTTP-конвейер, который будет выполнять следующие задачи:
- Выставить конечную точку API, которую клиенты будут использовать для отправки своих запросов GraphQL
- обрабатывать входящие запросы, используя нашу существующую модель данных
- Получение запрошенных данных из базовой СУБД
- Предоставить ответ с полученными данными в формате JSON.
Реализация этих функций с нуля потребовала бы значительного объема работы, даже для
даже для нашей ограниченной схемы базы данных.
К счастью, нам не нужно этого делать благодаря существованию нескольких клиентских библиотек ASP.NET Core, которые сделают большую часть работы за нас, например GraphQL.NET и HotChocolate, доступные
на GitHub под лицензией MIT.

В этой главе мы будем использовать HotChocolate, комплексную платформу .NET GraphQL, которая может
поможет нам достичь вышеуказанной цели с минимальными усилиями.
Установка HotChocolate
Необходимые нам компоненты HotChocolate доступны в двух удобных пакетах NuGet, которые
которые мы можем установить из графического интерфейса Visual Studio (с помощью менеджера пакетов NuGet) или с помощью консоли менеджера пакетов
Manager с помощью следующей команды:

```
PM> Install-Package HotChocolate.AspNetCore -Version 12.6.0
PM> Install-Package HotChocolate.AspNetCore.Authorization -Version 12.6.0
PM> Install-Package HotChocolate.Data.EntityFramework -Version 12.6.0
```
Предлагаемая версия, последняя на момент написания статьи, полностью совместима с нашим проектом WorldCitiesAPI
проектом.

Как всегда, мы можем выбрать другую версию, если считаем, что сможем справиться с
требуемыми обновлениями.

Первый пакет NuGet содержит GraphQL-сервисы и промежуточные модули HotChocolate и является единственным
необходимый.

Второй и третий пакеты содержат несколько полезных (но необязательных) расширений, которые позволят нам легко интегрировать модель авторизации ASP.NET Core и Entity Framework Core в HotChocolate,
что значительно ускорит время разработки: именно по этой причине мы будем использовать эту библиотеку.
Сразу после установки HotChocolate мы можем приступить к настройке схемы GraphQL, которая определяет, как мы
как мы хотим предоставлять данные клиенту и какие CRUD-операции мы хотим разрешить. Такая схема может быть
настроить с помощью трех корневых типов:
- Query, который раскрывает все возможные запросы, которые могут использовать клиенты, тем самым позволяя им получать
данные только для чтения. Мы можем представить его как централизованное представление всех наших сущностей, с
ряд методов, соответствующих различным способам их получения.
- Мутация, которая может использоваться клиентами для выполнения операций записи, таких как вставка, обновление,
и удаление сущностей.
- Подписка, которая позволяет клиентам подписываться на события и получать уведомления в реальном времени об их
их наступлении.
В следующих подразделах мы реализуем типы Query и Mutation, которые позволят
нашим клиентам выполнять те же операции чтения, добавления, обновления и удаления, которые мы реализовали в предыдущих главах с помощью
предыдущих главах, используя REST.

# Запрос
Используя Solution Explorer, создайте новую папку /Data/GraphQL/ в проекте WorldCitiesAPI. После этого
добавьте в нее новый файл Query.cs и заполните его содержимое следующими строками:

```Csharp
using Microsoft.EntityFrameworkCore;
using WorldCitiesAPI.Data.Models;
namespace WorldCitiesAPI.Data.GraphQL
{
 public class Query
 {
 /// <summary>
 /// Gets all Cities.
 /// </summary>
 [Serial]
 [UsePaging]
 [UseFiltering]
 [UseSorting]
 public IQueryable<City> GetCities(
 [Service] ApplicationDbContext context)
 => context.Cities;
 /// <summary>
 /// Gets all Countries.
/// </summary>
 [Serial]
 [UsePaging]
 [UseFiltering]
 [UseSorting]
 public IQueryable<Country> GetCountries(
 [Service] ApplicationDbContext context)
 => context.Countries;
 }
}
```
Как мы видим, в предыдущем типе Query есть два метода, которые используют Entity Framework для возврата
объекты IQueryable.
Самое важное, на что стоит обратить внимание, - это атрибуты аннотации данных, которые мы добавили выше
в два метода, чтобы обеспечить возможность листания, фильтрации и сортировки. Как нетрудно догадаться, эти атрибуты позволяют
прозрачно использовать некоторые мощные встроенные функции HotChocolate.
А именно:
- Serial. Этот атрибут указывает HotChocolate выполнять определенные задачи в последовательном, а не параллельном
что делает его совместимым с нашей текущей реализацией ApplicationDbContext.
Стоит отметить, что эта опция нетривиально скажется на производительности, однако,
мы воспользуемся им - по крайней мере, для этого примера - чтобы избежать рефакторинга нашего приложения (см.
ниже для дополнительной информации).
- UsePaging. Этот атрибут добавит Pagination Middleware, которое позволит клиентам GraphQL
пагинацию результатов с использованием спецификации курсорных соединений - стандартизированного способа, позволяющего клиентам
последовательно обрабатывать лучшие практики пагинации с поддержкой связанных метаданных.
- UseFiltering. Этот атрибут добавляет промежуточное ПО фильтрации, которое позволяет клиентам GraphQL использовать
фильтры, которые будут транслироваться в собственные запросы к базе данных. Доступные фильтры будут автоматически определяться HotChocolate на основе типов сущностей IQueryable.
- UseSorting. Этот атрибут добавляет промежуточное ПО сортировки, которое позволяет клиентам GraphQL сортировать
результаты с помощью аргумента сортировки, который будет переведен HotChocolate в LINQ-запрос,
и в конечном итоге, благодаря EF Core, в запросы к родным базам данных.
Атрибут Serial и причина, по которой мы его используем, - довольно сложная тема, которая заслуживает некоторого
дополнительного объяснения. Когда мы используем services.AddDbContext<T> для регистрации DbContext в качестве скопированного
сервиса, создается один экземпляр этого DbContext, который используется для всего GraphQL-запроса. Это
является проблемой, поскольку HotChocolate по соображениям производительности выполняет распознаватели запросов параллельно. Если
два распознавателя выполняются параллельно и оба пытаются выполнить операцию с использованием одного и того же DbContext,
мы можем увидеть одно из следующих исключений:
- Вторая операция началась в этом контексте до того, как была завершена предыдущая операция
- Невозможно получить доступ к утилизированному объекту

Оба они являются исключениями параллелизма, вызванными тем, что, вкратце, наш DbContext не является
потокобезопасным. Эту проблему можно решить либо с помощью атрибута Serial, что заставит HotChocolate
работать в последовательном режиме, либо реализовав метод расширения AddDbContextFactory - впервые появившийся
в .NET 5 - который позволяет нам регистрировать фабрику вместо одного экземпляра DbContext.

Чтобы не усложнять ситуацию, мы будем использовать атрибут [Serial] в качестве обходного пути для нашего
для нашего текущего сценария реализации. Тем не менее, подход AddDbContextFactory - это
для приложений производственного уровня.

Перейдем к другим атрибутам: UsePaging, UseFiltering и UseSorting. Если мы подумаем об этом
на секунду, то увидим, как они выполняют те же требования, которые мы реализовали в главе
6, "Получение и отображение данных", с помощью нашего класса ApiResult, при этом не нужно писать ни одной строки
кода. Эти мощные встроенные функции - часть причины, по которой мы используем HotChocolate вместе с
интеграционным пакетом для EF Core.

Этот минимальный тип Query - все, что нам нужно, чтобы выполнить наши требования по доступу только для чтения. Теперь давайте перейдем к
письменной части истории.

# Мутация
Добавьте новый файл Mutation.cs и заполните его содержимое следующими строками:

```Csharp
using HotChocolate.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using WorldCitiesAPI.Data.Models;
namespace WorldCitiesAPI.Data.GraphQL
{
 public class Mutation
 {
 /// <summary>
 /// Add a new City
 /// </summary>
[Serial]
 [Authorize(Roles = new[] { "RegisteredUser" })]
 public async Task<City> AddCity(
 [Service] ApplicationDbContext context, CityDTO cityDTO)
 {
 var city = new City() {
 Name = cityDTO.Name,
 Lat = cityDTO.Lat,
 Lon = cityDTO.Lon,
 CountryId = cityDTO.CountryId
 };
 context.Cities.Add(city);
 await context.SaveChangesAsync();
 return city;
 }
 /// <summary>
 /// Update an existing City
 /// </summary>
 [Serial]
 [Authorize(Roles = new[] { "RegisteredUser" })]
 public async Task<City> UpdateCity(
 [Service] ApplicationDbContext context, CityDTO cityDTO)
 {
 var city = await context.Cities
 .Where(c => c.Id == cityDTO.Id)
 .FirstOrDefaultAsync();
 if (city == null)
 // todo: handle errors
 throw new NotSupportedException();
 city.Name = cityDTO.Name;
 city.Lat = cityDTO.Lat;
 city.Lon = cityDTO.Lon;
 city.CountryId = cityDTO.CountryId;
 context.Cities.Update(city);
 await context.SaveChangesAsync();
 return city;
 }
 /// <summary>
 /// Delete a City
/// </summary>
 [Serial]
 [Authorize(Roles = new[] { "Administrator" })]
 public async Task DeleteCity(
 [Service] ApplicationDbContext context, int id)
 {
 var city = await context.Cities
 .Where(c => c.Id == id)
 .FirstOrDefaultAsync();
 if (city != null)
 {
 context.Cities.Remove(city);
 await context.SaveChangesAsync();
 }
 }
 /// <summary>
 /// Add a new Country
 /// </summary>
 [Serial]
 [Authorize(Roles = new[] { "RegisteredUser" })]
 public async Task<Country> AddCountry(
 [Service] ApplicationDbContext context, CountryDTO countryDTO)
 {
 var country = new Country() {
 Name = countryDTO.Name,
 ISO2 = countryDTO.ISO2,
 ISO3 = countryDTO.ISO3
 };
 context.Countries.Add(country);
 await context.SaveChangesAsync();
 return country;
 }
 /// <summary>
 /// Update an existing Country
 /// </summary>
 [Serial]
 [Authorize(Roles = new[] { "RegisteredUser" })]
 public async Task<Country> UpdateCountry(
 [Service] ApplicationDbContext context, CountryDTO countryDTO)
{
 var country = await context.Countries
 .Where(c => c.Id == countryDTO.Id)
 .FirstOrDefaultAsync();
 if (country == null)
 // todo: handle errors
 throw new NotSupportedException();
 country.Name = countryDTO.Name;
 country.ISO2 = countryDTO.ISO2;
 country.ISO3 = countryDTO.ISO3;
 context.Countries.Update(country);
 await context.SaveChangesAsync();
 return country;
 }
 /// <summary>
 /// Delete a Country
 /// </summary>
 [Serial]
 [Authorize(Roles = new[] { "Administrator" })]
 public async Task DeleteCountry(
 [Service] ApplicationDbContext context, int id)
 {
 var country = await context.Countries
 .Where(c => c.Id == id)
 .FirstOrDefaultAsync();
 if (country != null)
 {
 context.Countries.Remove(country);
 await context.SaveChangesAsync();
 }
 }
 }
}
```
Как мы видим, мы создали шесть методов, которые позволят клиентам добавлять, обновлять и удалять наши сущности Cities
и Countries с помощью Entity Framework.

Стоит отметить, что в реализации методов добавления и обновления мы использовали классы
классы CityDTO и CountryDTO Data Transfer Object, которые мы создали в главе 8, Код
Твики и службы данных, сопоставляя их с соответствующими сущностями City и Country.

Мы также применили атрибут [Authorize], предоставляемый пакетом HotChocolate.AspNetCore.Authorization
для этих методов, чтобы ограничить доступ только для авторизованных пользователей (ролей). По сути, это тот же
подход, который мы использовали в CitiesController и CountriesController, с одним важным отличием:
в этот раз мы использовали другой атрибут [Authorize], предоставляемый пространством Microsoft.AspNetCore.
Authorization, который здесь не подойдет.

У этих двух атрибутов одинаковое имя, но, к счастью, они принимают разные типы параметров Roles
тип параметра. Атрибуту Microsoft нужна строка, а атрибуту HotChocolate требуется
массив строк. Это различие поможет нам отличить их друг от друга.

Не забудьте добавить правильную ссылку на пространство имен в верхней части файла, как мы это сделали в предыдущем коде
коде.

# Program.cs
Теперь, когда наша схема GraphQL готова, нам остается добавить необходимые сервисы и промежуточные модули
в наш файл Program.cs.
Начнем с сервисов. Откройте файл Program.cs и добавьте следующие выделенные строки прямо
под сервисом JwtHandler, который мы добавили в главе 11, Аутентификация и авторизация:

```Csharp
// ...
using WorldCitiesAPI.Data.GraphQL;
// ...
builder.Services.AddScoped<JwtHandler>();
builder.Services.AddGraphQLServer()
 .AddAuthorization()
 .AddQueryType<Query>()
 .AddMutationType<Mutation>()
 .AddFiltering()
 .AddSorting();
```
Сервис поставляется с большим количеством вспомогательных методов, которые можно использовать для настройки его различных параметров. Однако сейчас нам не нужно ничего делать, поскольку нам достаточно значений по умолчанию. Нам просто нужно
добавить типы Query и Mutation, которые мы реализовали ранее, и включить фильтрацию и сортировку.

Теперь перейдем к промежуточному ПО. Прокрутите немного вниз и добавьте следующие выделенные строки прямо под
метода MapControllers():

```Csharp
app.MapControllers();
app.MapGraphQL("/api/graphql");
```
Опять же, промежуточное ПО принимает различные параметры конфигурации. В нашем сценарии нам нужно было только настроить
конечную точку GraphQL (по умолчанию это "/graphql"), чтобы она была совместима с правилом Angular Proxy, которое
которое уже есть в файле proxy.conf.js нашего приложения Angular.
Теперь мы можем проверить, что мы сделали до сих пор.

# Тестирование схемы GraphQL
Еще одна замечательная особенность HotChocolate заключается в том, что он поставляется со встроенным веб-клиентом GraphQL, который
который можно использовать для тестирования нашего сервиса GraphQL с помощью удобного визуального интерфейса. Это очень удобно для наших целей, поскольку нам все равно придется иметь дело с нашим Angular-приложением.
Этот клиент называется Banana Cake Pop (BCP), и доступ к нему можно получить с помощью стандартной конечной точки
(/api/graphql). Чтобы получить доступ к нему, запустите приложение, нажав F5, а затем перейдите по следующему URL:
https://localhost:40443/api/graphql.
Если мы все сделали правильно, мы должны увидеть экран приветствия BCP, как показано на
следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/8080f9ce-0e57-4d0e-aa87-a4fb2091f8da)

Нажмите CTRL + ALT + T, чтобы открыть новую вкладку, а затем введите следующий пример запроса:

```json
query {
 cities(order: { id: ASC }, first:3 ) {
 nodes {
 id
 name
 }
 }
}
```
Чтобы получить следующий результат:

```json
{
 "data": {
 "cities": {
 "nodes": [
 {
 "id": 1,
 "name": "Tokyo"
 },
 {
 "id": 2,
 "name": "Jakarta"
 },
 {
 "id": 3,
 "name": "Delhi"
 }
 ]
 }
 }
}
```
Если мы видим приведенные выше результаты, это означает, что наша реализация на стороне сервера с использованием HotChocolate
работает!
С помощью этого первого запроса мы уже протестировали промежуточное ПО сортировки. Чтобы протестировать промежуточное ПО фильтрации, мы
можем изменить запрос следующим образом:

```json
query {
 cities(
 order: { id: ASC }
 first:3
where: { name: { endsWith: "kyo" } }
 )
 {
 nodes {
 id
 name
 }
 }
}
```
Это ограничивает наши результаты только двумя городами, заканчивающимися на "кио", - Токио и Новым Токио, городом, который
мы добавили в главе 7 "Формы и проверка данных".

# Проблемы с именованием в GraphQL
При запросе Cities все выглядит хорошо. Однако если мы попытаемся получить некоторые страны, мы
мы, скорее всего, столкнемся со странным поведением, с которым мы уже сталкивались в прошлом.
Например, если мы попытаемся выполнить этот запрос:

```json
query {
 countries(order: { id: ASC }, first:3 ) {
 nodes {
 name
 iso2
 iso3
 }
 }
}
```

В окне ответа ППГ мы получим следующую ошибку:
"Поле 'iso2' не существует для типа 'Страна'".
Причина такой ошибки нам уже известна. Это та самая "проблема именования", на которую мы наткнулись
в главе 6, "Получение и отображение данных", из-за автоматического преобразования camelCase в API System.
Text.Json API, которую мы исправили с помощью атрибута аннотации данных [JsonPropertyName] в наших классах Country
и CountryDTO.
Собственно говоря, HotChocolate обеспечивает такое же поведение, автоматически преобразуя свойства нашего объекта
свойства в camelCase, и атрибут [JsonPropertyName] для него ничего не значит.
К счастью, пакет предоставляет специальный атрибут [GraphQLName], который можно использовать для получения
тот же результат. По сути, это означает, что для решения нашей проблемы нам нужно просто добавить такой атрибут в
классы Country и CountryDTO следующим образом:

```Csharp
[JsonPropertyName("iso2")]
[GraphQLName("iso2")]
public string ISO2 { get; set; } = null!;
 [JsonPropertyName("iso3")]
 [GraphQLName("iso3")]
 public string ISO3 { get; set; } = null!;
```
Как только мы это сделаем, приведенный выше запрос будет работать без проблем.

Обязательно примените атрибут [GraphQLName] к свойствам ISO2 и ISO3 обоих классов
классов Country и CountryDTO, иначе пример из этой главы не будет работать.

Пока все хорошо. Теперь самое время переключиться на Angular и подключиться к нашему новому серверному GraphQL-сервису с помощью нашего клиента.

# Добавление GraphQL в Angular
Чтобы использовать нашу новую конечную точку GraphQL в Angular, у нас есть два варианта:
- Вручную реализовать GraphQL-клиент, позаботившись о базовом HTTP-соединении и
а также различные задачи по выборке, кэшированию и оптимизации.
- Добавить сторонний пакет, который (надеемся) уже делает все это.
Как бы странно это ни звучало, но реализовать минимальный GraphQL-клиент не так уж и сложно. Теперь, когда
мы знаем, как работает HttpClient в Angular, мы можем применить эти знания на практике и реализовать
сервис на основе наблюдаемых данных, используя паттерн суперкласса/подкласса, который мы использовали в главе 8, "Настройки кода и сервисы данных".
Настройки и службы данных", с нашими существующими типами BaseService, CountryService и CityService.

Однако для простоты мы остановимся на стороннем пакете. Точнее, мы будем использовать Apollo Angular, гибкий, поддерживаемый сообществом клиент GraphQL для Angular, JavaScript и
нативных платформ. Основное преимущество такого клиента заключается в том, что его невероятно легко
что позволяет нам просто вставить его в наше существующее приложение на Angular в течение нескольких минут.
Вот что мы будем делать в следующих разделах:
- Установим Apollo Angular в наш проект WorldCities вместе со всеми его зависимостями
- Обновим наш CityService, рефакторив пример метода так, чтобы он использовал GraphQL вместо
существующих конечных точек REST
- Протестируйте его, чтобы убедиться, что новая реализация работает так, как ожидалось
- Улучшите реализацию путем рефакторинга других методов REST
- Расширьте изменения, применив их и к сервису CountryService.
Мы готовы? Поехали!

# Установка Apollo Angular
Начиная с версии 2, Apollo Angular поддерживает команду ng-add, что означает, что мы можем установить его
его с помощью однострочной команды из Angular CLI следующим образом:
```
> ng add apollo-angular
```
Однако, по крайней мере на момент написания статьи, этот подход не работает из-за некоторых опечаток, которые можно исправить только
можно исправить, только установив другие пакеты NPM или изменив существующую конфигурацию TypeScript, что мы не хотим делать.
чего мы не хотим делать. По этой причине мы просто установим необходимые пакеты с помощью NPM.

# Добавление пакетов NPM
Откройте консоль командной строки, перейдите в корневую папку приложения WorldCities и введите следующие команды
команды:

```
> npm install @apollo/client@3.5.6
> npm install apollo-angular@2.6.0
> npm install graphql@15.8.0
```
Или, если вы хотите, просто добавьте ссылку на каждый из предыдущих пакетов в файл package.json проекта
и затем выполнить установку npm.

Как всегда, предложенные версии полностью совместимы с текущей кодовой базой книги.
Те, кто хочет изменить/обновить их, могут делать это свободно, предполагая, что они смогут
справиться с проблемами совместимости с другими пакетами/зависимостями, которые может повлечь за собой такой выбор
может повлечь за собой.

Пакет apollo/client - это основной клиент GraphQL, а apollo-angular - это просто мост, чтобы
чтобы сделать его совместимым с Angular. Аналогичные мосты доступны для React, Vue, Svelte и многих других
фреймворков. Пакет graphql - это официальная реализация JS для GraphQL.
Как только пакеты npm будут установлены, мы можем приступить к настройке клиента в нашем приложении.

# Обновление модуля AppModule
Откройте файл app.module.ts и добавьте следующие выделенные строки:

```ts
import {APOLLO_OPTIONS} from 'apollo-angular';
import {HttpLink} from 'apollo-angular/http';
import {InMemoryCache} from '@apollo/client/core';
// ...
 providers: [
{
 provide: APOLLO_OPTIONS,
 useFactory: (httpLink: HttpLink) => {
 return {
 cache: new InMemoryCache({
 addTypename: false
 }),
 link: httpLink.create({
 uri: environment.baseUrl + 'api/graphql',
 }),
 defaultOptions: {
 watchQuery: { fetchPolicy: 'no-cache' },
 query: { fetchPolicy: 'no-cache' }
 }
 };
 },
 deps: [HttpLink],
 }
 ],
```
Как мы видим, все, что нам нужно было сделать, это включить необходимые ссылки на импорт и добавить новый провайдер
с нужными нам параметрами конфигурации, такими как конечная точка GraphQL, которую мы установили в нашем приложении ASP.NET
Core.
Стоит отметить, что Apollo Angular нативно поддерживает удобную встроенную функцию in-memory cache,
которая позволяет удобно хранить временные данные. Однако, поскольку использование кэширующего хранилища
создает некоторые нетривиальные проблемы для извлекаемых данных, для простоты мы не будем использовать
его в наших примерах кода. Именно по этой причине мы явно отключили его с помощью параметра конфигурации fetchPolicy
в настройках конфигурации.

Теперь мы готовы заменить нашу существующую реализацию REST на GraphQL.

# Рефакторинг CityService
Давайте начнем с простой замены метода get(id) CityService, который мы используем для получения одного города.
Вот существующий код, основанный на REST:

```ts
get(id: number): Observable<City> {
 var url = this.getUrl("api/Cities/" + id);
 return this.http.get<City>(url);
 }
```
А вот код замены для GraphQL:

```ts
import { Observable, map } from 'rxjs';
import { Apollo, gql } from 'apollo-angular';
// ...
 constructor(
 http: HttpClient,
 private apollo: Apollo) {
 super(http);
 }
// ...
 get(id: number): Observable<City> {
 return this.apollo
 .query({
 query: gql'
 query GetCityById($id: Int!) {
 cities(where: { id: { eq: $id } }) {
 nodes {
 id
 name
 lat
 lon
 countryId
 }
 }
 }
',
 variables: {
 id
 }
 })
 .pipe(map((result: any) =>
 result.data.cities.nodes[0]));
 }
```

Вот и все. Посмотрите внимательнее на то, что мы сделали:
- Мы заменили наш HttpClient на клиент Apollo, тем самым добавив необходимые ссылки на импорт.
- Мы использовали метод query для отправки GraphQL-запроса, не сильно отличающегося от тех, которые мы
которые мы использовали для тестирования серверной реализации GraphQL в начале этой главы. На этот раз вместо
вместо того чтобы вернуть коллекцию городов, мы получим только один из них - тот, который соответствует
переменной id, которую мы используем в запросе.
- Мы сопоставили возвращаемый тип метода запроса с результирующим узлом, который содержит свойства
полученного Города.
Вот базовый GraphQL-запрос, который будет использоваться в вышеупомянутом методе для получения данного города, допустим
скажем, со значением id, равным 1:

```json
query {
 cities(where: { id: { eq: 1 } })
 {
 nodes {
 id
 name
 lat
 lon
 countryId
 }
 }
}
```
А вот соответствующий JSON-ответ сервера GraphQL:

```json
{
 "data": {
 "cities": {
 "nodes": [
 {
"id": 1,
 "name": "Tokyo",
 "lat": 35.6897,
 "lon": 139.6922,
 "countryId": 1
 }
 ]
 }
 }
}
```
Если мы хотим провести быстрый тест, мы можем запустить наши приложения WorldCities и WorldCitiesAPI и
проверить, можем ли мы по-прежнему редактировать город без проблем. Если мы все сделали правильно, мы должны увидеть
никаких проблем - все должно работать так же, как и раньше, когда у нас была REST-реализация.
Это означает, что замена метода get(id) прошла успешно.
Давайте сделаем то же самое с методом getData<ApiResult>, который создает некоторые дополнительные проблемы. Этот
возвращает ApiResult, класс POCO, который мы добавили в главе 6, "Получение и отображение данных
Данные" для поддержки таких функций, как сортировка, фильтрация и листание.
На самом деле, мы знаем, что реализация HotChocolate и Entity Framework Core, которую мы установили в начале
мы установили на ранних этапах, поддерживают эти функции; однако пейджинг HotChocolate - который следует
спецификации GraphQL Cursor Connections Specification - работает совсем по-другому, и рефакторинг нашего приложения
для соответствия этим спецификациям потребует большой работы над фронтендом, а также некоторых не самых простых
изменений в нашем пользовательском интерфейсе.

По этой самой причине, чтобы сохранить уже проделанную работу, мы подойдем к ней с другой стороны;
работать на стороне сервера, чтобы GraphQL-запрос возвращал тот же объект (и данные), который мы
который мы уже настроили на получение.

# Улучшение запроса GraphQL
Давайте вернемся к нашему проекту ASP.NET Core's WorldCitiesAPI. Откройте файл /Data/GraphQL/Query.cs
и добавим следующий метод GetCitiesApiResult, прямо под существующими:

```Csharp
/// <summary>
/// Gets all Cities (with ApiResult and DTO support).
/// </summary>
[Serial]
public async Task<ApiResult<CityDTO>> GetCitiesApiResult(
 [Service] ApplicationDbContext context,
int pageIndex = 0,
 int pageSize = 10,
 string? sortColumn = null,
 string? sortOrder = null,
 string? filterColumn = null,
 string? filterQuery = null)
{
 return await ApiResult<CityDTO>.CreateAsync(
 context.Cities.AsNoTracking()
 .Select(c => new CityDTO()
 {
 Id = c.Id,
 Name = c.Name,
 Lat = c.Lat,
 Lon = c.Lon,
 CountryId = c.Country!.Id,
 CountryName = c.Country!.Name
 }),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
}
```
Как мы видим, здесь нет ничего нового; это тот же подход, который мы использовали в нашем CitiesController
для получения параметров пагинации, фильтрации и сортировки от клиента и возврата объектов ApiResult
содержащие результирующие данные. Этот обходной путь вряд ли можно назвать лучшим подходом к GraphQL,
но это отличный способ показать, насколько универсальным он может быть, когда нам нужно соответствовать существующему сценарию.

Если бы у нас было больше времени (и страниц), мы могли бы пойти другим путем, заменив существующую пагинацию на стороне клиента (и компоненты пользовательского интерфейса) на реализацию пагинации на основе курсора GraphQL
пагинации, что позволило бы нам использовать метод GetCities в Query вместо
вновь добавленного.

Теперь, когда мы можем удобно рассчитывать на новый метод GetCitiesApiResult, нам нужно просто использовать его в нашем клиенте.

# Возвращаемся к Angular
Переключитесь обратно на приложение WorldCities Angular, откройте файл city.service.ts и замените существующий метод
GetData следующим методом:

```ts
 getData(
 pageIndex: number,
 pageSize: number,
 sortColumn: string,
 sortOrder: string,
 filterColumn: string | null,
 filterQuery: string | null
 ): Observable<ApiResult<City>> {
 return this.apollo
 .query({
 query: gql'
 query GetCitiesApiResult(
 $pageIndex: Int!,
 $pageSize: Int!,
 $sortColumn: String,
 $sortOrder: String,
 $filterColumn: String,
 $filterQuery: String) {
 citiesApiResult(
 pageIndex: $pageIndex
 pageSize: $pageSize
 sortColumn: $sortColumn
 sortOrder: $sortOrder
 filterColumn: $filterColumn
 filterQuery: $filterQuery
 ) {
 data {
 id
 name
 lat
 lon
 countryId
 countryName
 },
 pageIndex
 pageSize
 totalCount
totalPages
 sortColumn
 sortOrder
 filterColumn
 filterQuery
 }
 }
 ',
 variables: {
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery
 }
 })
 .pipe(map((result: any) =>
 result.data.citiesApiResult));
 }
```
Как мы видим, мы написали длинный, параметризованный GraphQL-запрос, используя различные значения, полученные из
пользовательского интерфейса, а затем использовали новый метод GetCitiesApiResult на стороне сервера (и отобразили его результат), чтобы
вернуть тот же Observable<ApiResult>, что и раньше.
Чтобы проверить, что мы сделали, мы можем запустить наши два проекта и перейти к списку городов. Если мы все сделали
правильно, мы не должны увидеть никаких различий.
Теперь нам осталось заменить методы put, post, getCountries и isDupeCity. Последние два
достаточно просты, теперь мы знаем, как читать данные GraphQL. Настоящая проблема
возникает с первыми двумя, поскольку они выполняют операции записи в данные на стороне сервера.

# Запрос мутации
Рефакторинг методов put и post в CityService означает, что нам наконец-то придется использовать ASP.NET
Core файл Mutation.cs, который мы реализовали некоторое время назад и до сих пор не использовали.
Прежде чем вернуться к Angular, будет полезно запустить наш проект WorldCitiesAPI и перейти
в пользовательский интерфейс Banana Cake Pop из HotChocolate, чтобы посмотреть, как выглядит наш тип Mutation.
Откройте браузер и перейдите по следующему URL-адресу:
https://localhost:40443/api/graphql/

После этого выберите Schema Reference из выпадающего списка под URL-адресом сервера, а затем нажмите на
Mutation в меню Types, расположенном справа, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/80e679db-d352-494d-bc5b-c0c02661a303)

Как мы видим, у нас есть четыре мутации, которые мы можем использовать для того, что нам нужно сделать.
Теперь, зная это, мы можем открыть файл city.service.ts и заменить существующие методы put и
post методами со следующим кодом:

```ts
put(input: City): Observable<City> {
 return this.apollo
 .mutate({
 mutation: gql'
 mutation UpdateCity($city: CityDTOInput!) {
 updateCity(cityDTO: $city) {
 id
 name
 lat
 lon
 countryId
 }
}
 ',
 variables: {
 city: input
 }
 }).pipe(map((result: any) =>
 result.data.updateCity));
}
post(item: City): Observable<City> {
 return this.apollo
 .mutate({
 mutation: gql'
 mutation AddCity($city: CityDTOInput!) {
 addCity(cityDTO: $city) {
 id
 name
 lat
 lon
 countryId
 }
 }
 ',
 variables: {
 city: item
 }
 }).pipe(map((result: any) =>
 result.data.addCity));
}
```
Вот и все. Предшествующий код должен быть довольно простым для понимания, поскольку мы просто выполняем метод GraphQL
метод, указанный в классе Mutation.cs. Единственной новой концепцией здесь является использование параметра variables
параметра, JSON-объекта, который можно использовать для отправки одной или нескольких переменных движку GraphQL. Эти
переменные можно использовать в предыдущем параметре запроса, добавив к ним символ $, как это делали мы.
как это сделали мы.

Использование переменных часто является удобным способом поместить динамические данные в GraphQL-запрос
не прибегая к методам манипулирования строками в JS или TS или другим не очень чистым
обходных путей.

Как обычно, мы можем протестировать новую реализацию, запустив наши приложения и попытавшись обновить существующий
город и/или добавить новый город. Если мы все сделали правильно, мы должны быть в состоянии сделать это без проблем.
На этом мы закончили работу с CityService.

# Рефакторинг сервиса CountryService
В этом разделе мы быстро расскажем, что нам нужно сделать для рефакторинга CountryService, чтобы использовать GraphQL вместо REST для наиболее важных методов получения и обновления данных, как мы это делали для CityService.
Из соображений экономии места мы не будем показывать все обновления исходного кода. Их можно найти в
репозитории GitHub для этой главы. Тем не менее, пытаясь выполнить обновления в CountryService без
не заглядывая в код на GitHub, может стать отличным упражнением для читателя, которому мы настоятельно рекомендуем
сделать это.
Вот список соответствующих шагов:
- Рефакторинг метода get(id), который проще всего обновить, поскольку мы можем использовать стандартный метод
Метод GetCountries() типа GraphQL Query
- Рефакторинг метода getData, который будет немного сложнее, поскольку потребует также
добавления нового метода GetCountriesApiResult в файл Country.cs приложения ASP.NET Core
(который можно найти в репозитории GitHub для ознакомления)
- Рефакторинг методов put и post, которые будут использовать существующие методы updateCountry и
addCountry методов типа Mutation
CityService может стать отличным примером для решения всех вышеперечисленных задач, поскольку базовые сущности довольно
похожи. Все сводится к замене некоторых имен классов и свойств.


# Резюме
Эта глава была полностью посвящена GraphQL, языку запросов и манипулирования данными с открытым исходным кодом.
который может стать отличной альтернативой архитектурному стилю REST для некоторых специфических сценариев, поскольку он позволяет
смягчить некоторые известные ограничения REST, такие как избыточная выборка и риск возникновения регрессионных ошибок.
После краткого обзора плюсов и минусов обоих подходов мы начали внедрять GraphQL
в нашем проекте WorldCities ASP.NET Core. Для этого мы использовали HotChocolate, комплексную стороннюю
.NET GraphQL-платформу, которая помогла нам сделать это с минимальными усилиями, в основном благодаря тому, что она
обеспечивает отличную поддержку Entity Framework Core через свой пакет расширений.
Установка и настройка HotChocolate дала нам возможность ознакомиться с несколькими
концепциями, связанными с GraphQL, такими как запросы, мутации и подписки, которые являются частью общей схемы GraphQL.
схемы. Завершив настройку, мы также воспользовались возможностью попрактиковаться с некоторыми реальными запросами
во время первых тестов на стороне сервера.
Затем мы перешли на Angular. И снова мы решили использовать сторонний пакет, чтобы взять на себя большую часть
тяжелой работы. Выбор пал на Apollo Angular, гибкий, поддерживаемый сообществом GraphQL-клиент для Angular, который можно использовать как замену нашей существующей REST-реализации с минимальными изменениями.
изменений в кодовой базе.

После установки Apollo Angular мы потратили некоторое драгоценное время на рефакторинг большинства методов получения и
обновлений нашего существующего CityService, чтобы использовать GraphQL вместо конечных точек REST. Затем мы
проверили полученные знания, выполнив те же изменения в классе CountryService.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: GraphQL, REST, GraphQL Schema,
Query, Mutation, Subscription, HotChocolate, Banana Cake Pop и Apollo Angular.























































