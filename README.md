# Технический журнал Angular

|Задача|Реализация|
|:---|:---|
|Реализация бизнес-логики|Создайте класс, и Angular создаст его объект и внедрит в компонент. Вы можете также использовать оператор new|
|Реализация компонента с пользовательским интерфейсом|Создайте класс с аннотацией @Component|
|Определение шаблона HTML для отрисовки компонентом|Укажите либо код HTML в аннотации @Component с помощью свойства template, либо имя файла HTML в templateURL|
|Манипуляции с HTML|Примените одну из структурных директив (*ngIf, *ngFor) или создайте собственный класс с аннотацией @Directive|
|Отсылка к переменной класса текущего объекта|Задействуйте ключевое слово this: this userName="Mary";|
|Настройка навигации для приложения с одной страницей|Сконфигурируйте основанный на компонентах  маршрутизатор, позволяющий соотносить компоненты  и сегменты URL, и добавьте тег \<router-outlet> к шаблону там, где вы хотите отрисовать элемент|
|Отображение значения свойства компонента пользовательского интерфейса|Разместите переменные внутри двойных фигурных скобок внутри шаблона: {{customerName}}|
|Привязка свойства компонента и пользовательского интерфейса|Используйте привязку свойств и квадратные скобки: <input [value]="greeting" >|
|Обработка событий пользовательского интерфейса|Окружите имя события круглыми скобками и укажите  обработчик: <button (click)="onClickEvent()">Get Products</button>|
|Использование двухсторонней привязки|Задействуйте нотацию [()]:<input [(ngModel)]= "myComponentProperty">|
|Передача данных компоненту|Укажите для компонентов аннотации @Input и привяжите к ним значения|
|Передача данных из компонента|Укажите для компонентов аннотации @Output  и используйте EventEmitter для отправки событий|
|Создание запроса HTTP|Внедрите объект HTTP в компонент и вызовите один из методов HTTP: this.http.get('/products')|
|Обработка ответов HTTP|Примените метод subscribe() для результата, который поступает в формате наблюдаемого потока: this.http.get('/products').subscribe(...);|
|Передача фрагмента HTML компоненту-потомку|Используйте тег <ng-content> в шаблоне потомка|
|Перехватывание изменения компонентов|Задействуйте привязки для жизненного цикла элемента|
|Развертывание|Используйте сторонние упаковщики наподобие Webpack для упаковки файлов приложений и фреймворков в пакеты JavaScript|





Вопросы:
1. Когда наступает момент нужно использовать не SPA концепцию, а роутер?



декоратор - паттерн, который позволяет добавлять функционал в класс без его изменения (надстройка)

Могут быть компоненты, которые не видны: настройки и диалоговые окна

Angular может быстро адаптировать любой html шаблон

mobirise - это page builder, если не нашли нужный шаблон

bootstrap для разметки

angular material

при добавлении файлов в assets желательно перезапустить сервер

можно подклчать bootstrap-css-only

лучше взять css framework tailwind и научиться на нем делать простой, но понятный и красивый фронтенд

Вопрос: есть конструктор, есть ngInit. Где лучше стартовать?

Перегрузку методов в TS делать нельзя

Надо изучить как работатет реактивное программирование в Angular и библиотеку RxJS

Получается, что в Angular реализован реактивный подкход через наблюдаемые объекты и подписки

RxJS надо изучить

Изучить Subject, принципы subscribe

Для создания нормального интерфейса надо изучить tailwind

Есть структурные директивы ( меняют дом) и обычные. Структурные начинаются с *.

Когда мы что-то передаем в компонент, то скобки [], когда что-то хотим получить ().

Задача: научиться верстать интерфейсы на html + css + js быстро

Angular MAterial ( есть встроенные возможности сортировки, пагинации)

Когда мы работаем с Angular, то надо помнить, что мы должны возвращать объекты Observable (для реактивного программирования, асинхронных операций)

Слой DAO - это по сути набор интерфейсов ( описание сигнатур, поведения)
Т.е сервисы -> dao -> data

Чтобы быстро обернуть возвращаемые данные в контейнер Observable - of(service.data)