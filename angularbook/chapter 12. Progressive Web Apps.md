# Progressive Web Apps

В этой главе мы сосредоточимся на теме, которую мы только что кратко упомянули в главе 2 «Подготовка».
когда мы впервые говорили о различных шаблонах разработки веб-приложений, доступных сегодня:
Прогрессивные веб-приложения (PWA).
Фактически, наши приложения HealthCheck и WorldCities в настоящее время придерживаются одностраничного
Модель приложения (SPA), по крайней мере, по большей части; в следующих разделах мы увидим, как мы можем
превратите их в PWA, реализовав несколько хорошо зарекомендовавших себя возможностей, необходимых для такого подхода к разработке.
Как мы узнали из главы 2 «Подготовка», PWA — это веб-приложение, использующее возможности современного веб-браузера.
возможности предоставлять пользователям возможности, подобные приложениям. Для достижения этой цели PWA необходимо выполнить некоторые
технические требования, включая (но не ограничиваясь этим) файл манифеста веб-приложения и работника службы для
разрешить ему работать в автономном режиме и вести себя так же, как мобильное приложение.
Точнее, вот о чем мы будем говорить:
- Отличительные особенности PWA: мы суммируем основные характеристики PWA и определяем технические требования к PWA, следуя его известным спецификациям.
- Внедрение требований PWA в наших существующих приложениях HealthCheck и WorldCities для
превратить их в PWA. Точнее, мы сделаем это двумя разными способами: вручную.
выполнение всех необходимых шагов для приложения HealthCheck, а затем использование автоматического PWA.
настройка, предлагаемая Angular CLI для приложения WorldCities
- Обработка автономного статуса: мы будем обновлять наши компоненты, чтобы они вели себя по-другому, когда
приложение находится в автономном режиме — например, ограничение его функций и/или отображение информационного статуса автономного режима.
сообщение
- Тестирование новых возможностей PWA, где мы проверим, что наша реализация будет работать правильно.
работать с обоими нашими приложениями
К концу этой главы мы узнаем, как успешно преобразовать существующий SPA в PWA.

# Технические требования
В этой главе нам понадобятся все предыдущие технические требования, перечисленные в предыдущих главах.
со следующими дополнительными пакетами:
- @angular/service-worker (пакет npm)
- служба angular-connection (пакет npm)
- Microsoft.AspNetCore.Cors (пакет NuGet)
- WebEssentials.AspNetCore.ServiceWorker (пакет NuGet, необязательно)
- http-сервер (пакет npm)
Как всегда, желательно не устанавливать их сразу; мы собираемся привезти их во время
эту главу, чтобы лучше контекстуализировать их цели в рамках нашего проекта.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/master/Chapter_12/.

# Отличительные особенности PWA
Начнем с обобщения основных отличительных характеристик PWA:
- Прогрессивный: PWA должно работать для каждого пользователя, независимо от используемой платформы и/или браузера.
- Адаптивность: они должны хорошо адаптироваться к любому форм-фактору: настольному компьютеру, мобильному телефону, планшету и т. д.
- Независимость от подключения: они должны иметь возможность работать в автономном режиме — по крайней мере, в некоторой степени, например
как информирование пользователя о том, что некоторые функции могут не работать в автономном режиме или при низком качестве.
сети.
- Похожи на приложения: они должны обеспечивать ту же механику навигации и взаимодействия, что и мобильные приложения.
Сюда входит поддержка касаний, прокрутка на основе жестов и так далее.
- Безопасность: они должны обеспечивать поддержку HTTPS для повышения безопасности, например предотвращения слежения и
обеспечение того, чтобы их содержимое не было подделано.
- Доступность для обнаружения: они должны быть идентифицированы как веб-приложения с помощью файла манифеста W3C и
область регистрации сервисного работника, чтобы поисковые системы могли находить, идентифицировать и
классифицировать их.
- Повторное вовлечение: они должны облегчать повторное вовлечение с помощью таких функций, как push-уведомления.
- Возможность установки: они должны позволять пользователям устанавливать и хранить их на своих настольных компьютерах и/или мобильных устройствах.
главный экран, как и любое стандартное мобильное приложение, но без необходимости загружать
и установите их из магазина приложений.
- Доступность ссылок: ими должно быть легко делиться через URL-адрес, не требуя сложной установки.
Эти требования высокого уровня можно перевести в конкретные технические задачи, которые нам предстоит реализовать. Лучший способ сделать это — начать с технических базовых критериев, описанных Алексом.
Рассел, инженер Google Chrome, придумавший термин PWA вместе с дизайнером Фрэнсис.
Берриман еще в 2015 году:
- Происхождение из безопасного источника. Другими словами, имеется полная поддержка HTTPS без смешанной
содержимое (зеленый дисплей с замком)
- Загружать в автономном режиме, даже если это просто автономная информационная страница. Это явно подразумевает, что мы
нужно реализовать сервисного работника
- Ссылайтесь на манифест веб-приложения, используя как минимум четыре ключевых свойства: name, short_name, stat_url,
и отображение (с автономным или полноэкранным значением)
- Значок размером 144 x 144 в формате PNG. Поддерживаются и другие размеры, но минимальным требованием является 144 x 144.
- Используйте векторную графику, поскольку она может неограниченно масштабироваться и требует меньшего размера файлов.
Каждое из этих технических требований можно перевести в конкретную техническую задачу, которую мы имеем.
реализовать. В следующих разделах мы увидим, как мы можем их реализовать.

# Безопасное происхождение
Реализация функции безопасного происхождения по сути означает обслуживание нашего приложения через сертификат HTTPS.
В настоящее время такое требование довольно легко выполнить: сертификаты TLS довольно дешевы благодаря
доступно множество реселлеров. Сертификат PositiveSSL, выданный Comodo Inc., можно приобрести онлайн за
10 долларов в год или около того, и он сразу же доступен для скачивания.
Если мы не хотим тратить деньги, Let’s Encrypt предлагает бесплатную альтернативу: бесплатный, автоматизированный, открытый центр сертификации, который можно использовать для получения сертификата TLS без каких-либо затрат. Однако,
метод, который они используют для выпуска сертификата, требует доступа к оболочке (также известного как доступ по SSH) к
веб-хост развертывания.

Для простоты мы не будем рассматривать выпуск и установку сертификата HTTPS; хорошо
примите как должное, что читатель сможет правильно установить его благодаря многочисленным практическим руководствам.
доступен на веб-сайтах различных реселлеров (включая Let’s Encrypt).

# Оффлайн загрузка
Независимость соединения — одна из наиболее важных возможностей PWA; правильно реализовать его,
нам нужно представить — и реализовать — концепцию, о которой мы до сих пор почти не упоминали: сервис
рабочие. Что это такое и как они могут помочь нашему приложению работать в автономном режиме?
Лучший способ понять, что такое сервис-воркер, — это представить его как сценарий, который выполняется внутри
веб-браузера и выполняет определенную задачу для приложения, которое его зарегистрировало: такие задачи могут включать в себя
поддержка кэширования и push-уведомлений.
При правильной реализации и регистрации сервисные работники улучшат взаимодействие с пользователем (UX).
предоставляются стандартными веб-сайтами, предоставляя UX, аналогичный тому, которого можно достичь с помощью собственных мобильных устройств.
Программы; технически их роль заключается в перехвате любого текущего HTTP-запроса, сделанного пользователем, и — всякий раз, когда
оно направлено на веб-приложение, для которого они зарегистрированы — проверьте доступность веб-приложения.
и действовать соответственно. Другими словами, мы могли бы сказать, что они действуют как HTTP-прокси с запасным вариантом.
возможности, когда приложение не может обработать запрос.
Разработчик может настроить такой резервный вариант поведения по-разному, например следующим образом:
- Служба кэширования (также известная как автономный режим): работник службы доставит кэшированный ответ, запросив внутренний (локальный) кэш, ранее созданный из приложения (когда оно было в сети).
- Предупреждение об автономном режиме: всякий раз, когда кэшированный контент недоступен (или если мы не реализовали кэширование
механизм), сервисный работник может предоставить информационный текст об автономном состоянии, предупреждая пользователя
что приложение не может работать
Те, кто знаком с сервисами прямого кэширования, возможно, предпочтут представить себе сервис-воркеров как обратный кэш.
вместо этого прокси-серверы (или границы CDN) устанавливаются в веб-браузере конечного пользователя.
Функция службы кэширования отлично подходит для веб-приложений, предоставляющих статический контент, например веб-приложений на основе HTML5.
игровые приложения и приложения Angular, которые не требуют какого-либо внутреннего взаимодействия. К сожалению, это не идеально
для наших двух приложений: HealthCheck и WorldCities в значительной степени полагаются на внутренний веб-API, предоставляемый ASP.NET. И наоборот, эти приложения определенно могут выиграть от предупреждения в автономном режиме, чтобы их
пользователи будут проинформированы о том, что требуется подключение к Интернету — вместо сообщения об ошибке подключения,
сообщение 404 — Not Found или любое другое сообщение.

# Сервисные работники против HttpInterceptors
Если мы вспомним различные функции Angular, которые мы представили в главе 11 «Аутентификация и
Авторизация, мы видим, как вышеупомянутое поведение напоминает нам о роли, выполняемой
Http-перехватчики.
Однако, поскольку перехватчики являются частью пакета сценариев приложения Angular, они всегда перестают работать, когда пользователь закрывает вкладку браузера, содержащую веб-приложение.

Более того, перехватчики могут перехватывать только вызовы, сделанные с помощью HttpClient Angular: они не будут
уметь обрабатывать запросы браузера на загрузку скриптов, таблиц стилей, изображений и т. д.
И наоборот, сервис-воркеры необходимо сохранять после того, как пользователь закроет вкладку, чтобы они могли перехватить
браузер запрашивает перед подключением к приложению.
Хватит теории, давайте теперь посмотрим, как можно реализовать автономный режим, манифест веб-приложения и
Значки PNG в наших существующих приложениях.

# Представляем @angular/service-worker
Начиная с версии 5.0.0, Angular предоставляет полнофункциональную реализацию сервис-воркера, которая может
легко интегрироваться в любое приложение без необходимости писать код для низкоуровневых API. Такая реализация обрабатывается пакетом npm @angular/service-worker и опирается на файл манифеста, который
загружается с сервера, описывающего ресурсы для кэширования, и будет использоваться в качестве индекса
сервис-воркер, который ведет себя следующим образом:
- Когда приложение подключено к сети, каждый проиндексированный ресурс будет проверен на предмет изменений; если источник
изменилось, сервисный работник обновит или пересоберет кеш
- Если приложение не в сети, вместо него будет отображаться кэшированная версия.
Вышеупомянутый файл манифеста создается на основе файла конфигурации, созданного с помощью CLI, под названием ngswconfig.json, который нам придется создать и настроить соответствующим образом.

Стоит отметить, что веб-браузеры всегда будут игнорировать сервис-воркеров, если веб-сайт
который пытается их зарегистрировать, обслуживается через незащищенное (не HTTPS) соединение. 
причину этого довольно легко понять: поскольку определяющая роль сервисных работников заключается в
проксировать исходное веб-приложение и потенциально предоставлять альтернативный контент, вредоносный
стороны могут быть заинтересованы во вмешательстве в них; поэтому разрешение на их регистрацию
защита только веб-сайтов обеспечит дополнительный уровень безопасности для всего механизма.

Вот пример файла манифеста, похожего на тот, который нам нужен (и который мы добавим через некоторое время):

```json
{
 "name": "My Sample App",
 "short_name": " MySampleApp ",
 "start_url": ".",
 "display": "standalone",
 "background_color": "#fff",
 "description": "A simply readable Hacker News app.",
 "icons": [{
 "src": "images/touch/homescreen48.png",
 "sizes": "48x48",
 "type": "image/png"
 }, {
 "src": "images/touch/homescreen72.png",
"sizes": "72x72",
 "type": "image/png"
 }, {
... multiple icon definitions ...
 }],
 "related_applications": [{
 "platform": "play",
 "url": "https://play.google.com/store/apps/details?id=my.sample.app "
 }]
}
```
Стоит отметить, что @angular/service-worker — не единственный доступный подход, который мы могли бы использовать для решения этой проблемы.
реализовать возможности PWA сервис-воркера и файла манифеста веб-приложения. На самом деле ASP.NET
Core предлагает собственный способ удовлетворения этих требований с помощью набора промежуточного программного обеспечения, которое можно легко
установлен и интегрирован в HTTP-стек нашего проекта.

# Альтернатива промежуточного программного обеспечения ASP.NET Core PWA
Среди различных предложенных решений наиболее интересным (по крайней мере, на наш взгляд) является
Пакет WebEssentials.AspNetCore.ServiceWorker NuGet, разработанный Мэдсом Кристенсеном, плодовитым автором расширений Visual Studio и библиотек ASP.NET Core; пакет предоставляет полнофункциональный
Промежуточное ПО ASP.NET Core PWA, которое поставляется с полной поддержкой манифеста веб-приложения и предварительно созданным сервисом.
Workers и является действительной внутренней и внешней альтернативой чисто интерфейсному решению, предоставляемому
@angular/service-worker пакет npm.

В целом, похоже, у нас есть два удобных способа выполнения наших задач, связанных с PWA: какой из них следует
мы выбираем?
В идеале нам бы хотелось реализовать оба из них; однако из соображений экономии места мы просто будем использовать
пакет @angular/service-worker npm, оставляя альтернативу промежуточного программного обеспечения ASP.NET Core PWA.
в другой раз.

Выбор сервис-воркера Angular также даст нам некоторые преимущества: поскольку он специально разработан для Angular, он определенно поможет нам исправить некоторые распространенные проблемы.

В следующем разделе мы узнаем, как реализовать пакет @angular/service-worker в нашем
существующие приложения Angular используют два очень разных, но одинаково полезных подхода.
Реализация требований PWA
Чтобы выполнить необходимые шаги реализации, на которых мы сосредоточились в предыдущем разделе, у нас есть
два варианта:
- Выполните обновление исходного кода нашего приложения вручную.
- Используйте функцию автоматической установки, предоставляемую Angular CLI.
Чтобы извлечь максимальную пользу из этого опыта, следует пройти оба этих пути хотя бы один раз. К счастью
достаточно, у нас есть два существующих приложения Angular для экспериментов. Поэтому мы выберем ручной маршрут
сначала для нашего приложения HealthCheck, затем мы испытаем автоматическую настройку CLI для приложения WorldCities.

# Ручная установка
В этом разделе мы увидим, как вручную реализовать необходимые технические шаги, которых нам до сих пор не хватает.
чтобы наше приложение HealthCheck полностью соответствовало требованиям PWA.
Кратко резюмируем их:
- Добавьте пакет npm @angular/service-worker (package.json).
- Включите поддержку сервис-воркера в файле конфигурации Angular CLI (angular.json).
- Импортируйте и зарегистрируйте ServiceWorkerModule в классе AppModule (app.module.ts).
- Обновите файл HTML-шаблона основного приложения (index.html).
- Добавьте подходящий файл значка (favicon.ico).
- Добавьте файл манифеста (manifest.webmanifest).
- Добавьте файл конфигурации сервисного работника (ngsw-config.json).
Для каждого шага мы указали в скобках соответствующий файл, который нам придется обновить.

# Добавление npm-пакета @angular/service-worker
Первое, что нужно сделать, — это добавить пакет npm @angular/service-worker в наш файл package.json.
Как мы можем легко догадаться, такой пакет содержит реализацию сервис-воркера Angular, которую мы
о чем мы говорили минуту назад.
Откройте файл package.json и добавьте следующую ссылку на пакет в раздел «зависимости»:
прямо под пакетом @angular/router:

```json
"@angular/router": "13.0.1",
"@angular/service-worker": "13.0.1",
```
Как только мы сохраним файл, пакет npm должен быть загружен и установлен автоматически.
Визуальная Студия; если это не так, запустите npm install вручную, чтобы принудительно обновить пакеты.

# Обновление файла angular.json
Откройте файл конфигурации angular.json и добавьте ключи «serviceWorker» и «ngswConfigPath».
до завершения проектов | ЗдоровьеПроверка | архитектор | строить | раздел опций:

```json
"scripts": [],
"serviceWorker": true,
"ngswConfigPath": "ngsw-config.json"

```

Флаг «serviceWorker», который мы только что установили, приведет к тому, что производственная сборка будет включать пару
дополнительных файлов в выходной папке:
- ngsw-worker.js: основной рабочий файл службы.
- ngsw.json: конфигурация времени выполнения сервис-воркера Angular.
Оба этих файла необходимы нашему сервисному работнику для выполнения своей работы.

# Импорт модуля ServiceWorkerModule
ServiceWorkerModule, предоставляемый библиотекой пакетов npm @angular/service-worker, позаботится
регистрации сервис-воркера, а также предоставления нескольких сервисов, которые мы можем использовать для взаимодействия с ним.
Чтобы установить его в нашем приложении HealthCheck, откройте файл /src/app/app.module.ts и добавьте следующее:
строки (новые строки выделены):

```ts
import { ServiceWorkerModule } from '@angular/service-worker';
import { environment } from '../environments/environment';
// ...
imports: [
ServiceWorkerModule.register('ngsw-worker.js', {
 enabled: environment.production,
 // Register the ServiceWorker as soon as the app is stable
 // or after 30 seconds (whichever comes first).
 registrationStrategy: 'registerWhenStable:30000'
 })
],
```
Как мы говорили ранее, файл ngsw-worker.js, упомянутый в предыдущем коде, является основным сервис-воркером.
файл, который будет автоматически создан Angular CLI при создании приложения.
При такой реализации сервисный работник будет включен только при запуске нашего приложения Angular.
в производственной среде, а это именно то, что нам нужно.

# Обновление файла index.html
Файл /src/index.html является основной точкой входа для наших приложений Angular. Он содержит <app-root>
элемент, который будет заменен графическим интерфейсом нашего приложения в конце этапа начальной загрузки, а также некоторые
ссылки на ресурсы и метатеги, описывающие поведение и настройки конфигурации нашего приложения.
Откройте этот файл и добавьте следующий код в конец элемента <head> (обновленные строки
выделено):

```html
<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <title>HealthCheck</title>
 <base href="/">
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <link rel="icon" type="image/x-icon" href="favicon.ico">
 <link rel="preconnect" href="https://fonts.gstatic.com">
 <link href="https://fonts.googleapis.com/
css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
 <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
rel="stylesheet">
 <!-- PWA required files -->
 <link rel="manifest" href="manifest.webmanifest">
 <meta name="theme-color" content="#1976d2">
</head>
<body class="mat-typography">
 <app-root></app-root>
</body>
</html>
```
Выделенные строки настраивают цвет темы приложения и, что наиболее важно, ссылку на
файл манифеста.webmanifest, который, как ясно следует из его названия, является файлом манифеста приложения, одним из
ключевые требования к любому PWA.
Приятно это слышать, но в нашем приложении его пока нет: давайте исправим этот пробел сейчас.

# Добавление файла манифеста веб-приложения
Вместо того, чтобы вручную создавать файл манифеста веб-приложения с нуля, мы можем сгенерировать его автоматически.
используя один из различных генераторов манифестов веб-приложений, доступных в Интернете.
Для целей этой книги мы будем использовать генератор манифестов веб-приложений Самсона Амауго:
https://github.com/sammychinedu2ky/Web-App-Manifest-Generator
Более конкретно, мы будем использовать экземпляр, размещенный Netlify по следующему URL-адресу: https://manifestgen.netlify.app/.
Этот удобный инструмент также сгенерирует для нас все необходимые файлы значков PNG, что сэкономит нам много времени.
Однако нам потребуется источник изображения размером 512 x 512. Если у нас его нет, мы можем легко создать его, используя
веб-сайт DummyImage, еще один полезный бесплатный инструмент, который можно использовать для создания изображений-заполнителей.
любого размера, который доступен на https://dummyimage.com/.
Вот сгенерированный PNG-файл, который мы можем использовать для подачи предыдущего генератора манифеста веб-приложения Firebase.
инструмент:

Как мы можем легко догадаться, HC означает HealthCheck; мы вряд ли выиграем конкурс графического дизайна с
это изображение, но оно вполне подойдет для нашей текущей задачи.

Значок размером 512 x 512 будет использоваться онлайн-инструментом Web App Manifest Generator для создания всех необходимых значков для нашего PWA.

Согласно рекомендациям Google, для действительного файла манифеста PWA потребуется как минимум два значка.
с соответствующим размером 192 x 192 и 512 x 512 пикселей: https://web.dev/installablemanifest/#recommendations.
Онлайн-генератор значительно превысит минимальные требования, создав восемь
разные значки для большинства основных форматов, используемых различными устройствами.

После этого вернитесь к онлайн-инструменту «Генератор манифеста веб-приложения» и настройте его, используя следующую команду:
параметры:
- Название приложения: HealthCheck.
- Краткое имя: HealthCheck.
- Цвет темы: #2196f3.
- Цвет фона: #2196f3.
- Режим отображения: автономный
- Ориентация: Любая
- Область применения: /
- Начальный URL: /

Затем нажмите справа от кнопки «ЗАГРУЗИТЬ» под опцией «Загрузить через Graphql» и выберите HC.
изображение, которое мы сгенерировали минуту назад, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1e0173ca-2b9e-464e-bc6e-fe8f83d6fa5f)

Сгенерируйте архивный файл, нажав кнопку ЗАГРУЗИТЬ, распакуйте его и скопируйте включенные файлы в
следующим образом:
- Файл манифеста.json в папке /src/.
- Папка /icons/ со всем ее содержимым находится в папке /src/assets/, так что фактический PNG
файлы будут помещены в папку /src/assets/icons/
После этого нам необходимо внести следующие изменения в файл Manifest.json:
- Измените все начальные пути значков с images/icons/ на assets/icons/.
- Переименуйте его из Manifest.json в Manifest.webmanifest, поскольку это имя определено
спецификации W3C манифеста веб-приложения
На самом деле расширения .json и .webmanifest оба будут работать; однако, поскольку большинство
веб-серверы изначально не поддерживают расширение .webmanifest, выбор .json будет
возможно, сделать вещи проще.

Тем не менее, поскольку мы хотим, чтобы наши PWA соответствовали спецификациям W3C Web App Manifest, мы собираемся
выполните вышеуказанное переименование и используйте расширение .webmanifest для наших примеров приложений. Это решение
потребует от нас выполнения некоторых дополнительных задач при развертывании наших PWA в производстве, таких как
вручную добавив это расширение (и его MIME-тип application/manifest+json) в список поддерживаемых типов файлов на нескольких веб-серверах – как мы увидим в главе 15 «Развертывание в Windows, Linux и Azure».

Теперь, когда мы внесли необходимые изменения в файл манифеста.json, нам нужно убедиться, что он будет
включен в пакет публикации Angular.

# Публикация файла манифеста веб-приложения
Чтобы наш файл /src/manifest.webmanifest был опубликован вместе с остальной частью нашего HealthCheck.
Файлы приложений Angular, нам нужно добавить их в файл конфигурации CLI /angular.json.

Откройте этот файл и найдите все следующие записи:

```json
"assets": [
 "src/favicon.ico",
 "src/assets"
],
```
Замените их следующим обновленным значением:

```json
"assets": [
 "src/favicon.ico",
 "src/assets",
 "src/manifest.webmanifest"
],
```

В файле angular.json должно быть две ключевые записи «актива»:
- projects > health_check > architect > build > options
- projects > health_check > architect > test > options
Оба из них необходимо изменить, как описано в предыдущем коде.
Благодаря этому обновлению файл манифеста.webmanifest будет публиковаться в выходной папке всякий раз, когда мы
создайте приложение Angular.

# Добавление значка
Значок избранного (также известный как значок избранного, значок ярлыка, значок веб-сайта, значок вкладки, значок URL-адреса или закладка).
значок) — файл, содержащий один или несколько небольших значков, которые можно использовать для идентификации конкретного веб-сайта; всякий раз, когда мы видим небольшой значок в адресной строке, истории и/или вкладке браузера, содержащей данный веб-сайт,
мы смотрим на значок этого сайта.
Фавиконки можно создавать вручную, но если мы не графические дизайнеры, мы можем использовать один из
различные генераторы значков, доступные в Интернете, особенно если учесть, что большинство из них полностью
бесплатное использование; единственное, что нам нужно, это подходящее изображение, которое необходимо предоставить вручную (и
загружен в сервис).

Вот несколько рекомендуемых онлайн-генераторов значков, доступных в настоящее время:
favicon.io (https://favicon.io/)
Настоящий генератор фавиконов (https://realfavicongenerator.net/)

Кроме того, мы можем загрузить один из множества бесплатных наборов значков, доступных в Интернете.

Вот несколько веб-сайтов, на которых можно загрузить бесплатные значки:
Icons8 (https://icons8.com/icons/set/favicon)
FreeFavicon (https://www.freefavicon.com/freefavicons/icons/)

Фактически, шаблон ASP.NET Core и Angular Visual Studio, который мы использовали для создания нашего
Проект HealthCheck уже предоставил нам значок: мы можем найти его в папке /wwwroot/ нашего проекта.
Честно говоря, этот фавикон не так уж и плох, как мы видим на следующем скриншоте:

Сохранение вышеуказанного значка не помешает нашему приложению стать PWA; тем не менее, если мы хотим заменить
это с помощью специального, мы можем сделать это, используя один из вышеупомянутых веб-сайтов.

# Добавление файла ngsw-config.json
В обозревателе решений создайте новый файл ngsw-config.json в корневой папке проекта HealthCheck.
и замените содержимое следующим:

```json
{
 "$schema": "./node_modules/@angular/service-worker/config/schema.json",
"index": "/index.html",
 "assetGroups": [
 {
 "name": "app",
 "installMode": "prefetch",
 "resources": {
 "files": [
 "/favicon.ico",
 "/index.html",
 "/manifest.webmanifest",
 "/*.css",
 "/*.js"
 ]
 }
 },
 {
 "name": "assets",
 "installMode": "lazy",
 "updateMode": "prefetch",
 "resources": {
 "files": [
 "/assets/**",
 "/*.(eot|svg|cur|jpg|png|webp|gif|otf|ttf|woff|woff2|ani)"
 ]
 }
 }
 ]
}
```
Как мы видим, взглянув на раздел assetsGroups > app, предыдущий файл сообщает Angular о кэшировании.
файл favicon.ico и файл манифеста.webmanifest, который мы также создали недавно
в качестве основного файла index.html и всех пакетов CSS и JS — другими словами, статического файла нашего приложения.
файлы активов. Сразу после этого идет дополнительный раздел assetsGroup > assets, который определяет
файлы изображений для кэширования.
Основное различие между этими двумя разделами заключается в значении параметра installMode, который определяет
как эти ресурсы изначально кэшируются:
- предварительная выборка сообщает сервисному работнику извлекать эти ресурсы, пока он кэширует текущую версию приложения; другими словами, он поместит все это содержимое в кеш, как только оно будет
становятся доступными, то есть при первом посещении браузером онлайн-приложения. Мы могли бы назвать это
стратегия предварительного кэширования.
- lazy сообщает сервисному работнику кэшировать эти ресурсы только тогда, когда браузеры явно запрашивают
их впервые. Это можно назвать стратегией кэширования по требованию.
Предыдущие настройки могут быть полезны для общих приложений Angular, которые полагаются только на внешний интерфейс (без внутренних вызовов), поскольку эти файлы в основном содержат все приложение; точнее, приложение Angular
хостинг HTML5-игры, которая, возможно, опирается на множество файлов изображений, может подумать о перемещении
некоторые файлы изображений (или даже все) из раздела ресурсов в раздел приложений, чтобы весь
приложение, включая значки, спрайты и все ресурсы изображений, будет кэшироваться заранее.
и быть полностью доступным, даже когда приложение находится в автономном режиме.
Однако такой стратегии кэширования будет недостаточно для наших приложений HealthCheck и WorldCities;
даже если мы скажем нашему сервисному работнику кэшировать все файлы приложения, все HTTP-вызовы наших приложений все равно будут
сбой всякий раз, когда браузер находится в автономном режиме, не сообщая пользователю ничего об этом. По сути
Фактически, наши требования к доступности серверной части вынуждают нас выполнять дополнительную работу для обоих наших приложений.
Однако прежде чем сделать это, давайте ускорим работу нашего приложения WorldCities.

Автоматическая установка
Все шаги, которые мы выполнили вручную в предыдущем разделе, чтобы включить поддержку Service Worker.
для нашего приложения HealthCheck можно выполнить автоматически с помощью следующей команды CLI:
```
> ng add @angular/pwa@13.0.1
```
Давайте применим этот альтернативный метод для нашего приложения WorldCities.
Откройте командную строку и перейдите в корневую папку приложения WorldCities, затем выполните предыдущую команду.
команда; Angular CLI автоматически настроит наше приложение, добавив пакет @angular/serviceworker и выполнив другие необходимые шаги.
Наиболее релевантная информация для всей операции будет записана в вывод консоли, как показано ниже.
на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/ab4bd9c7-4b67-4494-aef7-54e608ef0b29)

Как мы видим из журналов, автоматический процесс выполняет те же шаги, которые мы только что применили.
приложение HealthCheck.

# Набор значков Angular PNG
Функция автоматической настройки PWA также предоставит несколько значков PNG разных размеров в файле /src/assets/.
значки/папка. Если мы откроем их с помощью графического приложения, мы увидим, что все они воспроизводят
Angular логотип, как показано на следующем рисунке:

Всякий раз, когда мы хотим сделать наше приложение общедоступным, мы, вероятно, захотим изменить эти значки.
Однако их более чем достаточно, по крайней мере на данный момент; давайте оставим эти файлы такими, какие они есть, и
переходим к последней оставшейся задаче — преобразованию наших SPA в PWA.

# Обработка статуса офлайн
Теперь, когда мы настроили сервис-воркера в обоих наших приложениях, мы можем подумать о способе обработки
сообщение об автономном состоянии, чтобы каждый из наших компонентов мог вести себя по-разному.
когда приложение находится в автономном режиме — например, ограничение его функций и отображение информативного статуса автономного режима.
сообщение нашим пользователям.
Чтобы реализовать это условное поведение, нам нужно найти способ правильно определить браузер.
статус подключения, то есть онлайн или нет; в следующих разделах мы кратко рассмотрим
несколько различных подходов, которые мы можем использовать, чтобы сделать (возможно) наилучший выбор.
Эти подходы таковы:
- Событие online/onoffline окна.
- Свойство Navigator.onLine.
- Сторонний пакет, определяющий статус онлайн/оффлайн в Angular.
Мы рассмотрим каждый из них в следующих разделах.

# Вариант 1 – событие окна online/onoffline
Если мы готовы принять способ решения этой проблемы на чистом JavaScript, такую задачу можно легко решить, используя
события JavaScript window.ononline и window.onoffline, которые доступны напрямую из
любой класс Angular.

Вот как мы можем их использовать:

```js
window.addEventListener("online", function(e) {
 alert("online");
}, false);
window.addEventListener("offline", function(e) {
 alert("offline");
}, false);
```
Однако, если мы готовы принять подход, основанный на чистом JavaScript, есть еще лучший способ его реализации.

# Вариант 2 — свойство Navigator.onLine.
Поскольку мы не хотим отслеживать изменения состояния сети и просто ищем простой способ определить, находится ли браузер в сети или нет, мы можем еще упростить задачу, просто проверив
Свойство window.navigator.onLine:

```js
if (navigator.onLine) {
 alert("online");
}
else {
 alert("offline");
}
```
Как можно легко догадаться по названию, это свойство возвращает онлайн-статус браузера. Свойство возвращает логическое значение с истинным значением в режиме онлайн и ложным значением в автономном режиме и обновляется.
всякий раз, когда меняется возможность браузера подключаться к сети.
Благодаря этому свойству нашу реализацию Angular можно свести к следующему:

```ts
ngOnInit() {
 this.isOnline = navigator.onLine;
}
```
Затем мы можем использовать локальную переменную isOnline в файле шаблона нашего компонента, чтобы мы могли показать
различный контент для наших пользователей с помощью структурной директивы ngIf. Это было бы довольно легко, не так ли?
К сожалению, все не так просто; давайте попробуем понять, почему.

# Недостатки подходов JavaScript
Оба подхода на основе JavaScript, которые мы упомянули, страдают серьезным недостатком, вызванным
тем, что современные браузеры реализуют свойство navigator.onLine (а также свойство window.
события ononline и window.onoffline) по-разному.
В частности, Chrome и Safari, а также новый Microsoft Edge на базе Chromium, установят
это свойство имеет значение true всякий раз, когда браузер может подключиться к локальной сети или маршрутизатору.

Это может легко привести к ложному срабатыванию, поскольку большинство домашних и деловых связей связаны с
доступ в Интернет через локальную сеть, которая, вероятно, будет работать, даже если фактический доступ в Интернет отключен.

Учитывая все обстоятельства, это по сути означает, что мы не можем использовать описанные удобные подходы.
ранее, чтобы проверить онлайн-статус нашего браузера, поэтому, чтобы серьезно заняться этим вопросом, нам нужно
найдите лучший способ сделать это.

# Вариант 3 — пакет npm angular-connection-service
К счастью, есть изящный пакет npm, который делает именно то, что нам нужно: его имя — ng-onlinestatus, и по сути это служба мониторинга интернет-соединения, которая может определить, работает ли браузер
есть активное подключение к Интернету или нет.
Задача онлайн-обнаружения выполняется с использованием (настраиваемого) механизма контрольного сигнала, который периодически отправляет HTTP-запросы на (настраиваемый) URL-адрес для определения состояния подключения к Интернету.
К сожалению, последняя версия ng-connection-service, в которой появилась функция пульса,
недоступно в npm на момент написания: последняя обновленная версия — 1.0.4, которая была разработана
для Angular 6 несколько лет назад и все еще основывался на window.ononline и window.onoffline.
события, о которых мы говорили ранее.
На момент написания я не знаю, почему автор до сих пор не обновил пакет npm; однако, поскольку
он сделал исходный код последней версии доступным на GitHub под лицензией MIT, многие разработчики
разветвил свою оригинальную работу, обновил ее для более новых версий Angular и опубликовал полученные пакеты.
в npm под той же лицензией. Именно по этой причине мы собираемся использовать одну из этих вилок, которая
называется службой углового подключения.

Вот значения пакета по умолчанию:
- enableHeartbeat: true
- heartbeatUrl: //httpstat.us/200
- heartbeatInterval: 3000 (milliseconds)
- heartbeatRetryInterval: 1000
- requestMethod: head

Большинство из них хороши, за исключением heartbeatUrl — по разным причинам, которые мы объясним позже.

Излишне говорить, что поскольку это сервис Angular, мы сможем настроить его централизованно и
затем внедрить его всякий раз, когда нам нужно, без необходимости каждый раз настраивать его вручную: это почти
кажется слишком хорошим, чтобы быть правдой!
Давайте посмотрим, как мы можем это реализовать.

# Установка сервиса
Для этого откройте файл package.json проекта HealthCheck и добавьте следующую строку справа:
под пакетом @angular/service-worker, который мы добавили минуту назад:

```json
"@angular/service-worker": "13.0.1",
"angular-connection-service": "13.0.1",
```
Обязательно используйте версию, совместимую с версией Angular, которую мы сейчас используем.

После этого откройте командную строку и выполните npm install, чтобы обновить пакеты: сразу после этого
мы можем реализовать эту услугу в наших приложениях.

# Обновление файла AppModule
Первое, что нужно сделать, это добавить модуль пакета в наш файл AppModule. Для этого откройте файл app.module.ts проекта HealthCheck и добавьте следующие выделенные строки:

```ts
import { environment } from '../environments/environment';
import { ConnectionServiceModule, ConnectionServiceOptions,
ConnectionServiceOptionsToken } from 'angular-connection-service';
@NgModule({
// ...
 imports: [
ConnectionServiceModule
 ],
 providers: [
 {
 provide: ConnectionServiceOptionsToken,
 useValue: <ConnectionServiceOptions>{
 heartbeatUrl: environment.baseUrl + 'api/heartbeat',
 }
 }
 ],
```
Как мы видим, мы воспользовались возможностью изменить значение heartbeatUrl; вместо запроса значения по умолчанию
httpstat.us сторонний веб-сайт, мы проверим выделенную конечную точку API/Heartbeat, которую мы
сделать доступными в рамках нашего проекта веб-API. Мы выбрали этот выбор по нескольким веским причинам:
наиболее важными из них являются следующие:
- Чтобы не мешать сторонним хостам.
- Чтобы получить более релевантный результат, поскольку нам нужно знать, может ли наше приложение достичь наших конкретных Домен веб-API
- Чтобы избежать проблем совместного использования ресурсов между источниками (CORS) в отношении сторонних ресурсов (подробнее
об этом позже)
Прежде чем переключиться на ASP.NET Core и создать конечную точку API/конечной точки, давайте закончим Angular.
часть работы.
# Обновление AppComponent
Весь смысл того, что мы сейчас делаем, заключается в том, чтобы наши пользователи знали, что приложение находится в автономном режиме с помощью
информационное сообщение об автономном статусе. Для эффективности должно отображаться это сообщение:
- Как можно скорее, чтобы наши пользователи знали статус подключения приложения перед навигацией.
где-то
- Везде, чтобы их предупреждали об этом, даже если они посещают какие-то внутренние просмотры.
Поэтому хорошим местом для его реализации будет класс AppComponent, который содержит все наши
компоненты, независимо от внешнего маршрута, выбранного пользователем.

# app.comComponent.ts
Начнем с файла TypeScript.
Откройте файл /src/app/app.comComponent.ts и соответствующим образом измените его файл класса (обновленные строки
выделены):

```ts
import { Component } from '@angular/core';
import { ConnectionService } from 'angular-connection-service';
@Component({
 selector: 'app-root',
 templateUrl: './app.component.html',
 styleUrls: ['./app.component.scss']
})
export class AppComponent {
 title = 'HealthCheck';
 hasNetworkConnection: boolean = true;
 hasInternetAccess: boolean = true;
 constructor(private connectionService: ConnectionService) {
 this.connectionService.monitor().subscribe((currentState: any) => {
 this.hasNetworkConnection = currentState.hasNetworkConnection;
 this.hasInternetAccess = currentState.hasInternetAccess;
 });
 }
 public isOnline() {
 return this.hasNetworkConnection && this.hasInternetAccess;
 }
}
```

На этом этапе приведенный выше код должен быть довольно прост для понимания: мы установили несколько локальных переменных.
и подписался на ConnectionService, созданный в конструкторе компонента с использованием DI, чтобы
периодически обновляйте их. И последнее, но не менее важное: мы добавили метод isOnline(), который можно использовать для
определить онлайн-статус приложения.

# app.comComponent.html
Теперь, когда у нас есть метод isOnline(), мы можем изменить файл шаблона AppComponent, чтобы отобразить
информативное сообщение «офлайн-статус» нашим пользователям всякий раз, когда оно возвращает false.
Откройте файл /src/app/app.comComponent.html и обновите его содержимое, выделив следующее:
линии:

```html
<app-nav-menu></app-nav-menu>
<div class="alert alert-warning" *ngIf="!this.isOnline()">
 <strong>WARNING</strong>: the app is currently <i>offline</i>:
 some features that rely upon the back-end might not work as
expected. This message will automatically disappear as soon
 as the internet connection becomes available again.
</div>
<div class="container">
 <router-outlet></router-outlet>
</div>
```

Вот и все: поскольку домашний вид нашего приложения напрямую не требует внутреннего HTTP-запроса, мы решили
просто покажите предупреждающее сообщение, чтобы сообщить пользователю, что некоторые функции нашего приложения могут не работать, пока
не в сети. И наоборот, мы могли бы полностью закрыть приложение, добавив дополнительный ngIf="!this.
isOnline()» другим элементам, чтобы сообщение о состоянии автономного режима было
только видимый вывод.

# app.component.scss
Теперь нам просто нужно стилизовать наше новое оповещение об автономном статусе.
Откройте файл /src/app/app.comComponent.scss и добавьте следующие строки к существующему содержимому:

```scss
.alert {
 position: relative;
 padding: .75rem 1.25rem;
 margin-bottom: 1rem;
 border: 1px solid transparent;
 border-radius: .25rem;
 &.alert-warning {
 color: #856404;
 background-color: #fff3cd;
 border-color: #ffeeba;
 }
}
```

Вот и все: на этом мы закончили с нашими задачами Angular.
Прежде чем перейти на ASP.NET Core, давайте быстро проверим то, что мы уже сделали: нажмите F5, чтобы запустить
проект в режиме отладки и нажмите CTRL + SHIFT + J, чтобы открыть окно консоли.
Если мы все сделали правильно, AppComponent должен подписаться на новый сервис, который должен
попал в HTTP 404 при попытке проверить конечную точку API/Heartbeat, которая еще не существует.

В результате метод isOnline() должен вернуть false, что приведет к появлению предупреждения, как в примере
следующий скриншот:

![image](https://github.com/artemovsergey/Angular/assets/26972859/e287995e-b4e0-4dab-b96f-2375ad78d26d)

Теперь нам нужно убедиться, что конечная точка API/Heartbeat будет найдена: для этого нам нужно переключиться
в проект HealthCheckAPI и также выполнить там некоторые обновления.
Однако прежде чем перейти к проекту веб-API ASP.NET Core, давайте воспользуемся возможностью применить все
Angular также вносит изменения в проект WorldCities. Репозиторий проекта GitHub для этой главы.
содержит все необходимые обновления для обоих проектов и является хорошим справочником для тех, кому нужна помощь.

# Добавление конечной точки API/Heartbeat
Чтобы создать новую конечную точку API в нашем приложении ASP.NET Core, у нас может возникнуть соблазн добавить новый контроллер:
точно так же, как мы делали во всех предыдущих главах: или, может быть, мы можем создать новый метод действия в существующем
контроллер?
На самом деле оба варианта будут работать нормально, однако проект HealthCheckAPI не
у вас еще нет контроллера, и создание нового только для обработки запроса HEAD Heartbeat может быть излишним. Что касается проекта WorldCitiesAPI, существующие контроллеры предназначены для определенной цели:
какое отношение метод действия Heartbeat имеет к контроллерам, возвращающим данные о городах и странах?
Если бы контроллеры были единственным способом решения такой задачи, нам определенно пришлось бы создать новый контроллер в обоих наших проектах веб-API. Однако мы можем воспользоваться этим шансом и представить альтернативу.
метод обработки HTTP-запросов, который мы до сих пор никогда не использовали; этот метод называется Минимальный
API, и он был представлен в ASP.NET Core 6.

# Представляем минимальные API
Объяснить минимальные API в нескольких словах — задача непростая, однако для простоты давайте попробуем
чтобы кратко суммировать концепции этой новой функции ASP.NET Core.
В двух словах, минимальные API — это набор вспомогательных методов, позволяющих разработчикам обрабатывать HTTP.
запросы с минимальными зависимостями, файлами и исходным кодом.

Этот новый подход можно использовать как вместе со стандартными контроллерами, так и полностью их заменить.
в зависимости от заданного сценария: в идеале они лучше всего подходят для микросервисов и облегченных API,
или для обработки очень простых запросов — например, конечной точки API/Heartbeat, которую нам нужно добавить.
Без лишних слов, давайте откроем файл Program.cs и реализуем наш самый первый минимальный API, верно
ниже существующего метода app.MapControllers():

```Csharp
app.MapControllers();
app.MapMethods("/api/heartbeat", new[] { "HEAD" }, () => Results.Ok());
```
Как мы видим, новый добавленный метод довольно минималистичный, но очень читабельный: мы обрабатываем
входящие HTTP-запросы, указывающие на конечную точку API/Heartbeat (только запросы HEAD), возвращающие
стандартный HTTP-ответ 200 – OK без содержания. Это намного быстрее, чем создание специального
контроллер, да?
Что касается пустого содержимого, мы сделали это просто потому, что оно нам не нужно: содержимое запроса HEAD
совершенно не имеет значения, службе angular-connection просто нужно проверить код состояния нашего ответа
чтобы определить онлайн-статус нашего приложения.
Чтобы проверить то, что мы только что сделали, мы можем снова запустить наш проект HealthCheck: на этот раз предупреждение не должно быть
больше не виден, а это означает, что наша новая конечная точка API/Heartbeat может быть доступна с помощью приложения Angular.
и заставляя метод isOnline() AppComponent возвращать true.
Теперь нам просто нужно выполнить те же задачи в нашем проекте WorldCitiesAPI, после чего мы можем перейти к
следующий шаг.

# Совместное использование ресурсов между источниками (CORS)
Теперь, когда мы добавили конечную точку api/heartbeat в наш проект веб-API ASP.NET, давайте потратим немного времени.
ценное время на понимание концепции совместного использования ресурсов перекрестных запросов, более известной как CORS.
Как мы говорили ранее, последняя версия angular-connection-service позволяет нам выполнять HEAD
запрос в течение определенного периода времени («пульс»), чтобы определить, находимся ли мы в сети или нет. Однако мы решили изменить сторонний веб-сайт, который был установлен в значениях службы по умолчанию (//
httpstat.us/200) к выделенной конечной точке веб-API, находящейся под нашим контролем (api/heartbeat), которую мы
просто добавлено для этой конкретной цели.
Почему мы это сделали? Что плохого в периодической выдаче запроса HEAD стороннему лицу
Веб-сайт?
Первую причину довольно просто понять: мы не хотим мешать этим веб-сайтам, поскольку
они определенно не предназначены для того, чтобы мы могли проверять их онлайн-статус.

Если их системные администраторы увидят наши запросы в своем журнале, они могут забанить нас или принять некоторые контрмеры, которые могут помешать работе нашей проверки пульса или, что еще хуже, поставить под угрозу ее работу.
Статус надежности.
Другая причина заключается в том, что надежность стороннего сайта, такого как httpstat.us, может сильно отличаться от надежности нашего веб-API: что, если такой веб-сайт доступен, пока производственная среда нашего
Проекта WorldCitiesAPI нет? Совершенно очевидно, что нам следует проверять сердцебиение, а не что-то другое.
сайт один.
Однако есть еще одна важная причина избегать такой практики.
Разрешение нашему приложению отправлять HTTP-запросы на внешние веб-сайты может нарушить политику CORS по умолчанию.
настройки этих веб-сайтов; пока мы здесь, было бы полезно потратить немного времени, чтобы лучше понять
эта концепция.
Как мы, возможно, уже знаем, современные браузеры имеют встроенные настройки безопасности, которые не позволяют веб-странице
от выполнения запросов JavaScript к домену, отличному от того, который обслуживает веб-страницу: например
Ограничение называется политикой одного и того же происхождения и вводится для предотвращения вредоносного стороннего веб-сайта.
от чтения данных с другого сайта.
Однако большинство веб-сайтов могут захотеть (или должны) отправлять некоторые внешние запросы другим веб-сайтам: например,
Например, HeartbeatUrl по умолчанию, настроенный в angular-connection-service, сообщил бы нашему
приложение для отправки запроса HEAD на внешний веб-сайт //httpstat.us для проверки его онлайн-статуса.
Эти требования, которые довольно распространены в большинстве приложений, называются CORS: чтобы их реализовать,
браузер ожидает получить от принимающего сервера — того, на котором размещены необходимые ресурсы, —
подходящая политика CORS, которая позволит им пройти. Если эта политика не появится или не будет включать
запрашивающий источник — HTTP-запрос будет заблокирован. Поскольку этот механизм, основанный на сердцебиении, теперь
важная часть нашего приложения, мы не можем рисковать быть заблокированными сторонними ограничениями CORS:
поэтому мы заменили эту неприятную внешнюю ссылку более безопасным URL-адресом, указывающим на
внутренний ресурс под нашим контролем.

На момент написания все конечные точки httpstat.us были настроены так, чтобы разрешить все источники,
заголовки и методы HTTP, что не создает проблем с CORS: однако у нас нет никаких гарантий.
что такой подход «без ограничений» сохранится и в будущем.

Тем не менее, поскольку наш веб-API играет роль внешнего сервера, мы все равно можем захотеть настроить
такая политика, позволяющая нашему приложению вызывать конечную точку API/Heartbeat, а также любую другую
конечная точка – даже нелокального происхождения. Это не требуется сейчас, когда мы тестируем наше приложение в нашей
localhost, но это определенно может произойти, когда мы публикуем наш проект в рабочей среде.

Хватит теории: давайте посмотрим, как можно реализовать CORS в нашем проекте HealthCheckAPI и
разрешить всем своим конечным точкам, включая, помимо прочего, API/Heartbeat, вызываться из
внешние серверы.

# Внедрение CORS
Настройка CORS в ASP.NET Core требует добавления служб CORS и промежуточного программного обеспечения CORS, часть
пространства имен Microsoft.AspNetCore.Cors в файл Program.cs.
Однако прежде чем сделать это, нам необходимо предоставить нашему приложению параметр конфигурации, который мы можем использовать.
чтобы указать источник, который мы хотим разрешить: подходящим местом для этого является файл appsettings.json.

# Добавление параметра конфигурации AllowedCORS
Откройте файл appsettings.json HealthCheckAPI и добавьте новый ключ AllowedCORS прямо под
Ключ AllowedHosts, как показано ниже:

```json
"AllowedHosts": "*",
"AllowedCORS": "*"
```
Подстановочное значение «*» ослабит политику CORS для любой конечной точки, что может быть полезно для нашего тестирования.
целях: мы ограничим такое разрешительное поведение в главе 15 «Развертывание Windows, Linux и Azure»,
когда мы развернем наши приложения в производстве.

Сразу после сохранения файла appsettings.json HealthCheckAPI откройте настройки appsettings WorldCitiesAPI.
json и добавьте туда ключ AllowedCORS, прежде чем двигаться дальше.
Теперь, когда у нас есть доступный параметр конфигурации AllowedCORS, мы можем обновить наш файл Program.cs.

# Обновление файла Program.cs
Откройте файл Program.cs HealthCheckAPI и добавьте необходимые выделенные строки кода:

```Csharp
using Microsoft.AspNetCore.Cors;
// ...
builder.Services.AddSwaggerGen();
builder.Services.AddCors(options =>
 options.AddPolicy(name: "AngularPolicy",
 cfg => {
 cfg.AllowAnyHeader();
 cfg.AllowAnyMethod();
 cfg.WithOrigins(builder.Configuration["AllowedCORS"]);
 }));
// ...
app.UseAuthorization();
app.UseCors("AngularPolicy");
```
Приведенный выше код не должен быть слишком сложным для понимания:
- Мы добавили службы CORS (AddCors) и настроили политику CORS, которая – при применении
– ослабляет CORS для любого HTTP-заголовка и метода для конечных точек AllowedCORS, указанных в
файл appsettings.json.
- Ниже мы добавили промежуточное программное обеспечение CORS (UseCors) чуть ниже UseAuthorization().
метод: очень важно поместить его перед промежуточным программным обеспечением, которое обрабатывает различные конечные точки.
(Контроллеры, HealthChecks, минимальные API и т. д.), чтобы была применена наша политика CORS.
всем им.
Благодаря этому мы успешно реализовали все необходимые функции PWA. Опять же, обязательно также подайте заявку
приведенные выше настройки CORS в проект WorldCitiesAPI, прежде чем двигаться дальше.
Давайте теперь найдем способ правильно протестировать то, что мы сделали; сделать это из Visual будет непросто.
Studio из-за особенностей PWA, но есть несколько обходных путей, которые мы можем использовать, чтобы добиться этого.

# Тестирование возможностей PWA
В этом разделе мы попытаемся протестировать регистрацию сервис-воркера для нашего приложения HealthCheck. К сожалению,
сделать это из среды разработки Visual Studio — довольно сложная задача по нескольким причинам:
включая следующее:
- ngserve — команда Angular CLI, которая предварительно устанавливает пакеты и запускает приложение в любое время.
мы запускаем наше приложение в режиме отладки, оно не поддерживает сервис-воркеров
- Задачи регистрации сервис-воркера, которые мы недавно поместили в класс AppModule, регистрируют его только тогда, когда приложение работает в производственной среде.

Необходимые статические файлы, созданные Angular CLI с использованием конфигурации angular.json.
файл, который мы изменили ранее, будет доступен только в производственных средах
Однако мы можем легко обойти эти ограничения, скомпилировав наше приложение Angular для производства.
а затем запустить сгенерированные файлы на отдельном выделенном HTTP-сервере.
В следующих разделах мы увидим, как все это можно сделать.

# Компиляция приложения
Вот как мы можем опубликовать наше приложение с помощью Angular CLI. Откройте командную строку, перейдите к
корневую папку проекта и введите следующую команду:

```
ng build
```

CLI скомпилирует наше приложение Angular в новую папку /dist/, которая будет содержать все сгенерированные файлы.
файлы. Стоит отметить, что мы собираемся использовать эту папку (и все ее содержимое) для тестирования нашего сервис-воркера.
только потом удалив его.

В качестве альтернативы мы могли бы также исключить его из контроля версий, добавив путь к папке.
в файл .gitignore — именно это мы и сделали в репозитории GitHub для этой книги.

Теперь нам просто нужно установить отдельный HTTP-сервер, который сможет поддерживать нашего сервис-воркера. С этой целью,
мы собираемся использовать пакет npm http-server: простой статический пакет командной строки с нулевой конфигурацией.
HTTP-сервер, который также рекомендуется официальной документацией Angular для сервисных работников.
Важно понимать, что http-сервис не предназначен для использования в производственных целях: однако
его общая простота делает его идеальным для тестирования, локальной разработки и обучения.

# Установка http-сервера
http-сервер можно установить с помощью npm или запустить напрямую с помощью npx — инструмента, поставляемого в комплекте.
Node.js, который можно использовать для выполнения двоичных файлов пакетов npm без их установки.
Если мы хотим глобально установить его перед запуском, мы можем сделать это с помощью следующих команд:

```
 npm install http-server -g
 http-server -p 8080 -c-1 dist/HealthCheck/
```

Если мы просто хотим протестировать нашего сервис-воркера, вместо этого мы можем использовать следующую команду:

```
npx http-server -p 8080 -c-1 dist/HealthCheck/
```
Обе команды запустят http-сервер и передадут наше приложение HealthCheck на локальный TCP-порт 8080.
как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/45f9b3f1-4aa4-472a-8b06-eee053910790)

Как только мы это сделаем, мы сможем подключиться к нему, открыв браузер и введя следующий URL-адрес в поле
адресная строка: http://localhost:8080.
Мы можем проверить возможности PWA наших приложений так же, как мы это делали с Visual Studio и IIS Express.
ранее; однако мы не сможем протестировать внутренние HTTP-запросы, поскольку http-сервер изначально не поддерживает
поддержка ASP.NET Core. К счастью, для запуска этих тестов нам не нужна серверная часть.
Тестирование наших PWA
Для простоты следующие снимки экрана будут связаны с HealthCheck, но они одинаковы.
проверки можно применить и к приложению WorldCities, поскольку мы настроили его, используя те же шаблоны реализации.

Настоятельно рекомендуется выполнить следующие тесты в браузере на базе Chromium:
например, Google Chrome или Microsoft Edge, поскольку такие движки поставляются с некоторыми удобными встроенными инструментами для проверки наличия манифеста веб-приложения и сервис-воркера. Кроме того, это сильно
рекомендуется использовать режим инкогнито браузера, чтобы гарантировать, что работник службы всегда будет
начать с нуля, не читая ранее созданные кеши или состояния.

Давайте начнем наш тест с остановки всех наших проектов и закрытия всех окон, чтобы убедиться, что у нас нет ошибок.
запущенные или активные процессы. Сразу после этого запустите http-сервер – как описано в предыдущем
раздел – и откройте браузер по следующему URL-адресу: http://localhost:8080.
Если мы все сделали правильно, мы должны увидеть главную страницу приложения с видимым желтым оповещением об автономном режиме.
на экране. Причина этого довольно проста: наш веб-API не запущен (пока), поэтому Angular
приложение не может достичь конечной точки API/Heartbeat.

Мы можем легко проверить это поведение, нажав Shift + Ctrl + J, чтобы открыть инструменты разработчика Chrome.
а затем просмотрите вкладку «Консоль», как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/f504cfa0-0475-439a-bb67-972c246e2b0b)

Теперь мы можем нажать F5, чтобы запустить наши проекты HealthCheck и HealthCheckAPI.
Автономное предупреждающее сообщение исчезнет через несколько секунд: после этого мы можем приступить к следующему тесту.
Оставив окно инструментов разработчика Chrome открытым, перейдите на вкладку «Приложение», где мы увидим
что наш файл манифеста веб-приложения был правильно загружен. Если мы прокрутим вниз Приложение | Манифест
панели мы также сможем увидеть наши значки PNG.

ПРИМЕЧАНИЕ. Прежде чем
service worker фактически появляется при первой установке.

Следующее, что мы можем проверить, это Приложение | Панель Service Workers, которая должна сильно напоминать показанную на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/ea99556b-2b34-4f94-a4b1-541591382ba0)

Файл JavaScript сервис-воркера должен быть четко виден, а также дата его регистрации и текущий
статус работоспособности.
Давайте теперь попробуем отключить наш веб-браузер. Для этого установите флажок «Не в сети» в левом верхнем углу.
раздел вкладки «Приложения» инструментов разработчика Chrome и посмотрите, что произойдет:

![image](https://github.com/artemovsergey/Angular/assets/26972859/0c85ea6d-8ce3-483e-a469-51f17583b6f7)

Наше автономное информационное сообщение с предупреждением должно немедленно сработать благодаря нашей реализации angular-connectedservice. Если мы перейдем на вкладку «Сеть», мы увидим, что конечная точка API/Heartbeat
больше недоступен, а это означает, что метод isOnline() AppComponent теперь возвращает false.
Теперь мы можем возобновить подключение (сняв флажок «Не в сети») и проверить еще два
вещи: подключаемые и устанавливаемые возможности PWA. Оба они четко показаны в крайнем правом углу.
часть адресной строки браузера, как мы видим на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/d99d36c6-da6b-43ff-95da-5e6c5c6ce6b0)

Если мы перейдем туда с помощью указателя мыши, мы сможем увидеть контекстные сообщения, предлагающие нам
отправьте URL-адрес приложения на другие устройства (слева) и установите его на рабочий стол (справа).

# Установка PWA
Давайте теперь нажмем кнопку установки (та, со знаком плюс, вписанным в кружок) и подтвердим, что мы
хотите локально установить HealthCheck PWA.
Через несколько секунд мы сможем увидеть домашний вид нашего недавно установленного приложения в окне, похожем на настольное приложение, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/66bc118c-2e21-4f55-82ac-716ead8e74b6)

Оттуда выполните следующие действия:
1. Нажмите Shift + Ctrl + J, чтобы снова открыть инструменты разработчика Google Chrome.
2. Перейдите к Приложению | Панель «Служебные работники»
3. Установите флажок «Не в сети», чтобы снова установить/активировать его.
Приложение должно снова отобразить автономное предупреждающее информационное сообщение.
Излишне говорить, что мы не сможем увидеть таблицу результатов проверки работоспособности, пока наше приложение находится в автономном режиме, поскольку
эти данные извлекаются в режиме реального времени, и в настоящее время у нас нет механизма автономного кэширования, который мог бы их сохранить.
в локальном хранилище и сделать его доступным, когда подключение к Интернету недоступно; однако оффлайн
предупреждающего информационного сообщения достаточно, чтобы наши пользователи знали о том, что приложение находится в автономном режиме.
Вот и все: мы успешно превратили наши SPA в PWA. На самом деле мы только что поцарапали
поверхность многих возможностей, предлагаемых таким многообещающим подходом к развертыванию; однако,
мы успешно продемонстрировали, что наши интерфейсные и серверные платформы полностью способны обрабатывать
правильно и последовательно выполнять свои основные требования.

# Краткое содержание
Вся эта глава была посвящена PWA: мы потратили некоторое драгоценное время, чтобы лучше понять высокоуровневые
Отличительные особенности этого современного шаблона веб-разработки и способы их воплощения в технических спецификациях. Сразу после этого мы приступили к их реализации, учитывая различные
доступные варианты, предлагаемые нашими интерфейсными и серверными платформами.

Поскольку концепция PWA тесно связана с интерфейсными аспектами нашего приложения, мы решили использовать Angular способ реализации необходимых возможностей; Имея это в виду, мы решили взять руководство
сначала выберите наше приложение HealthCheck, а затем опробуйте функцию автоматической установки.
с помощью Angular CLI для приложения WorldCities. В обоих сценариях мы хорошо использовали @angular/
пакет service-worker npm, модуль, доступный начиная с Angular 5, который предоставляет полнофункциональный сервис.
рабочая реализация, которую можно легко интегрировать в наши приложения.
После этого нам потребовалось некоторое время, чтобы понять, как можно справиться с автономным статусом нашего приложения.
оценка различных стратегий и, в конечном итоге, выбор решения на основе пульса с использованием пакета npm angularconnection-service и выделенной конечной точки веб-API. Решая эти задачи,
мы воспользовались возможностью изучить и реализовать некоторые удобные функции ASP.NET Core, такие как Minimal
API и совместное использование ресурсов между источниками.
После этого мы вручную запустили несколько тестов согласованности, чтобы проверить новые возможности PWA.
наших приложений с помощью Google Chrome и его инструментов разработчика.
В конце этой главы мы наконец увидели нашего сервис-воркера в действии, а также манифест веб-приложения.
файл, способный обслуживать значки PNG и обеспечивать функции установки и связывания с нашими приложениями.
Различные концепции, которые мы изучили в этой главе, также помогли нам сосредоточиться на некоторых очень важных моментах.
важные вопросы, касающиеся различий между средами разработки и производства, следовательно,
подготавливая нас к тому, чтобы должным образом подготовиться к заключительной части нашего пути: развертыванию Windows, Linux и Azure,
которые станут основными темами главы 15 «Развертывание Windows, Linux и Azure». Однако прежде
мы дошли до этого момента, но есть еще несколько тем, которые нам нужно затронуть в следующих двух главах.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: прогрессивные веб-приложения (PWA), @angular/service-worker, безопасное происхождение, HTTPS, TLS, Let’s Encrypt, сервисные работники, HTTPInterceptors,
значки, файл манифеста веб-приложения, Microsoft.AspNetCore.Cors, совместное использование ресурсов между источниками (CORS),
автономный статус, window.navigator, ng-connection-service, IIS Express и http-сервер.


















