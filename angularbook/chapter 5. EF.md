# EF

Пример приложения HealthCheck, с которым мы работаем начиная с главы 2 «Подготовка», работает нормально.
однако в нем отсутствуют некоторые важные функции, которые мы, вероятно, использовали бы в типичном веб-приложении; среди
наиболее важным из них является возможность чтения и записи данных из системы управления базами данных.
(СУБД), поскольку это важное требование практически для любой веб-задачи: управление контентом,
обмен знаниями, мгновенная связь, хранение и/или добыча данных, отслеживание и статистика, пользовательские
аутентификация, журналирование системы и т. д.
По правде говоря, даже наше приложение HealthCheck определенно может использовать некоторые из этих задач: отслеживание хоста
статусы с течением времени могут быть хорошей функцией; аутентификация пользователя должна быть обязательной, особенно если
мы планируем опубликовать его в Интернете; ведение журнала системы всегда полезно; и так далее. Однако,
поскольку мы предпочитаем делать наши проекты максимально простыми, мы собираемся создать новый и предоставить
некоторые возможности СУБД.
Вот что мы собираемся сделать в этой главе:
- Создайте совершенно новый проект веб-приложения .NET и Angular под названием WorldCities: базу данных.
городов со всего мира
- Выберите подходящий источник данных, чтобы получить разумный объем реальных данных для экспериментов.
- Определить и реализовать модель данных с помощью Entity Framework Core.
- Настройте и разверните механизм СУБД, который будет использоваться в нашем проекте.
- Создайте базу данных с помощью функции миграции данных Entity Framework Core.
- Внедрить стратегию заполнения данных для загрузки источника данных в базу данных.
- Чтение и запись данных с помощью .NET с использованием методов объектно-реляционного сопоставления (ORM), предоставляемых Entity Framework Core.
Вы готовы начать?

# Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущей главе.
главы, а также следующие внешние библиотеки:

- Пакет NuGet Microsoft.EntityFrameworkCore.
- Пакет NuGet Microsoft.EntityFrameworkCore.Tools.
- Пакет NuGet Microsoft.EntityFrameworkCore.SqlServer.
- SQL Server 2019 (если мы выбираем маршрут локального экземпляра SQL)
- Подписка MS Azure (если мы выбираем вариант размещения облачной базы данных)

Как всегда, желательно не устанавливать их сразу. Мы собираемся привезти их во время
в этой главе, чтобы мы могли контекстуализировать их назначение в нашем проекте.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/master/Chapter_05/.

# Веб-приложение WorldCities
Первое, что мы собираемся сделать, это создать два новых проекта, используя два шаблона Visual Studio, которые
мы использовали в главе 2 «Подготовка»:
- Автономный шаблон TypeScript Angular для нового проекта Angular.
- Шаблон веб-API ASP.NET Core для нового веб-API.
Короче говоря, нам просто нужно повторить то, что мы делали во второй части главы 2 «Подготовка».
где мы создали проекты HealthCheck и HealthCheckAPI: с той лишь разницей, что на этот раз
мы дадим им другое имя: WorldCities для автономного проекта TypeScript Angular,
и WorldCitiesAPI для основного веб-API ASP.NET.
Создание этих двух проектов с нуля станет отличным упражнением и хорошей возможностью применить их на практике.
то, что вы узнали до сих пор. Посмотрим, сможете ли вы сделать это без посторонней помощи!

После того, как мы создали два проекта, первое, что нам нужно сделать, это убедиться, что Visual Studio будет
запустите их оба, используя функцию «Несколько запускаемых проектов», как мы это делали в главе 2 «Подготовка».
Для этого щелкните правой кнопкой мыши узел решения и выберите параметр «Задать запускаемые проекты» в контекстном меню.
меню и действуйте соответственно.
Сразу после этого нам нужно будет применить к нашим новым проектам те же обновления и улучшения, которые мы
сделал это в проектах HealthCheck и HealthCheckAPI в главе 2 «Подготовка».

# Обновление приложения ASP.NET Core
Начнем с приложения ASP.NET Core, которое требует лишь некоторых незначительных изменений. Вот что нам нужно
делать:
- В файле launchSettings.json измените порты HTTP и HTTPS на 40080 и 40443.
Вот и все.

# Обновление приложения Angular
Перейдем к приложению Angular. Вот что нам нужно сделать:
- Обновите (или понизьте версию) версии Angular в файле package.json.
- Отредактируйте файл /src/proxy.conf.json, чтобы обновить контекст прокси Angular из /weatherforecast.
в /api, а также изменив порт HTTPS на 40443, чтобы он соответствовал приложению ASP.NET Core.
- Добавьте HomeComponent и NavMenuComponent с помощью команды nggenerate Angular CLI.
- Удалите функции получения данных прогноза погоды из AppComponent, чтобы он
содержать элементы app-nav-menu и router-outlet
- Добавьте AppRoutingModule, чтобы отделить стратегии маршрутизации от AppModule.
- Добавьте свойство baseUrl в файлы /src/environments/environment.ts и Environment.prod.ts, используя значения «/» и «https://localhost:40443/» соответственно.

Замечание: Как мы видим, мы не упомянули FetchDataComponent: мы не будем использовать его в нашем новом
WorldCities Angular, поэтому мы можем избежать его создания, а также ссылок на него в
NavMenuComponent и AppRoutingModule.

Пока мы там, мы можем продолжать упражнение, применяя улучшения пользовательского интерфейса, которые мы реализовали в разделе «Рестайлинг пользовательского интерфейса» главы 4 «Взаимодействия с внешним и внутренним интерфейсом»:
- Установите угловой материал
- Добавьте MatToolbar в NavMenuComponent.
- Замените CSS на Sass.

Поначалу необходимость повторять все эти шаги может показаться неприятной, но это хороший способ убедиться в том, что
мы поняли каждый соответствующий шаг. Однако, если вы не хотите практиковаться, вы также можете скопировать и
вставьте обновленный код из приложения HealthCheck Angular… или напрямую извлеките обновленный исходный код.
из репозитория GitHub этой главы.

После внесения всех этих изменений мы можем проверить, что все работает, нажав F5 и проверив
исход. Если все сделано правильно, мы должны увидеть следующий экран:

![image](https://github.com/artemovsergey/Angular/assets/26972859/e352440c-7342-41e0-8616-5e5c67305fce)

Поскольку мы не хотим читать то «Привет, незнакомец!» фразу до конца этой книги, давайте потратим 2 минуты нашего времени, чтобы кратко обновить домашнюю страницу нашего нового приложения.

# Минимальный рестайлинг пользовательского интерфейса
Откройте веб-браузер и перейдите на www.pexels.com, удобный веб-сайт, предлагающий бесплатные стоковые фотографии и
видео, которыми поделились талантливые авторы со всего мира. Введите карту мира в строку поиска и выберите
подходящее изображение обложки, возможно, с альбомными пропорциями.
Вот хороший снимок, взятый с https://www.pexels.com/photo/close-up-of-globe-335393/:

![image](https://github.com/artemovsergey/Angular/assets/26972859/132f6545-75fe-4960-abd0-c637b7e32cf6)

Загрузите фотографию в минимально возможном разрешении (640x426) и сохраните ее в нашем приложении WorldCities, используя следующий путь и имя:

```/src/assets/img/home.jpg```

Для этого нам придется создать папку /img/, потому что ее еще нет.
Теперь, когда у нас есть собственное изображение обложки дома, давайте обновим вид дома, чтобы оно отображалось правильно;
откройте файл /src/app/home/home.comComponent.html и измените его содержимое следующим образом:

```html
<h1>WorldCities</h1>
<p>
 A sample web application to demonstrate
 how to interact with ASP.NET, Angular,
 Entity Framework Core and a SQL Database.
</p>
<img src="/assets/img/home.jpg" alt="WorldCities"
 class="home-cover" />
```
Как видно из предыдущего кода, мы планируем показать наше новое изображение с помощью элемента <img>, который
также имеет атрибут class: это означает, что теперь нам нужно реализовать этот CSS-класс домашней обложки.
используя один из подходов к компонентам стиля, поддерживаемых Angular.
Как мы знаем из опыта предыдущих глав, мы могли бы сделать это, либо добавив
свойство стилей в метаданные компонента, обновив файл /src/app/home/home.comComponent.ts
Файл TypeScript…

```ts
@Component({
 selector: 'app-home',
 templateUrl: './home.component.html',
 styles: ['.home-cover { display:block; margin:auto; max-width:100%; }']
})
```

или мы могли бы использовать отдельный файл SCSS и реализовать там класс. Мы также знаем, что это последнее
подход почти всегда предпочтительнее, поскольку он позволит нам отделить структуру HTML от CSS.
стилизацию, не испортив код компонента, поэтому мы сделаем это именно так.

В обозревателе решений откройте файл /src/app/home/home.comComponent.scss, который должен быть пустым.
к настоящему моменту — и заполните его содержимое следующим кодом:

```css
.home-cover {
 display:block;
 margin: auto;
 max-width:100%;
}
```
Обязательно убедитесь, что файл home.comComponent.scss правильно указан в свойстве styleUrls.
в файле /src/app/home/home.comComponent.ts компонента следующим образом:

```scss
@Component({
 selector: 'app-home',
 templateUrl: './home.component.html',
 styleUrls: ['./home.component.scss']
})
```

Теперь, когда мы обновили файл SCSS, давайте посмотрим на правила таблицы стилей, которые мы поместили в класс homecover: как мы видим, мы применили некоторые минимальные стили CSS, чтобы центрировать изображение и сделать его
автоматически изменяет размер, чтобы его базовая ширина (640 пикселей) не была помехой для мобильных телефонов.
Давайте теперь нажмем F5 и посмотрим, как выглядит наш новый домашний вид:

![image](https://github.com/artemovsergey/Angular/assets/26972859/8a758288-5144-4c1b-87e6-e77c12adcdca)

Мы никогда не получим награду за этот макет, но для наших целей это нормально.
Если мы уменьшим ширину браузера до минимальной величины (или воспользуемся функцией эмуляции мобильных устройств MS Edge
открыв Инструменты разработчика и затем нажав Ctrl + Shift + M), мы также можем увидеть, как это будет выглядеть
на мобильных устройствах:

![image](https://github.com/artemovsergey/Angular/assets/26972859/2a86fb0d-2f72-4db0-b099-feda7abf4e7a)

Не так уж и плохо, не так ли?
Вот и все: теперь у нас есть совершенно новое веб-приложение .NET и Angular, с которым можно поиграть. Нам просто нужно
источник данных и модель данных, к которым можно получить доступ через внутренний веб-API для получения некоторых данных
от: другими словами, сервер данных.

# Причины использовать сервер данных
Прежде чем мы двинемся дальше, было бы разумно потратить пару минут на ответ на следующий вопрос:
действительно ли нам нужен настоящий сервер данных? Разве мы не можем как-то подражать одному из них? Мы запускаем только код
образцы, в конце концов.

На самом деле, мы определенно могли бы избежать этого и пропустить всю эту главу: Angular предоставляет
аккуратный пакет веб-API в памяти, который заменяет HttpBackend модуля HttpClient и эмулирует
CRUD-операции через RESTful API; эмуляция осуществляется путем перехвата Angular HTTP
запросы и перенаправление их в хранилище данных в памяти, находящееся под нашим контролем.
Этот пакет великолепен и отлично работает для большинства сценариев тестирования, таких как следующие:
- Для моделирования операций с наборами данных, которые не были реализованы в нашей разработке/
тестовый сервер
- Для написания приложений модульного тестирования, которые читают и записывают данные без необходимости перехватывать несколько HTTP-вызовов.
и создавать последовательности ответов
- Для выполнения сквозных тестов без вмешательства в реальную базу данных, что отлично подходит для сборок непрерывной интеграции (CI).
Служба веб-API в памяти работает настолько хорошо, что вся документация Angular доступна по адресу https://.
angular.io/ полагается на него. Однако мы пока не будем его использовать, по простой (и довольно очевидной) причине.
Причина: в этой книге основное внимание уделяется не Angular, а взаимодействию клиент/сервер между Angular и
.NET; именно по этой причине разработка настоящего веб-API и подключение его к реальному источнику данных через
реальная модель данных является частью игры.
Мы не хотим моделировать поведение серверной части RESTful, потому что нам нужно понять, что
что там происходит и как это правильно реализовать: мы хотим реализовать это вместе с СУБД, которая
проведет хостинг и предоставит данные.
Именно по этой причине мы в первую очередь создали проект WorldCitiesAPI, и мы обязательно планируем
использовать его: именно это мы и собираемся сделать, начиная со следующего раздела.

Замечание: Тем, кто хочет получить дополнительную информацию о веб-API Angular в памяти.
сервис может посетить страницу проекта GitHub in-memory-web-api по адресу https://github.com/.
angular/in-memory-web-api/.

# Источник данных
Какие данные потребуются нашему веб-приложению WorldCities? Мы уже знаем ответ: база данных
городов со всего мира. Существует ли такой репозиторий?
На самом деле, есть несколько альтернатив, которые мы можем использовать для заполнения нашей базы данных, а затем создания
он доступен нашим конечным пользователям.
Ниже приводится бесплатная база данных городов мира, созданная DSpace-CRIS:
- URL-адрес: https://dspace-cris.4science.it/handle/123456789/31.
- Формат: CSV.
- Лицензия: бесплатное использование.
Ниже представлена база данных городов мира GeoDataSource (бесплатная версия):
- URL-адрес: http://www.geodatasource.com/world-cities-database/free.
- Формат: CSV.
- Лицензия: бесплатная для использования (требуется регистрация).
Ниже представлена база данных городов мира от simplemaps:
- URL-адрес: https://simplemaps.com/data/world-cities.
- Формат: CSV, XLSX.
- Лицензия: бесплатная для использования (CC BY 4.0, https://creativecommons.org/licenses/by/4.0/).
Все эти альтернативы достаточно хороши, чтобы удовлетворить наши потребности: мы выберем simplemaps.com, поскольку он
не требует регистрации и предоставляет удобочитаемый формат электронных таблиц.
Откройте свой любимый браузер, введите или скопируйте указанный выше URL-адрес и найдите столбец «Основные» на странице
Раздел базы данных городов мира:

Нажмите кнопку «Загрузить», чтобы получить (огромный) ZIP-файл, содержащий файлы .csv и .xlsx, а также
сохрани его где-нибудь. На данный момент это все; мы разберемся с этими файлами позже.
Начиная со следующего раздела, мы начнем процесс построения нашей модели данных: это будет долгий,
но и очень полезное путешествие.

# Модель данных
Теперь, когда у нас есть источник необработанных данных, нам нужно найти способ сделать его доступным для нашего веб-приложения.
чтобы наши пользователи могли получать (и, возможно, изменять) фактические данные.
Для простоты мы не будем тратить драгоценное время, представляя всю модель данных.
понятие, а также различные значения этих двух слов. Те из вас, кто имеет опыт, как
а также опытные разработчики, вероятно, будут в курсе всех соответствующих вещей. Мы просто скажем это, когда
мы говорим о модели данных, мы не имеем в виду ничего больше или меньше, чем облегченную модель,
определенно типизированный набор классов сущностей, представляющих постоянные, управляемые кодом структуры данных, которые мы можем
использовать в качестве ресурсов в коде нашего веб-API.
Слово «стойкий» использовалось не просто так; мы хотим, чтобы наша структура данных хранилась в базе данных.
Это довольно очевидно для любого приложения, основанного на данных. Совершенно новое веб-приложение, о котором мы говорим
create не будет исключением, поскольку мы хотим, чтобы он действовал как коллекция (или хранилище) записей, поэтому
которые мы можем читать, создавать, удалять и/или изменять в соответствии с нашими потребностями.
Как мы можем легко догадаться, все эти задачи будут выполняться некоторой внутренней бизнес-логикой (.NET).
контроллеры), который запускается интерфейсным пользовательским интерфейсом (компоненты Angular).

# Представляем ядро Entity Framework
Мы создадим нашу базу данных с помощью Entity Framework Core (также известного как EF Core),
известный объектно-реляционный преобразователь объектов (ORM) с открытым исходным кодом для ADO.NET, разработанный Microsoft.
Причины такого выбора следующие:
• Бесшовная интеграция с Visual Studio IDE.
• Концептуальная модель, основанная на классах сущностей (Модель данных сущностей (EDM)), которая позволит нам
работать с данными с использованием предметно-ориентированных объектов без необходимости писать код доступа к данным,
это именно то, что мы ищем
• Простота развертывания, использования и обслуживания на этапах разработки и производства.
• Совместимость со всеми основными движками SQL с открытым исходным кодом и коммерческими, включая MSSQL.
SQLite, Azure Cosmos DB, PostgreSQL, MySQL/MariaDB, MyCAT, Firebird, Db2/Informix,
Oracle DB и многое другое благодаря официальным и/или сторонним поставщикам и/или соединителям.
доступен через NuGet

Стоит отметить, что Entity Framework Core ранее был известен как Entity Framework 7 до его последней версии RC. Изменение имени соответствует ASP.NET 5/ASP.NET Core.
переключатель перспективы, о котором мы уже говорили, поскольку он также подчеркивает Entity Framework
Основные изменения/переработка ядра, если сравнивать его с предыдущими частями.

Вам может быть интересно, почему мы выбираем подход, основанный на SQL, вместо того, чтобы использовать
Альтернатива NoSQL; существует много хороших продуктов NoSQL, таких как MongoDB, RavenDB и CouchDB,
у которого есть библиотека соединителей C#. А как насчет использования одного из них?
Ответ довольно прост: несмотря на то, что они доступны в качестве сторонних поставщиков, они не включены в официальный список поставщиков основных баз данных Entity Framework (см. ссылку в следующем разделе).
информационное окно). Именно по этой причине мы будем придерживаться реляционной базы данных, которая также может
будет более удобным подходом для простых схем баз данных, которые мы собираемся разработать в этой книге.

# Установка ядра Entity Framework
Чтобы установить Entity Framework Core, нам нужно добавить соответствующие пакеты в раздел зависимостей.
нашего файла проекта. Мы можем легко сделать это с помощью визуального графического интерфейса следующим образом:
- Щелкните правой кнопкой мыши проект WorldCitiesAPI.
- Выберите «Управление пакетами NuGet».
- Убедитесь, что в раскрывающемся списке «Источник пакета» установлено значение «Все».
- Перейдите на вкладку «Обзор» и найдите пакеты, содержащие Microsoft.EntityFrameworkCore.
ключевое слово:

![image](https://github.com/artemovsergey/Angular/assets/26972859/775c8ba8-7c03-4a0c-b9af-40442829c6a0)

Оказавшись там, выберите и установите следующие пакеты (последние на момент написания):
- Microsoft.EntityFrameworkCore версии 6.0.0.
- Microsoft.EntityFrameworkCore.Tools версии 6.0.0.
- Microsoft.EntityFrameworkCore.SqlServer версии 6.0.0.
Эти пакеты также содержат некоторые необходимые зависимости, которые нам также необходимо установить.
требуют принятия условий лицензии:

![image](https://github.com/artemovsergey/Angular/assets/26972859/30f0ae00-ce3e-4600-a245-cd151269dd5e)

Если мы предпочитаем делать это с помощью командной строки диспетчера пакетов NuGet, мы можем ввести следующее:
PM> Install-Package Microsoft.EntityFrameworkCore -Version 6.0.0
PM> Install-Package Microsoft.EntityFrameworkCore.Tools -Version 6.0.0
PM> Install-Package Microsoft.EntityFrameworkCore.SqlServer -Version 6.0.0
Стоит отметить, что номер версии, который является самым последним на момент написания,
может быть изменено: обязательно проверьте его трижды в репозитории этой книги на GitHub!

# Поставщик данных SQL Server
Среди указанных имен пространства стоит отметить наличие Microsoft.EntityFrameworkCore.
SqlServer, поставщик базы данных Microsoft SQL для Entity Framework Core. Это весьма
Универсальный соединительный интерфейс обеспечивает всю домашнюю базу данных Microsoft SQL Server, включая последнюю версию SQL Server 2019.

# Модели лицензирования СУБД
Несмотря на довольно дорогую (если не сказать больше) модель лицензирования, существует как минимум три Microsoft.
Редакции SQL, которые можно использовать бесплатно при соблюдении определенных требований:

- Ознакомительная версия бесплатна, но не имеет прав на производственное использование. Это означает, что мы можем только
используйте его на серверах разработки. Кроме того, его можно использовать только в течение 180 дней. После этого мы
придется либо купить лицензию, либо удалить ее (и перейти на другую редакцию).
- Версия для разработчиков также бесплатна и не требует прав на производственное использование. Однако его можно использовать
без ограничений, при условии, что мы используем его только для сценариев разработки и/или тестирования.
- Экспресс-версия бесплатна и может использоваться в любой среде. Это означает, что мы можем использовать ее на
серверы разработки и производства. Однако он имеет некоторые серьезные ограничения по производительности и размеру, которые могут снизить производительность сложного веб-приложения с высоким трафиком.

Как мы легко видим, и версия Developer, и версия Express могут быть очень полезны для небольших веб-приложений, подобных тем, с которыми мы работаем в этой книге.

# А как насчет Линукса?
SQL Server 2019 также доступен для Linux и официально поддерживается для следующих дистрибутивов:
- Red Hat Enterprise Linux (RHEL)
- Корпоративный сервер SUSE
- Убунту

Помимо этого, его также можно настроить для работы в Docker и даже подготовить как виртуальную машину в Azure.
что часто может быть отличной альтернативой, если мы не хотим устанавливать локальный экземпляр DMBS и сохранять наши
драгоценные аппаратные ресурсы.
Что касается модели лицензирования, все продукты SQL Server лицензируются одинаково для всех этих сред: по сути это означает, что мы можем использовать нашу лицензию (включая бесплатные) на платформе.
нашего выбора.

# Альтернативы SQL-серверу
Если вам не хочется использовать Microsoft SQL Server, вы на 100% свободны выбрать другой движок СУБД, например
как MySQL, PostgreSQL или любой другой продукт, если он имеет какое-то ядро Entity Framework Core.
официальная (или сторонняя) поддержка.
Должны ли мы принять это решение сейчас? Это полностью зависит от подхода к моделированию данных, который мы хотим использовать.
усыновить; на данный момент и для простоты мы будем придерживаться Microsoft SQL Server.
семейство, которое позволяет нам бесплатно установить достойную СУБД на любую нашу локальную машину (разработка
и/или производство) или Azure (благодаря стоимости 200 евро и 12-месячной бесплатной пробной версии): не беспокойтесь об этом.
на данный момент — мы доберемся до этого позже.

# Подходы к моделированию данных
Теперь, когда у нас установлен Entity Framework Core, и мы более или менее знаем, какую СУБД мы используем.
Собираясь использовать, нам придется выбирать между одним из двух доступных подходов к моделированию структуры данных: «Сначала код» или «Сначала база данных». У каждого из них есть немало преимуществ и недостатков.
конечно знаю. Хотя мы не будем вдаваться в подробности, было бы полезно кратко подвести итог.
каждый, прежде чем сделать выбор.

# Код-сначала
Это флагманский подход Entity Framework, начиная с версии 4, а также рекомендуемый: элегантный и высокоэффективный рабочий процесс разработки модели данных. Привлекательность этого подхода может быть легко
найден в его помещении; подход Code-First позволяет разработчикам определять объекты модели, используя только
стандартные классы, без необходимости использования каких-либо инструментов проектирования, файлов сопоставления XML или громоздких кип
автоматически сгенерированный код.
Подводя итог, можно сказать, что подход Code-First означает написание классов сущностей модели данных, которые мы будем использовать.
в нашем проекте и позволяем Entity Framework соответствующим образом генерировать базу данных:

![image](https://github.com/artemovsergey/Angular/assets/26972859/37a422b5-debf-4d48-8242-1158673d8059)

Плюсы и минусы описаны в следующих разделах.
Плюсы
- Нет необходимости в диаграммах и визуальных инструментах, что может быть полезно для проектов малого и среднего размера, поскольку сэкономит много времени.
- Он имеет свободный API-интерфейс, который позволяет разработчику следовать соглашению о настройке.
подход, позволяющий обрабатывать наиболее распространенные сценарии, одновременно давая им возможность
переключиться на пользовательскую реализацию на основе атрибутов, которая отменяет необходимость настройки
отображение базы данных

Минусы
- Требуется хорошее знание C# и обновленных соглашений EF.
- Поддержание базы данных часто может быть затруднительным, а также обработка обновлений без каких-либо проблем.
потери данных. Поддержка миграции, которая была добавлена в версии 4.3 для решения этой проблемы и была
с тех пор постоянно обновляется, что значительно смягчает проблему, хотя это также влияет на
кривая обучения в отрицательную сторону.

# База данных – прежде всего
Если у нас уже есть существующая база данных или мы не против создать ее заранее, мы могли бы рассмотреть возможность
альтернативный подход, который идет наоборот: вместо того, чтобы позволить EF Core автоматически создавать
базу данных с помощью команд SQL, сгенерированных из объектов модели, мы генерируем эти объекты
из существующей базы данных с помощью инструмента командной строки dotnet ef. Этот метод генерации кода
называется модельным каркасом и основан на следующей команде:

```
dotnet ef dbcontext scaffold
```
Мы можем резюмировать это, сказав, что подход «База данных прежде всего» будет означать создание базы данных и предоставление
Entity Framework создает/обновляет остальные соответственно:

![image](https://github.com/artemovsergey/Angular/assets/26972859/efabd2bc-d609-475e-92b5-9ea279aaa569)

Плюсы и минусы описаны в следующих разделах.
Плюсы
• Если у нас уже есть существующая база данных, вероятно, это будет правильным решением.
избавь нас от необходимости воссоздавать его
• Риск потери данных будет сведен к минимуму, поскольку любые структурные изменения или базы данных
обновление модели всегда будет выполняться в самой базе данных
Минусы
• Обновление базы данных вручную может оказаться затруднительным, если мы имеем дело с кластерами, несколькими экземплярами,
или несколько сред разработки/тестирования/производства, так как нам придется вручную сохранять
их синхронизировать вместо того, чтобы полагаться на обновления/миграции на основе кода или автоматически генерируемые сценарии SQL.
• У нас будет меньше контроля над автоматически генерируемыми классами моделей, поэтому управлять ассоциациями, внешними ключами и ограничениями будет сложнее.

# Делая выбор
Если принять во внимание преимущества и недостатки этих двух вариантов, такого понятия не существует.
как общий лучший или лучший подход; и наоборот, мы можем сказать, что каждый сценарий проекта, скорее всего, будет иметь
наиболее подходящий подход. Тем не менее, учитывая, что Code-First является рекомендуемым подходом для Entity
Framework Core, особенно для новых приложений и/или в тех случаях, когда база данных еще не существует, мы
практически не сомневаемся, что его принятие будет нашим лучшим выбором.

По правде говоря, в последние годы подход «База данных прежде всего» становится все менее и менее популярным.
и поддержка этой техники в фреймворке тоже упала: собственно говоря, такой
в настоящее время этот подход используется редко, если только нет уже существующей структуры базы данных.
которые нелегко обновить или которые необходимо сохранить в том виде, в каком они есть, потому что другие
приложения и/или службы уже имеют к нему доступ.

Теперь, когда мы сделали свой выбор, нам нужно создать несколько сущностей и найти подходящую СУБД для хранения.
наши данные: именно это мы собираемся сделать в следующих разделах.

# Создание сущностей
Теперь, когда у нас есть источник данных, мы можем использовать одно из основных преимуществ подхода Code-First.
мы говорили ранее, и начинаем писать наши классы сущностей как можно раньше, не слишком беспокоясь о
какой механизм базы данных мы в конечном итоге будем использовать.

По правде говоря, мы уже кое-что знаем о том, что в конечном итоге будем использовать. Мы не будем
принятие решения NoSQL, поскольку оно официально не поддерживается Entity Framework Core
еще; мы также не хотим брать на себя обязательства по покупке дорогих планов лицензий, поэтому
коммерческие версии Oracle и SQL Server, вероятно, также не учитываются.
Это оставляет нам относительно небольшой выбор: версия SQL Server Developer (или Express),
MySQL/MariaDB, общественная версия Oracle (известная как Oracle XE) или другая менее
известные решения, такие как PostgreSQL. Более того, мы до сих пор не уверены на 100% в
установка локального экземпляра СУБД на нашу машину разработки (и/или на нашу производственную машину).
сервер) или полагаться на облачное решение, такое как Azure.
При этом принятие Code-First даст нам возможность отложить разговор до тех пор, пока мы
Модель данных готова.

Однако для создания классов сущностей нам необходимо знать, какие данные они будут содержать, и
как его структурировать: это сильно зависит от источника данных и таблиц базы данных, которые мы в конечном итоге
хотите создать с помощью Code-First.
В следующих разделах мы узнаем, как можно справиться с этими задачами.

# Определение сущностей

В Entity Framework Core, как и в большинстве фреймворков ORM, сущность — это класс, который сопоставляется с заданным
таблица базы данных. Основная цель сущностей — дать нам возможность работать с данными в объектно-ориентированном виде.
стиль, используя строго типизированные свойства для доступа к столбцам таблицы (и связям данных) для каждого
ряд. Мы собираемся использовать сущности для извлечения данных из базы данных и сериализации их в JSON для внешнего интерфейса. Мы также сделаем обратное, то есть десериализуем их обратно всякий раз, когда интерфейс выдает POST.
или запросы PUT, которые потребуют от серверной части внесения некоторых постоянных изменений в базу данных,
например добавление новых строк или обновление существующих.
Если мы попытаемся расширить наше внимание и посмотреть на общую картину, мы сможем увидеть, как сущности
играют центральную роль во всем двунаправленном потоке данных между СУБД, серверной частью и сервером.
интерфейсные части нашего веб-приложения.

Чтобы понять эту концепцию, давайте взглянем на следующую диаграмму:

![image](https://github.com/artemovsergey/Angular/assets/26972859/3fa48346-2bfa-400f-a33b-5f3c9dd5c3ea)

Как мы ясно видим, основная цель Entity Framework Core — сопоставить таблицы базы данных с
классы сущностей: это именно то, что нам нужно сделать сейчас.
Разархивируйте сжатый файл городов мира, который мы скачали некоторое время назад, и откройте worldcities.xlsx.
файл: если у вас нет MS Excel, вы можете импортировать его на Google Диск с помощью Google Таблиц, как показано на рисунке.
следующий URL-адрес: http://bit.ly/worldcities-xlsx.

Сразу после импорта я также воспользовался возможностью внести небольшие улучшения в читабельность этого файла: выделить имена столбцов жирным шрифтом, изменить размер столбцов, изменить фон.
цвет и заморозка на первом ряду и так далее.

Если мы откроем предыдущий URL-адрес, мы увидим, как выглядит импортированная электронная таблица:

![image](https://github.com/artemovsergey/Angular/assets/26972859/930b5c7a-203f-4a04-b205-53c65f9c8794)

Глядя на заголовки электронной таблицы, мы можем сделать вывод, что нам понадобятся как минимум две таблицы базы данных:
- Города: для столбцов A, B, C и D (и, возможно, K, если мы хотим сохранить эти уникальные идентификаторы).
- Страны: для столбцов E, F и G.
Кажется, это самый удобный выбор с точки зрения здравого смысла. В качестве альтернативы мы могли бы поставить
все в одну таблицу Cities, но у нас будет много избыточного контента, а это
то, чего мы, возможно, хотели бы избежать.
Если мы собираемся иметь дело с двумя таблицами базы данных, это означает, что нам нужны две сущности для их сопоставления.
и создать их в первую очередь, поскольку мы планируем принять подход Code-First.

# Сущность города
Начнем с сущности City.
В обозревателе решений проекта выполните следующие действия:
1. Создайте новую папку /Data/ на корневом уровне проекта WorldCitiesAPI; это будет где
все наши классы, связанные с Entity Framework, будут постоянно находиться.
2. Создайте папку /Data/Models/.
3. Добавьте новый ASP.NET | Код | Файл класса, назовите его City.cs и замените пример кода на
следующий:

```Csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
namespace WorldCitiesAPI.Data.Models
{
public class City
 {
 #region Properties
 /// <summary>
 /// The unique id and primary key for this City
 /// </summary>
 [Key]
 [Required]
 public int Id { get; set; }
 /// <summary>
 /// City name (in UTF8 format)
 /// </summary>
 public string Name { get; set; } = null!;
 /// <summary>
 /// City latitude
 /// </summary>
 [Column(TypeName = "decimal(7,4)")]
 public decimal Lat { get; set; }
 /// <summary>
 /// City longitude
 /// </summary>
 [Column(TypeName = "decimal(7,4)")]
 public decimal Lon { get; set; }
 /// <summary>
 /// Country Id (foreign key)
 /// </summary>
 public int CountryId { get; set; }
 #endregion
 }
}
```

Как мы видим, мы добавили отдельное свойство для каждого столбца таблицы, который мы определили ранее.
на; мы также включили свойство CountryId, которое собираемся использовать для сопоставления внешнего ключа для
Страна, связанная с городом (подробнее об этом позже). Мы также постарались улучшить общую читабельность
исходный код класса сущности, снабдив каждое свойство некоторыми полезными комментариями, которые обязательно
помогите нам вспомнить, для чего они предназначены.

И последнее, но не менее важное: стоит отметить, что мы воспользовались возможностью украсить наш класс сущности, используя некоторые
Атрибуты аннотаций к данным, поскольку они являются наиболее удобным способом переопределить стандартные значения Code-First.
конвенции. Более конкретно, мы использовали следующие аннотации:
- [Обязательный]: определяет свойство как обязательное (не допускающее NULL) поле.
- [Ключ]: это означает, что свойство содержит первичный ключ таблицы базы данных.
- [Column(TypeName="decimal(7,4)"]: это означает, что для свойства потребуется столбец БД
указанного типа и точности. Если мы не предоставим эту информацию, Entity Framework не будет
знать, какую точность установить для столбцов таблицы базы данных, которые она создаст для этих свойств
и вернется к значениям по умолчанию. Этот запасной вариант может привести к потере точности, если
фактические данные имеют большее количество десятичных знаков.
Дополнительные атрибуты аннотаций к данным будут добавлены позже.
Те из вас, у кого есть некоторый опыт работы с Entity Framework (и реляционными базами данных), больше всего
вероятно, поймут, для чего нужны эти аннотации к данным: это удобный способ проинструктировать
Entity Framework о том, как правильно построить нашу базу данных при использовании подхода Code-First. Есть
здесь нет ничего сложного; мы просто сообщаем Entity Framework, что столбцы базы данных, созданные для размещения этих свойств, должны быть установлены по мере необходимости и что первичный ключ должен быть привязан к
отношение один-ко-многим к другим внешним столбцам в разных таблицах.
Чтобы использовать аннотации к данным, нам нужно добавить ссылку на одно или оба следующих пространства имен, в зависимости от атрибутов, которые мы собираемся использовать:
System.ComponentModel.DataAnnotations
System.ComponentModel.DataAnnotations.Schema
Если мы посмотрим на предыдущий код, то увидим, что для удобства на оба этих пространства имен ссылаются с помощью оператора using, даже если атрибуты, которые мы использовали до сих пор ([Key] и
[Обязательно]) требуется только первый.

# Объект «Страна»
Следующим объектом будет определение стран, которые будут иметь отношения один-ко-многим с городами.

Это неудивительно: мы определенно ожидаем, что для каждого города будет своя страна.
и несколько городов для каждой данной страны: для этого нужны отношения «один ко многим».

Щелкните правой кнопкой мыши папку /Data/Models/, добавьте файл класса Country.cs и заполните его следующим кодом:

```Csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
namespace WorldCitiesAPI.Data.Models
{
 public class Country
 {
 #region Properties
 /// <summary>
 /// The unique id and primary key for this Country
 /// </summary>
 [Key]
 [Required]
 public int Id { get; set; }
 /// <summary>
 /// Country name (in UTF8 format)
 /// </summary>
 public string Name { get; set; } = null!;
 /// <summary>
 /// Country code (in ISO 3166-1 ALPHA-2 format)
 /// </summary>
 public string ISO2 { get; set; } = null!;
 /// <summary>
 /// Country code (in ISO 3166-1 ALPHA-3 format)
 /// </summary>
 public string ISO3 { get; set; } = null!;
 #endregion
 }
}
```
Опять же, для каждого столбца электронной таблицы есть свойство с соответствующими аннотациями к данным и комментариями.

# Должны ли мы (все еще) использовать блоки #region?
Если мы посмотрим на примеры кода двух только что добавленных классов сущностей, мы увидим, что мы использовали
некоторые директивы #region: давайте поговорим о них минутку.
Как уже известно большинству разработчиков C#, регионы — это директивы препроцессора, которые позволяют разработчику указывать
блок кода, который можно развернуть или свернуть при использовании функции структурирования редактора кода.

Регионы были представлены в первых версиях C# и получили высокую оценку на заре развития языка.
лет, потому что они рассматривались как жизнеспособный метод улучшения читаемости кода, особенно в длительных и длительных
сложные занятия. Однако они также могут побудить разработчика принять ряд плохих практик,
например, размещение «неоптимизированного» или повторяющегося кода, чтобы скрыть его от просмотра вместо его рефакторинга; разделение сложного метода (или класса) на несколько «задач» вместо разделения его на несколько методов (или
занятия); встраивание избыточного кода вместо того, чтобы делать его менее избыточным; и так далее.
Поскольку потенциальные недостатки регионов значительно превышают их предполагаемые преимущества, регионы в настоящее время
большинство разработчиков C# считают плохой практикой, и их использование сократилось.

Это мнение подкреплено StyleCop, отличным инструментом статического анализа кода с открытым исходным кодом от Microsoft, который проверяет код C# на соответствие рекомендуемым стилям кодирования и рекомендациям по проектированию.
который суммирует свое суждение относительно регионов в правиле SA1124:

Хотя я в целом согласен с таким «антирегиональным» подходом, я все же считаю, что использование #regions для
группировать поля, свойства и т. д. может быть полезно в некоторых крайних сценариях, например в коде
примеры и учебные пособия (например, классы, которые мы создаем и рассматриваем в этой книге), поскольку это позволяет нам
различать разные части кода: например, мы собираемся использовать их, чтобы помочь читателю
отличать стандартные свойства от свойств навигации внутри типа сущности.
Вот почему в этой книге мы по-прежнему используем их здесь и там, даже если мы полностью осознаем, что хорошему коду, совместимому со StyleCop, они не понадобятся — даже для группировки полей, свойств, частных методов и т. д.
конструкторы и так далее: в то же время я также рекомендую их не использовать (или ограничить их использование).
до минимальной суммы) в вашем реальном коде.

# Определение отношений
Теперь, когда мы построили основной скелет сущности «Город» и «Страна», нам нужно обеспечить соблюдение взаимосвязей.
мы знаем, что существует между ними. Мы хотим иметь возможность делать такие вещи, как получение страны, а затем
просмотр всех связанных с ним городов, возможно, строго типизированным способом.
Для этого нам нужно добавить пару новых свойств, связанных с сущностями, по одному для каждого класса сущностей. Более
в частности, мы добавим следующее:

- Свойство Country в нашем классе объектов City, которое будет содержать одну страну, связанную с этим.
город (родительский)
- Свойство Cities в нашем классе объектов Country, которое будет содержать коллекцию городов.
связанные с этой страной (дети)
Если мы взглянем глубже и попытаемся визуализировать отношения между этими сущностями, мы сможем
посмотрите, как первое свойство идентифицирует родителя (с точки зрения каждого дочернего элемента), а второе
содержать детей (с точки зрения родителей): именно такого паттерна мы и можем ожидать
для отношений «один ко многим», подобных тем, с которыми мы имеем дело.
В следующих разделах мы узнаем, как реализовать эти два свойства навигации.

# Добавление свойства Country в класс сущности City
Добавьте следующие строки кода в конец файла, в конец области «Свойства» (новые строки
выделены):

```Csharp
using System.ComponentModel.DataAnnotations.Schema;
// ...existing code...
/// <summary>
/// Country Id (foreign key)
/// </summary>
[ForeignKey(nameof(Country))]
public int CountryId { get; set; }
#endregion
#region Navigation Properties
/// <summary>
/// The country related to this city.
/// </summary>
public Country? Country { get; set; } = null!;
#endregion
// …existing code...

```

Как мы видим, помимо добавления нового свойства Country, мы также украсили уже существующий
Свойство CountryId с новой аннотацией данных [ForeignKey(nameof(Country))]. Благодаря этому
аннотации, Entity Framework будет знать, что такое свойство будет содержать первичный ключ внешней таблицы.
и что свойство навигации Country будет использоваться для размещения родительского объекта.

Стоит отметить, что привязка, объявленная с использованием аннотации данных [ForeignKey],
также будет формально применяться путем создания ограничения, пока ядро базы данных
поддерживает такую функцию.

Также стоит отметить, что мы использовали nameof(Country) вместо простой строки «Country».
это позволит повысить типобезопасность нашего кода и тем самым сделать его менее подверженным ошибкам ввода.
Как мы видим, взглянув на первую строку предыдущего исходного кода, чтобы использовать [ForeignKey]
аннотацию данных, мы должны добавить ссылку на System.ComponentModel.DataAnnotations.Schema
пространство имен в начале класса, если мы еще этого не сделали.

# Добавление свойства Cities в класс сущности Country
Давайте теперь переключимся на класс Country.cs: как только он появится, добавьте следующее сразу после конца
Регион недвижимости:

```Csharp
// ...existing code...
#region Navigation Properties
/// <summary>
/// A collection of all the cities related to this country.
/// </summary>
public ICollection<City>? Cities { get; set; } = null!;
#endregion
// ...existing code...
```

Вот и все. Как мы видим, для этой сущности не были определены свойства внешнего ключа, поскольку
отношениям они не нужны с родительской стороны: поэтому нет необходимости добавлять [ForeignKey]
аннотация данных и/или необходимое пространство имен.

# Шаблон загрузки ядра Entity Framework
Теперь, когда у нас есть свойство Cities в сущности Country и соответствующие данные [ForeignKey].
аннотации в сущности City, вам может быть интересно, как мы можем использовать эти свойства навигации для
загрузить связанные объекты. Другими словами: как мы собираемся заполнить свойство Cities?
внутри объекта «Страна» всякий раз, когда нам это нужно?
Такой вопрос дает нам возможность потратить пару минут на перечисление трех шаблонов ORM.
поддерживается Entity Framework Core для загрузки таких связанных данных:
- Оперативная загрузка: связанные данные загружаются из базы данных как часть первоначального запроса.
- Явная загрузка: связанные данные явно загружаются из базы данных позднее.
- Отложенная загрузка: связанные данные прозрачно загружаются из базы данных, когда объект
Доступ к свойству навигации осуществляется впервые. Это самый сложный узор среди
три, и при неправильной реализации они могут серьезно снизить производительность.
Важно понимать, что всякий раз, когда мы хотим загрузить данные, связанные с объектом, нам необходимо активировать
(или реализовать) один из этих шаблонов. Это означает, что в нашем конкретном сценарии субъект нашей страны
Свойству Cities будет присвоено значение NULL всякий раз, когда мы извлекаем одну или несколько стран из базы данных, за исключением случаев, когда
мы явно указываем Entity Framework Core также загружать города.

Это очень важный аспект, который следует учитывать при работе с веб-API, поскольку он определенно повлияет на
как наша серверная часть .NET будет предоставлять ответы на структурированные данные JSON нашему внешнему клиенту Angular.
Чтобы понять, что мы имеем в виду, давайте рассмотрим пару примеров.
Ниже приведен стандартный запрос Entity Framework Core, который используется для получения страны из заданного
Идентификатор с поведением EF Core по умолчанию (шаблон загрузки не определен и не реализован):

```Csharp
var country = await _context.Countries
 .FindAsync(id);
return country; // country.Cities is still set to NULL

```

Как мы видим, переменная страны возвращается вызывающей стороне со свойством Cities, установленным в NULL.
просто потому, что мы об этом не просили: именно по этой причине, если мы преобразуем эту переменную в объект JSON
и вернуть его клиенту, объект JSON также не будет содержать городов.
Ниже приведен запрос Entity Framework Core, который извлекает страну по заданному идентификатору с помощью нетерпеливого запроса.
загрузка:

```Csharp
var country = await _context.Countries
 .Include(c => c.Cities)
 .FindAsync(id);
return country; // country.Cities is (eagerly) loaded
```
Попробуем понять, что здесь происходит:
- Метод Include(), указанный в начале запроса, сообщает Entity Framework Core
чтобы активировать шаблон получения данных с нетерпеливой загрузкой
- Что касается нового шаблона, запрос EF выберет страну, а также все соответствующие данные.
города в одном запросе
- По всем этим причинам возвращаемая переменная страны будет иметь свойство Cities, заполненное
все города, связанные со страной (то есть значение CountryId будет равно значению этой страны).
значение идентификатора)

Для простоты в этой книге мы будем использовать только нетерпеливую загрузку, используя функцию Include().
метод всякий раз, когда он нам нужен; дополнительную информацию об отложенной и явной загрузке см.
мы настоятельно рекомендуем вам просмотреть следующий URL-адрес: https://docs.microsoft.com/en-US/
ef/core/querying/related-data.

# Определение имен таблиц базы данных
Сценарий SQL, созданный EF Core с использованием подхода Code-First, согласно настройкам по умолчанию, будет
создайте таблицу базы данных для каждой сущности, используя имя класса сущности: по сути это означает, что мы
будет таблица City, содержащая все города, и таблица Country для стран. Хотя
в этих именах нет ничего плохого, мы могли бы также изменить настройку по умолчанию, чтобы создать
таблицы во множественном числе для обеспечения единообразия: «Города» для городов, «Страны» для стран.

Чтобы «заставить» имя таблицы базы данных по нашему выбору для каждого отдельного объекта, мы можем добавить данные [Table]
атрибут аннотации к классу сущности следующим образом.
Для сущности City (файл /Data/Models/City.cs):

```Csharp
[Table("Cities")]
public class City
```
Для объекта «Страна» (файл /Data/Models/Country.cs):

```Csharp
[Table("Countries")]
public class Country
```

Прежде чем идти дальше, давайте выполним это простое обновление наших классов, чтобы продемонстрировать, насколько легко
это необходимо для достижения дополнительного контроля над автоматически созданной базой данных.
На этом мы закончили с сущностями, по крайней мере на данный момент. Теперь нам просто нужно прийти в себя
СУБД, чтобы мы могли фактически создать нашу базу данных.

# Определение индексов
Поскольку мы собираемся иметь дело с набором данных, содержащим десятки тысяч записей, было бы также разумно
чтобы добавить некоторые индексы к нашим объектам. Такую задачу можно легко выполнить, используя аннотацию данных [Index].
атрибут следующим образом.
Для сущности City (файл /Data/Models/City.cs):

```Csharp
[Table("Cities")]
[Index(nameof(Name))]
[Index(nameof(Lat))]
[Index(nameof(Lon))]
public class City
```
Для объекта «Страна» (файл /Data/Models/Country.cs):

```Csharp
[Table("Countries")]
[Index(nameof(Name))]
[Index(nameof(ISO2))]
[Index(nameof(ISO3))]
public class Country
```
Чтобы использовать атрибут [Index], нам также необходимо добавить следующую ссылку в оба файла:

```Csharp
using Microsoft.EntityFrameworkCore;
```
Когда мы создаем базу данных с использованием подхода Code-First EF Core, эти атрибуты свойств будут
использоваться для создания индексов SQL для соответствующих столбцов таблицы, что значительно улучшит
производительность любого поискового запроса

# Получение экземпляра SQL Server
Давайте устраним этот пробел раз и навсегда и обеспечим себя экземпляром SQL Server. Как мы уже
Как уже упоминалось, есть два основных пути, по которым мы можем пойти:
- Установите локальный экземпляр SQL Server (выпуск Express или Developer) на нашем компьютере для разработки.
- Настройте базу данных SQL (и/или сервер) в Azure, используя один из нескольких вариантов, доступных на
эта платформа

Первый вариант воплощает классический безоблачный подход, который используют разработчики программного обеспечения и веб-разработчики.
используем с незапамятных времен: локальный экземпляр легко реализовать, и он предоставит все, что нам нужно.
понадобится в средах разработки и производства... пока нас не интересуют данные
избыточность, большая нагрузка на инфраструктуру и возможное влияние на производительность (в случае высокого трафика)
веб-сайты), масштабирование и другие узкие места из-за того, что наш сервер представляет собой единый физический объект.
В Azure все работает по-другому: размещение там нашей СУБД дает нам возможность использовать наш SQL.
Рабочие нагрузки сервера выполняются как размещенная инфраструктура (инфраструктура как услуга, также известная как
как IaaS) или размещенную услугу (платформа как услуга, также известная как PaaS): первый вариант хорош, если мы
хотите самостоятельно решать задачи обслуживания базы данных, такие как применение исправлений и принятие
резервные копии; второй вариант предпочтительнее, если мы хотим делегировать эти операции Azure. Однако,
независимо от пути, который мы выберем, у нас будет масштабируемая служба базы данных с полной избыточностью.
отсутствие гарантий единой точки отказа, а также множество других преимуществ производительности и безопасности данных. 
Минусы, как можно легко догадаться, заключаются в следующем: дополнительные затраты и тот факт, что мы собираемся
хранить наши данные в другом месте, что может стать серьезной проблемой с точки зрения конфиденциальности и защиты данных.
в определенных сценариях.
В следующем разделе мы кратко резюмируем, как реализовать оба этих подхода, чтобы мы
сможете сделать наиболее удобный выбор.

# Установка SQL-сервера 2019
Если мы хотим избежать облака и придерживаться подхода «старой школы», мы можем установить SQL
Локальный экземпляр Server Express (или Developer) на нашей машине разработки (а позже и на нашей рабочей машине).
Для этого выполните следующие шаги:

1. Загрузите локальный установочный пакет SQL Server 2019 (здесь мы будем использовать сборку для Windows, но также доступен установщик для Linux) по следующему URL-адресу: https://
www.microsoft.com/en-us/sql-server/sql-server-downloads.
2. Дважды щелкните исполняемый файл, чтобы начать процесс установки. Когда будет предложено ввести
тип установки, выберите вариант BASIC (если нам не нужно настроить некоторые дополнительные параметры).
для удовлетворения конкретных потребностей, при условии, что мы знаем, что делаем).

После этого установочный пакет начнет загрузку необходимых файлов. Когда это будет сделано, нам останется только
щелкнуть «Новая автономная установка SQL Server» (первый доступный вариант, начиная сверху, поскольку
показано на следующем снимке экрана), чтобы начать сам процесс установки:

Примите условия лицензии и продолжайте, сохраняя все параметры по умолчанию и выполняя необходимые действия.
операции (например, открытие брандмауэра Windows) по запросу.

Если мы хотим свести потребление дискового пространства к минимуму, мы можем безопасно
удалите службы репликации SQL и машинного обучения из списка функций.
раздел и сэкономьте примерно 500 МБ.

Установите имя экземпляра SQLExpress и идентификатор экземпляра SQLEXPRESS. Помните этот выбор:
он нам понадобится, когда нам придется записать строку подключения.
Когда нас попросят выбрать режим аутентификации (как видно на следующем снимке экрана),
выберите один из следующих вариантов:
- Режим аутентификации Windows, если мы хотим иметь неограниченный доступ к базе данных.
engine только с локального компьютера (используя наши учетные данные Windows)
- Смешанный режим, чтобы включить системного администратора SQL Server (пользователя sa) и установить пароль.
для этого
Эти два варианта можно увидеть на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/959819c6-b507-4903-8876-b3a55c4d92b8)

Первый вариант отлично подходит для обеспечения безопасности, а второй гораздо более универсален, особенно если мы
собираюсь администрировать SQL-сервер удаленно с помощью встроенного административного интерфейса SQL Server,
это инструмент, который мы собираемся использовать для создания нашей базы данных.

После завершения установки SQL Server мы можем сразу подключиться к вновь установленному
экземпляр с помощью одного из следующих бесплатных инструментов управления:
- SQL Server Management Studio, также известная как SSMS.
- Azure Data Studio, также известная как ADS.
Оба являются программными приложениями, которые позволяют подключаться к базе данных SQL Server и управлять ее содержимым (таблицами, пользователями, агентами и т. д.), а также выполнять запросы и сценарии. SSMS доступна только для Windows и имеет множество функций, которые можно реализовать с помощью графического интерфейса, тогда как ADS поддерживает
портативный, многоплатформенный и легкий дизайн с довольно минималистичным интерфейсом, который просто
позволяет выполнять SQL-запросы (по крайней мере, на данный момент).
Для целей этой книги мы будем использовать SQL Server Management Studio, поскольку она позволяет
изящная кривая обучения для новичков в SQL; однако Azure Data Studio может стать отличной альтернативой для
опытные разработчики SQL, которые предпочитают избегать подхода на основе графического интерфейса и выполнять все через
SQL-запросы и скрипты.

# Установка инструментов управления БД
SQL Server Management Studio можно установить с помощью дополнительных настроек мастера установки SQL Server.
компоненты (раздел «Инструменты управления SQL Server») или загруженные как отдельный пакет с сайта
следующий URL-адрес:
https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms
Azure Data Studio можно загрузить по следующему URL-адресу:
https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio
Прежде чем использовать эти инструменты для подключения к нашей базе данных, мы потратим немного драгоценного времени на обсуждение
о Лазурном пути.

# Создание базы данных SQL в Azure
Если вы хотите отказаться от локальных экземпляров СУБД и перейти на облачный маршрут Azure, наш список дел
полностью зависит от того, какой из основных подходов, предоставляемых платформой Azure, мы собираемся использовать.
Выбери из. Конечным пользователям доступны три основных варианта: от самого дешевого до самого дорогого:
База данных SQL, Управляемый экземпляр SQL и виртуальная машина SQL. Мы рассмотрим каждый по очереди.

# База данных SQL
Это полностью управляемый механизм базы данных SQL, основанный на выпуске SQL Server Enterprise. Этот вариант позволяет нам настраивать и управлять одной или несколькими отдельными реляционными базами данных, размещенными в облаке Azure, с помощью
модель использования и выставления счетов PaaS: более конкретно, мы можем определить ее как базу данных как услугу (DBaaS).
подход. Этот вариант обеспечивает встроенную высокую доступность, аналитику и управление, что означает
это отлично подходит для тех, кому нужно универсальное решение без необходимости настраивать, управлять,
и оплатите весь хостинг сервера.

# Управляемый экземпляр SQL
Это выделенный Управляемый экземпляр SQL в Azure. Это масштабируемая служба базы данных, которая обеспечивает почти
100% совместимость со стандартным экземпляром SQL Server и модель использования и выставления счетов IaaS.
Этот вариант предоставляет все те же преимущества PaaS, что и предыдущий (база данных SQL), но добавляет некоторые
дополнительные функции и возможности, такие как связанные серверы, брокеры служб, почта базы данных, полная версия Azure.
Поддержка виртуальных сетей, несколько баз данных с общими ресурсами и т. д.

# виртуальная машина SQL
Это полностью управляемый SQL-сервер, состоящий из виртуальной машины Windows или Linux с SQL-сервером.
экземпляр установлен поверх него. Этот подход, который также использует модель использования и выставления счетов IaaS, предлагает
полный административный контроль над всем экземпляром SQL Server и базовой ОС, следовательно,
самый сложный и настраиваемый. Самое существенное отличие от двух других вариантов
(База данных SQL и Управляемый экземпляр SQL) заключается в том, что виртуальные машины SQL Server также обеспечивают полный контроль
над ядром базы данных: мы можем выбирать, когда начинать обслуживание/исправление, изменять восстановление
модель, приостановить/запустить службу и т. д.

# Делая выбор
Все эти варианты хороши и, хотя и сильно различаются по общим затратам, их можно активировать.
бесплатно: База данных SQL, пожалуй, самая дешевая, поскольку она бесплатна в течение 12 месяцев благодаря
план пробной подписки, предлагаемый Azure, при условии, что мы сохраняем его размер менее 250 ГБ; И Управляемый экземпляр SQL, и Виртуальная машина SQL довольно дороги, поскольку они оба предоставляют виртуализированную
IaaS, но их можно активировать бесплатно (по крайней мере на несколько недель) за 200 евро, предоставленные тем же
План пробной подписки Azure.

В следующих разделах мы узнаем, как настроить базу данных SQL, поскольку она менее дорогая.
подход в долгосрочной перспективе: единственным недостатком является то, что нам придется поддерживать его размер ниже 250 ГБ... что
это определенно не проблема, учитывая, что размер исходного файла данных о городах мира составляет менее 1 ГБ.
Если вы хотите выбрать Управляемый экземпляр Azure SQL (вариант № 2), вот отличное руководство, объясняющее
как это сделать: https://docs.microsoft.com/en-us/azure/sql-database/sql-database-managedinstance-get-started.
Если вы хотите настроить SQL Server, установленный на виртуальной машине (вариант № 3), вот руководство, объясняющее это.
тема: https://docs.microsoft.com/en-US/azure/virtual-machines/windows/sql/quickstartsql-vm-create-portal.

# Настройка базы данных SQL
Начнем с посещения следующего URL-адреса: https://azure.microsoft.com/en-us/free/services/.
sql-база данных/.

Это приведет нас к следующей веб-странице, которая позволит нам создать экземпляр базы данных SQL Azure:

![image](https://github.com/artemovsergey/Angular/assets/26972859/58e06c91-aeca-4ca1-a826-ebe2401b1d0d)

Нажмите кнопку «Начать бесплатно» и создайте новую учетную запись.

Если у вас уже есть действующая учетная запись MS, вы определенно можете ее использовать; однако вам следует только
сделайте это, если вы уверены, что хотите использовать на нем бесплатную пробную версию Azure; если это не так,
рассмотрите возможность создания нового.

После краткой формы регистрации (и/или этапа входа в систему) мы будем перенаправлены на портал Azure.

Само собой разумеется, что если учетная запись, под которой мы вошли, уже израсходовала бесплатный период или
имеет активный платный план подписки, мы будем корректно возвращены:

![image](https://github.com/artemovsergey/Angular/assets/26972859/8e5a1280-cc78-442e-903c-6636f5fff3ac)

В конце концов, после того, как мы во всем разобрались, у нас должен появиться доступ к порталу Azure (https://
портал.azure.com) во всей красе:

![image](https://github.com/artemovsergey/Angular/assets/26972859/13c44e4a-9f41-43f7-b1ad-214e3a9e0a44)

Оказавшись там, сделайте следующее:
1. Нажмите кнопку «Создать ресурс», чтобы получить доступ к Azure Marketplace.
2. Найдите запись под названием Azure SQL.
3. Нажмите «Создать», чтобы получить доступ к странице выбора, показанной на следующем снимке экрана:

ВАЖНО. Будьте осторожны, чтобы не выбрать вместо этого запись «Управляемые экземпляры SQL».
который предназначен для создания виртуальной машины SQL Server — это вариант №2, который мы
говорили ранее.

![image](https://github.com/artemovsergey/Angular/assets/26972859/cdc018ba-67a0-4a4c-9893-e38f3c4d2572)

На предыдущем экране выбора выполните следующие действия:
1. Выберите первый вариант (базы данных SQL).
2. Установите в раскрывающемся списке Тип ресурса значение Одна база данных.
3. Нажмите кнопку «Создать», чтобы запустить основной мастер настройки.
В ходе этого процесса нам также будет предложено создать наш самый первый клиент Azure (если у нас еще нет
один). Это виртуальная организация, которая владеет и управляет определенным набором облачных служб Microsoft.
Арендаторы идентифицируются по уникальным URL-адресам в следующем формате: <TenantName>.onmicrosoft.com. Только
дайте ему подходящее имя и вперед.

# Настройка экземпляра
Как только мы нажмем кнопку «Создать», нам будет предложено настроить нашу базу данных SQL с помощью мастера.
Интерфейс разделен на следующие вкладки:
- Основные сведения: тип подписки, имя экземпляра, имя пользователя и пароль администратора и т. д.
- Сеть: метод сетевого подключения и правила брандмауэра.
- Безопасность: настройки безопасности.
- Дополнительные настройки: сортировка и часовой пояс.
- Теги: набор пар имя/значение, которые можно применять для логической организации ресурсов Azure в
функциональные категории или группы, имеющие общую область применения (например, производство и тестирование)
- Просмотреть + создать: просмотрите и подтвердите все предыдущие настройки.

На вкладке «Основные» нам нужно вставить сведения о базе данных, например имя базы данных, которое также будет
быть префиксом URL-адреса базы данных в формате <ИМЯ>.database.windows.net — и сервера, который мы
хотелось бы использовать. Если мы приедем сюда впервые, у нас не будет свободных серверов.
В связи с этим нам придется создать наш первый, щелкнув ссылку «Создать новый» и заполнив всплывающую форму, которая переместится в самую правую часть экрана. Обязательно установите нетривиального администратора сервера.
логин (на наших скриншотах мы будем использовать WorldCitiesAdmin) и сложный Пароль.

Важно понимать, что логин администратора Сервера — это не та учетная запись, которая будет использоваться.
с помощью нашего веб-приложения для доступа к базе данных WorldCities: мы создадим выделенного пользователя
(с меньшими правами) для этого. Логин администратора сервера — это учетная запись глобального администратора
весь экземпляр службы базы данных SQL Azure: в основном мы будем использовать его для выполнения высокоуровневых
административные задачи, такие как создание базы данных WorldCities, добавление веб-приложений
выделенный пользователь и так далее.

На следующем снимке экрана показан пример настройки этой части мастера:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c1fa1d99-e00b-4b4c-b9b0-b47449b7861c)

Последние два параметра на вкладке «Основные» запросят у нас тип хранилища «Вычисления +» и «Резервное хранилище».
избыточность: для этого конкретного проекта мы определенно можем выбрать минимально возможный уровень — локальный
резервный базовый тип хранилища с максимальным объемом 2 ГБ (см. следующий снимок экрана):

![image](https://github.com/artemovsergey/Angular/assets/26972859/e7239682-40b6-4dc6-93a5-dd630c91addd)

Однако, если мы чувствуем себя смелыми, мы можем вместо этого выбрать стандартный тип с объемом памяти 250 ГБ, поскольку он
будет по-прежнему бесплатным в течение 12 месяцев.
На вкладке «Сеть» обязательно выберите общедоступную конечную точку, чтобы включить внешний доступ из Интернета.
чтобы мы могли подключаться к нашей базе данных из всех наших сред. Мы также должны установить оба
для правил брандмауэра установлено значение «Да», чтобы разрешить службам и ресурсам Azure доступ к серверу и добавить наш текущий IP-адрес.
адрес в белом списке разрешенных IP-адресов.

Подождите: разве это не серьезная проблема безопасности? Что, если наши базы данных содержат личные
или конфиденциальные данные?
На самом деле, это так: разрешить публичный доступ из Интернета – это то, что мы должны сделать.
всегда избегайте, если только мы не играем с открытыми данными для тестирования, демонстраций или учебных пособий.
целей... это именно то, что мы делаем прямо сейчас.

На вкладках «Дополнительные настройки» и «Теги» все в порядке с настройками по умолчанию: нам нужно только изменить их.
если нам нужно изменить некоторые параметры (например, параметры сортировки и часовой пояс, который наиболее подходит для нашего
язык и страна) или активировать определенные функции, такие как расширенная безопасность данных, что совершенно не нужно для наших текущих потребностей.

На вкладке «Просмотр + создание» у нас будет последняя возможность просмотреть и изменить наши настройки (как показано на рисунке).
следующий скриншот):

![image](https://github.com/artemovsergey/Angular/assets/26972859/e9a4752a-561f-46af-a8e3-ecdf8f67b6ea)

Если мы в них не уверены, у нас есть возможность вернуться и изменить их. Когда мы уверены на 100%,
мы можем нажать кнопку «Создать» и развернуть нашу базу данных SQL за несколько секунд.

Стоит отметить, что мы также можем скачать шаблон для автоматизации, если захотим.
сохраните эти настройки, чтобы в будущем создать дополнительные базы данных SQL.

Вот и все: теперь мы можем сосредоточиться на настройке нашей базы данных.

# Настройка базы данных
Независимо от того, какой путь мы выберем — локальный экземпляр или Azure — мы должны быть готовы управлять нашими новыми
создал базу данных SQL Azure.

Самый практичный способ сделать это — подключиться к нему с помощью одного из двух бесплатных инструментов управления SQL Server.
Графические интерфейсы Microsoft, о которых мы говорили ранее: SQL Server Management Studio и Azure.
Студия данных. Если вы еще не установили его, сейчас самое время это сделать.

В следующих примерах и снимках экрана, а также в остальной части книги мы будем использовать SQL Server Management Studio.

После установки инструмента запустите его: на главной панели управления нажмите ссылку «Новое подключение», затем
заполните форму с данными вашей базы данных SQL, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/e304e458-4df3-4d3d-a496-4229c71d7db9)

Точнее, нам нужно использовать имя сервера, логин и пароль, выбранные при установке.
наш локальный экземпляр SQL Server или создал базу данных SQL в Azure.

Как мы видим, взглянув на URL-адрес, который мы написали в поле «Сервер», в предыдущем
снимок экрана, на котором мы подключаемся к типичному экземпляру базы данных SQL Azure: чтобы подключиться
для локально установленного SQL-сервера мы будем использовать localhost\SQLEXPRESS, 127.0.0.1\
SQLEXPRESS или что-то в этом роде, в зависимости от выбранного нами имени экземпляра.
в процессе установки.

Нажав кнопку «Подключиться», мы сможем войти на наш сервер базы данных. Как только ССМС
подключается к серверу базы данных SQL, появится окно обозревателя объектов с древовидным представлением
представляющий структуру нашего экземпляра SQL Server. Это интерфейс, который мы будем использовать для создания нашего
базу данных, а также пользователя/пароль, который наше приложение будет использовать для доступа к ней.

# Создание базы данных World Cities
Если мы выберем маршрут базы данных SQL Azure, мы уже сможем увидеть базу данных World Cities.
в папке Базы данных дерева обозревателя объектов слева:

![image](https://github.com/artemovsergey/Angular/assets/26972859/569d5cc5-ef05-4406-b3c4-d506e0868dba)

В качестве альтернативы, если мы установили наш локальный экземпляр SQL Server Express или Developer, нам придется вручную
создайте его, выполнив следующие действия:
1. Щелкните правой кнопкой мыши папку «Базы данных».
2. Выберите «Добавить базу данных» в контекстном меню.
3. Введите имя WorldCities, затем нажмите «ОК», чтобы создать его.
Как только база данных будет создана, у нас появится возможность развернуть узел ее дерева, щелкнув значок
знак плюс (+) слева и визуально взаимодействует со всеми дочерними объектами — таблицами, хранимыми процедурами, пользователями,
и так далее — через графический интерфейс SSMS. Само собой разумеется, что если мы сделаем это сейчас, мы не найдем таблиц, потому что мы их еще не создали: это то, что Entity Framework Core сделает за нас.
позже. Однако прежде чем сделать это, мы собираемся добавить учетную запись для входа, чтобы наше веб-приложение
умею подключаться.

# Добавление логина WorldCities
Параметры безопасности базы данных можно настроить двумя разными способами:
- Использование графического интерфейса SSMS, который доступен только в том случае, если база данных размещена на локальном (или удаленном) компьютере.
Экземпляр SQL Server, например SQL Server Express или Developer.
- Использование необработанных команд SQL, которые всегда доступны, а также являются единственным доступным вариантом, если
мы создали нашу базу данных SQL в MS Azure (или если мы используем Azure Data Studio вместо SSMS)
Начнем с первого варианта, который позволяет нам добавлять и настраивать учетные записи без написания
одна строка кода SQL.

# Использование графического интерфейса SSMS
В обозревателе объектов SSMS вернитесь в верхнюю корневую папку и разверните папку «Безопасность», которая
должно быть чуть ниже него. Оказавшись там, сделайте следующее:
- Щелкните правой кнопкой мыши подпапку «логины» и выберите «Новый вход».
- В появившемся модальном окне установите имя для входа в WorldCities.
- В списке переключателей под именем входа выберите «Аутентификация SQL Server» и установите
подходящий пароль с достаточной надежностью (например, MyVeryOwn$721 — мы собираемся использовать его).
для примеров кода и снимков экрана с этого момента)
- Обязательно отключите этот параметр. Пользователь должен изменить пароль при следующем входе в систему (который отмечен флажком).
по умолчанию); в противном случае Entity Framework Core не сможет выполнить вход в систему позже.
- Установите для пользователя базу данных по умолчанию WorldCities.
- Просмотрите все параметры, затем нажмите «ОК», чтобы создать учетную запись WorldCities.
Если нам нужен более простой пароль, например WorldCities или Password, нам, возможно, придется отключить принудительное применение.
опция политики паролей. Однако мы настоятельно не рекомендуем этого делать: выбирайте слабый пароль.
никогда не будет разумным выбором, особенно если мы делаем это в готовой к работе среде. Мы предлагаем, чтобы
вы всегда используете надежный пароль, даже в средах тестирования и разработки. Просто будьте уверены, что не
забудьте об этом, так как оно нам понадобится позже.
Использование необработанных команд SQL
Если мы имеем дело с базой данных SQL, размещенной в MS Azure, мы используем Azure Data Studio или предпочитаем
чтобы использовать необработанный SQL, вот сценарий, который создаст вышеуказанного пользователя:

```sql
CREATE LOGIN WorldCities
 WITH PASSWORD = 'MyVeryOwn$721'
GO
```

Если мы хотим ослабить политику паролей, мы можем добавить опцию CHECK_POLICY = OFF к приведенному выше запросу;
однако мы настоятельно не рекомендуем делать это по соображениям безопасности, которые были объяснены ранее.

# Сопоставление логина с базой данных
Следующее, что нам нужно сделать, это правильно сопоставить этот логин с базой данных WorldCities, которую мы добавили ранее.
Вот как это сделать с помощью графического интерфейса SSMS:
1. Дважды щелкните имя входа WorldCities в папке «Безопасность», чтобы открыть ту же модель.
мы использовали всего несколько секунд назад.
2. В меню навигации слева перейдите на вкладку «Сопоставление пользователей».
3. Установите флажок слева от базы данных WorldCities: ячейка Пользователь должна автоматически заполниться значением WorldCities. Если это не так, нам нужно будет вручную ввести WorldCities.
внутрь.
4. В поле «Членство в роли базы данных для» на нижней правой панели назначьте db_owner.
членская роль.

Все предыдущие шаги изображены на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/d4f6e161-862c-4726-a80a-36c50e01d904)

Опять же, если нам нужно (или мы предпочитаем) использовать необработанные команды SQL, вот сценарий, который нужно использовать (обязательно переключитесь на
базу данных WorldCities перед ее запуском):

```sql
CREATE USER WorldCities
 FOR LOGIN WorldCities
 WITH DEFAULT_SCHEMA = dbo
GO
EXEC sp_addrolemember N'db_owner', N'WorldCities'
GO
```
That’s it! Now, we can go back to our web application project, add the connection string, and create
our tables (and data) using the Entity Framework Code-First approach.

# Создание базы данных с помощью Code-First
Прежде чем идти дальше, давайте составим краткий контрольный список:
- Мы закончили с нашими сущностями? Да
- Есть ли у нас СУБД и база данных WorldCities? Да
- Прошли ли мы все необходимые шаги, которые необходимо выполнить для фактического создания и заполнения
в вышеупомянутой базе данных с использованием Code-First? Нет

На самом деле нам нужно позаботиться еще о двух вещах:
- Настройте соответствующий контекст базы данных.
- Включите поддержку Code-First Data Migrations в нашем проекте.
В следующих разделах мы собираемся заполнить все эти пробелы и в конечном итоге заполнить наши WorldCities.
база данных.

# Настройка DbContext
Для взаимодействия с данными как объектами/классами сущностей Entity Framework Core использует пакет Microsoft.
Класс EntityFrameworkCore.DbContext, также называемый DbContext или просто Context. Этот класс находится в
ответственность за все объекты сущностей во время выполнения, включая заполнение их данными из
базу данных, отслеживая изменения и сохраняя их в базе данных во время операций CRUD.
Мы можем легко создать для нашего проекта собственный класс DbContext, который мы назовем
ApplicationDbContext — выполнив следующие действия:
1. В обозревателе решений щелкните правой кнопкой мыши папку /Data/, которую мы создали некоторое время назад, и добавьте новую
Файл класса ApplicationDbContext.cs
2. Заполните его следующим кодом:

```Csharp
using Microsoft.EntityFrameworkCore;
using WorldCitiesAPI.Data.Models;
namespace WorldCitiesAPI.Data
{
 public class ApplicationDbContext : DbContext
 {
 public ApplicationDbContext() : base()
 {
 }
 public ApplicationDbContext(DbContextOptions options)
 : base(options)
 {
 }
 public DbSet<City> Cities => Set<City>();
 public DbSet<Country> Countries => Set<Country>();
 }
}
```

Как мы видим, мы воспользовались возможностью добавить свойство DbSet<T> для каждой из наших сущностей, чтобы мы могли
легко получить к ним доступ позже.

# Entity type configuration methods
Since we chose to adopt the Code-First data modeling approach, we need to make sure that our entities
are properly configured from within the code, so that the SQL scripts generated by Entity Framework
Core will create the database using the names, database types, definitions, and rules that we want.
EF Core provides three available methods for configuring various aspects of your model:
- Data Annotations, through attributes applied directly on the entity types
- Fluent API (also known as ModelBuilder API), via custom rules applied by overriding the
OnModelCreating method in DbContext
- EntityTypeConfiguration classes, via custom rules applied to separate configuration classes
referenced in the DbContext OnModelCreating override method (by all means an alternative
take on the Fluent API approach)
All of them are viable enough for most scenarios: however, in a real project, it is highly advisable to
avoid mixing them and just pick one for the sake of consistency.
Let’s briefly review all of them before choosing our pick.

# Аннотации к данным
Аннотации к данным — это специальные атрибуты, которые можно применять к классам и свойствам сущностей для
переопределить соглашения Code-First по умолчанию и/или определить новые правила. Основное преимущество данных
Аннотации заключаются в том, что они позволяют разработчику управлять определением данных в коде класса, что
отлично подходит для читаемости и удобства обслуживания кода.
Фактически, мы уже использовали аннотации к данным в наших существующих классах сущностей, когда добавляли
Атрибуты [Key], [Required] и [ForeignKey] для их свойств, связанных с базой данных. Это означает
что, если мы хотим переключиться на другой метод конфигурации, нам нужно будет выполнить небольшой рефакторинг нашего кода.
Аннотации к данным отлично подходят для применения простых изменений конфигурации, что часто делает их идеальными.
для небольших проектов; однако они не поддерживают весь набор доступных параметров конфигурации.
от EF Core. Всякий раз, когда нам нужно получить больше контроля над настройками типа сущности, мы можем легко почувствовать
желание перейти на более мощный метод.

# Fluent API
Чтобы использовать Fluent API, нам нужно переопределить метод OnModelCreating в нашем производном контексте.
и используйте API ModelBuilder для настройки нашей модели.
Отличный способ понять, как мы можем использовать Fluent API, — это посмотреть, как мы можем преобразовать наши
существующие аннотации к данным в настройки ModelBuilder. Вот как мы можем это сделать:

```Csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
 base.OnModelCreating(modelBuilder);
 modelBuilder.Entity<City>().ToTable("Cities");
 modelBuilder.Entity<City>()
 .HasKey(x => x.Id);
 modelBuilder.Entity<City>()
 .Property(x => x.Id).IsRequired();
 modelBuilder.Entity<City>()
 .Property(x => x.Lat).HasColumnType("decimal(7,4)");
 modelBuilder.Entity<City>()
 .Property(x => x.Lon).HasColumnType("decimal(7,4)");
 modelBuilder.Entity<Country>().ToTable("Countries");
 modelBuilder.Entity<Country>()
 .HasKey(x => x.Id);
 modelBuilder.Entity<Country>()
 .Property(x => x.Id).IsRequired();
 modelBuilder.Entity<City>()
 .HasOne(x => x.Country)
 .WithMany(y => y.Cities)
 .HasForeignKey(x => x.CountryId);
}
```
Предыдущий метод переопределения следует добавить в класс ApplicationDbContext.
сразу после конструкторов: подробности см. в исходном коде в репозитории GitHub.

Как мы видим, для каждой аннотации данных, которую мы использовали до сих пор, существует соответствующий Fluent API.
метод: ToTable() для [Table], HasKey() для [Key], IsRequired() для [Required] и так далее.
Основное преимущество Fluent API заключается в том, что такой метод позволяет нам указывать конфигурацию сущности без изменения наших классов сущностей; кроме того, конфигурации Fluent API имеют самый высокий
приоритет, что означает, что они будут переопределять любое существующее соглашение EF Core и/или аннотацию данных.
применяется к классам и свойствам сущностей.

Их единственным реальным недостатком является то, что, несмотря на «гибкость», они довольно многословны; в больших проектах и/или
сложные сценарии конфигурации объектов, а также то, когда они действительно хороши, объем кода, который они
Требование легко увеличивается по мере накопления необходимых настроек, что делает исходный код DbContext
довольно сложно читать и поддерживать.

# Классы EntityTypeConfiguration
Классы EntityTypeConfiguration — это ключевой аспект расширенного шаблона кодирования, целью которого является
преодолеть основную проблему Fluent API, сохранив при этом все их преимущества.
В двух словах, этот метод использует метод API ApplyConfigurationsFromAssembly Fluent,
который позволяет определять внешние правила в отдельных файлах конфигурации, тем самым удаляя
необходимо объединить их все в методе переопределения OnModelCreating DbContext и уменьшить
необходимое количество кода в одну строку.
Опять же, лучший способ понять, как работает этот метод, — это объяснить, как мы можем преобразовать наши
существующие правила аннотации данных в классы конфигурации.
На этот раз нам нужно будет создать два дополнительных файла. Первый будет называться /Data/Models/.
СитиEntityTypeConfiguration.cs:

```Csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
namespace WorldCitiesAPI.Data.Models
{
 public class CityEntityTypeConfiguration
 : IEntityTypeConfiguration<City>
 {
 public void Configure(EntityTypeBuilder<City> builder)
 {
 builder.ToTable("Cities");
 builder.HasKey(x => x.Id);
 builder.Property(x => x.Id).IsRequired();
 builder
 .HasOne(x => x.Country)
 .WithMany(x => x.Cities)
 .HasForeignKey(x => x.CountryId);
 builder.Property(x => x.Lat).HasColumnType("decimal(7,4)");
 builder.Property(x => x.Lon).HasColumnType("decimal(7,4)");
 }
 }
}
```
А второй будет называться /Data/Models/CountryEntityTypeConfiguration.cs:

```Csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
namespace WorldCitiesAPI.Data.Models
{
 public class CountryEntityTypeConfiguration
 : IEntityTypeConfiguration<Country>
 {
 public void Configure(EntityTypeBuilder<Country> builder)
 {
 builder.ToTable("Countries");
 builder.HasKey(x => x.Id);
 builder.Property(x => x.Id).IsRequired();
 }
 }
}
```
Добавить эти классы конфигурации в наш ApplicationDbContext было бы так же просто, как добавить это
одна строка в методе OnModelCreating, который мы добавили ранее:

```Csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
 base.OnModelCreating(modelBuilder);
 // add the EntityTypeConfiguration classes
 modelBuilder.ApplyConfigurationsFromAssembly(
 typeof(ApplicationDbContext).Assembly
 );
}
```

# Делая выбор
Теперь, когда мы изучили три альтернативных способа настройки наших объектов, предлагаемых EF Core, мы
нужно выбрать, какой из них мы будем использовать в дальнейшем.
Само собой разумеется, что метод классов EntityTypeConfiguration является наиболее предпочтительным.
подход для крупных проектов, поскольку он дает нам возможность последовательно и последовательно организовать наши настройки.
структурированном и читаемом виде: однако, поскольку мы будем иметь дело с очень простыми моделями баз данных, которые
в этой книге потребуется минимальное количество настроек конфигурации, мы продолжим использовать
подход к аннотированию данных.

Базовая реализация двух других методов, которые мы обсуждали ранее в этом разделе, также доступна в исходном коде этой главы в репозитории GitHub, поэтому
что читатели, желающие применить другой подход, все равно могут их просмотреть. Оба
Метод OnModelCreating ApplicationDbContext и EntityTypeConfiguration
классы были задокументированы с <summary>, объясняющим, что этот код является избыточным.
переопределение правил аннотирования данных и предназначено только для образовательных целей: такие
избыточный код будет удален в Главе 6 «Извлечение и отображение данных» и в
последующие главы, в которых будут представлены только аннотации к данным.

# Стратегии инициализации базы данных
Создание базы данных в первый раз — это не единственное, о чем нам нужно беспокоиться; например, как
можем ли мы отслеживать изменения, которые обязательно произойдут с нашей моделью данных?
В предыдущих неосновных версиях EF (вплоть до 6.x) мы могли выбрать один из способов управления базой данных.
шаблоны (известные как инициализаторы базы данных или DbInitializers), предлагаемые подходом Code-First, то есть
выбрав подходящую стратегию инициализации базы данных для наших конкретных нужд, из:
- CreateDatabaseIfNotExists.
- DropCreateDatabaseIfModelChanges.
- DropCreateDatabaseAlways
- Мигрировать базу данных в последнюю версию.
Кроме того, если нам потребуется удовлетворить особые требования, мы также можем настроить наши собственные
инициализатор, расширив один из предыдущих и переопределив их основные методы.
Основным недостатком DbInitializers было то, что они не были достаточно быстрыми и оптимизированными для
средний разработчик. Они были жизнеспособны, но с ними было трудно справиться без обширных знаний о Сущности.
Логика фреймворка.
В Entity Framework Core этот шаблон значительно упрощен; нет никаких DbInitializers, и
автоматическая миграция данных также была удалена. Аспект инициализации базы данных теперь полностью
обрабатывается с помощью команд PowerShell, за единственным исключением небольшого набора команд, которые могут
размещаться непосредственно в конструкторе реализации DbContext для частичной автоматизации процесса;
они следующие:
- База данных.EnsureCreated()
- База данных.EnsureDeleted()
- База данных. Миграция()
В настоящее время нет возможности программно выполнить миграцию данных; их необходимо добавить через PowerShell, как мы вскоре увидим.

# Updating the appsettings.json file
From Solution Explorer, open the appsettings.json file and add a new "ConnectionStrings" JSON
key section right below the "Logging" one with the following value (new lines are highlighted):

```json
{
 "Logging": {
 "LogLevel": {
 "Default": "Warning"
 }
 },
 "AllowedHosts": "*",
 "ConnectionStrings": {
 "DefaultConnection": "Server=localhost\\SQLEXPRESS;
 Database=WorldCities;
 User Id=WorldCities;Password=MyVeryOwn$721;
 Integrated
Security=False;MultipleActiveResultSets=True;TrustServerCertificate=True"
 }
}
```
К сожалению, JSON не поддерживает LF/CR, поэтому нам нужно будет добавить DefaultConnection
значение в одной строке. Если вы скопируете и вставите предыдущий текст, убедитесь, что Visual Studio
не добавляет автоматически дополнительные двойные кавычки и/или escape-символы в эти строки;
в противном случае ваша строка подключения не будет работать.

Это строка подключения, на которую мы позже будем ссылаться в файле Program.cs нашего проекта.
ВАЖНО: Как мы видим, теперь наш файл appsettings.json содержит идентификатор пользователя нашей базы данных и
Пароль в виде открытого текста, что создает нетривиальную проблему безопасности. Хотя этот файл в настоящее время находится исключительно
на нашей машине разработки, возможно, что рано или поздно он будет «случайно» расшарен или
опубликовано в другом месте, например, в репозитории GitHub. Именно по этой причине не проверяйте свой
проект, пока не прочтете следующий абзац.

# Представляем хранилище секретов

Начиная с .NET Core 2.x и Visual Studio 2019, Microsoft предоставила своим разработчикам новую
функция, которую можно использовать для хранения любого секрета (паролей баз данных, ключей API и т. д.) в безопасном и
эффективный способ: эта функция называется «Хранилище секретов» и хорошо документирована в безопасном хранилище Microsoft.
секреты приложения в разработке в официальном руководстве ASP.NET Core, доступном по следующему URL-адресу: https://docs.
microsoft.com/en-us/aspnet/core/security/app-secrets.
Короче говоря, новая функция создает файл secrets.json в пользовательской папке компьютера разработки.
(в типичной среде Windows файл \Users\UserName\AppData\Roaming\Microsoft\UserSecrets
каталог), который можно использовать для добавления или переопределения элементов стандартных файлов appsettings.json.
используя тот же синтаксис, который у них уже есть.
Это хорошо по ряду причин, в том числе:
• Файл secrets.json недоступен для удаленных пользователей, например тех, кто мог получить доступ к файлу secrets.json.
проект из репозитория GitHub, поскольку он будет создан в локальной папке
Локальные пользователи не смогут получить доступ к файлу secrets.json, поскольку он будет создан в
личная папка разработчика (которая недоступна другим локальным пользователям)
• Файл secrets.json будет работать сразу после установки, фактически расширяя настройки приложения.
json, не заставляя нас писать туда какие-либо секреты
Эта функция является отличной альтернативой подходу с использованием переменных среды, который является еще одним обходным решением.
предложенный Microsoft в предыдущем руководстве, лично мне не очень нравится (по крайней мере, для сред разработки), потому что он гораздо менее гибкий и простой.
Теперь, когда мы выбрали свой путь, давайте посмотрим, как мы можем его реализовать.

# Добавление файла secrets.json
Одним из величайших аспектов функции «Хранилище секретов» является тот факт, что ее можно использовать изнутри.
Графический интерфейс Visual Studio, возможно, лучший способ сделать это.
Все, что нам нужно сделать, это щелкнуть правой кнопкой мыши корневую папку проекта в обозревателе решений и выбрать «Управление».
Параметры секретов пользователя, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c8116505-7e23-4dac-8c6f-26fb627d5da4)

Как только мы выберем этот параметр, Visual Studio добавит элемент UserSecretsId в PropertyGroup.
файла .csproj проекта, присвоив ему случайное значение GUID:

```
<PropertyGroup>
 [...]
 <UserSecretsId>9430de8f-8575-4a47-9d22-a98e491af64c</UserSecretsId>
 </PropertyGroup>
```
Такое случайное значение UserSecretsId затем используется Visual Studio для создания пустого файла secrets.json.
файл в следующей папке:

```\Users\UserName\AppData\Roaming\Microsoft\UserSecrets\```

Сразу после этого Visual Studio откроет этот файл secrets.json в графическом интерфейсе в режиме редактирования, чтобы
мы можем использовать его для хранения наших секретов.

# Совместное использование файла secrets.json между несколькими проектами
По умолчанию внутренний текст UserSecretsId представляет собой случайно сгенерированный GUID; однако это значение
произвольный и может быть изменен: использование (случайного) уникального идентификатора предотвратит
наличие одного и того же файла secrets.json; в то же время выбор одного и того же идентификатора может быть полезен, если мы
хотят «разделить» одни и те же секреты между несколькими проектами.
В репозитории GitHub этой книги мы воспользовались этим поведением, определив произвольный
UserSecretsId для каждого отдельного проекта — один для HealthCheckAPI, другой для WorldCitiesAPI,
и так далее — и «перерабатывать» его через все экземпляры этих проектов в различных главах.
папки. Например, вот значение UserSecretsId, которое мы использовали для всех экземпляров текущего проекта:

```
<UserSecretsId>WorldCitiesAPI</UserSecretsId>
```

Чтобы вручную установить это значение, мы можем использовать опцию «Редактировать файл проекта», доступную в визуальном меню.
Графический интерфейс Studio, доступный по щелчку правой кнопкой мыши по корневой папке проекта Solutions Explorer:

![image](https://github.com/artemovsergey/Angular/assets/26972859/f032c82d-6ed5-4f44-820c-82e3550e5062)

Кроме того, мы также можем отредактировать файл WorldCities.csproj в корневой папке проекта, используя текстовый файл.
редактор по нашему выбору (включая Блокнот Windows) и найдите соответствующую строку/значение, которое нужно изменить.

# Работа с файлом secrets.json
Теперь, когда мы создали файл secrets.json, давайте воспользуемся им: откройте файл appsettings.json и вырежьте
весь блок ConnectionStrings:

```json
{
 "Logging": {
 "LogLevel": {
 "Default": "Warning"
 }
 },
 "AllowedHosts": "*"
}
```

И вставьте его в файл secrets.json следующим образом:

```json
{
 "ConnectionStrings": {
 "DefaultConnection": "Server=localhost\\SQLEXPRESS;
 Database=WorldCities;
 User Id=WorldCities;Password=MyVeryOwn$721;
 Integrated
Security=False;MultipleActiveResultSets=True;TrustServerCertificate=True"
 }
}
```
ПРИМЕЧАНИЕ. Значение «DefaultConnection» должно быть указано в одной строке, в противном случае
это не сработает.

Вот и все: ключи JSON, определенные в файле secrets.json, будут добавлены к уже присутствующим.
в файле appsettings.json (заменив их, если они уже есть) простым и прозрачным способом,
без необходимости делать что-либо еще.
В следующем разделе у нас появится хороший шанс воспользоваться такой удобной функцией.

# Создание базы данных
Теперь, когда мы настроили собственный DbContext и определили действительную строку подключения, указывающую на наш
WorldCities, мы можем легко добавить первоначальную миграцию и создать нашу базу данных.

# Обновление Program.cs
Первое, что нам нужно сделать, это добавить поддержку EntityFramework и наш ApplicationDbContext.
реализацию в наш класс запуска приложения. Откройте файл Program.cs и добавьте следующий новый
строки прямо под последним сервисом (это должен быть SwaggerGen):

```Csharp
// ...existing code...
builder.Services.AddSwaggerGen();
// Add ApplicationDbContext and SQL Server support
builder.Services.AddDbContext<ApplicationDbContext>(options =>
 options.UseSqlServer(
 builder.Configuration.GetConnectionString("DefaultConnection")
 )
);
// ...existing code...

```

В новом коде также потребуются следующие ссылки на пространство имен:

```Csharp
using Microsoft.EntityFrameworkCore;
using WorldCitiesAPI.Data;
```
Как мы видим, мы использовали метод расширения GetConnectionString("DefaultConnection"), предоставляемый интерфейсом IConfiguration, который можно использовать для получения ConnectionStrings:Defa.
JSON-ключ ultConnection из файла appsettings.json.
Однако в нашем конкретном сценарии это значение будет получено из файла secrets.json, поскольку мы
недавно переместил туда весь блок ConnectionStrings.

Метод GetConnectionString("DefaultConnection") по сути является ярлыком для
Команда Configuration["ConnectionStrings:DefaultConnection"]: оба
вернет то же значение ключа JSON, пока эти ключи существуют, из настроек приложения.
json и/или файлы secrets.json.

# Добавляем первоначальную миграцию
Чтобы добавить первоначальную миграцию, мы можем использовать CLI dotnet (из командной строки) или пакет
Консоль диспетчера (из графического интерфейса Visual Studio).

Судя по отзывам читателей, если ваша среда разработки прошла ряд
При последующих обновлениях .NET Core SDK консоль диспетчера пакетов может выбрать неверный вариант.
оснастка и провал. Имея это в виду, я предлагаю сначала попробовать CLI, а затем переключиться на
Консоль диспетчера пакетов на случай проблем: если оба подхода не сработают, это может быть целесообразно.
чтобы удалить некоторые старые пакеты SDK для .NET Core, и повторите попытку.


# Использование CLI dotnet
Откройте командную строку PowerShell и перейдите в корневую папку проекта, которая выглядит следующим образом:
в нашем примере:
```
C:\ThisBook\Chapter_05\WorldCities\WorldCitiesAPI\
```
Оказавшись там, введите следующую команду, чтобы глобально установить инструмент командной строки dotnet-ef:
```
dotnet tool install --global dotnet-ef
```
Подождите, пока установка не завершится. Когда мы получим вывод зеленого сообщения, введите следующее
команда для добавления первой миграции:

```
dotnet ef migrations add "Initial" -o "Data/Migrations"
```

Необязательный параметр -o можно использовать для изменения места, где выполняется миграция.
будут созданы файлы, сгенерированные кодом; если мы его не укажем, корневой уровень /Migrations/
папка будет создана и использована по умолчанию. Поскольку мы поместили все EntityFrameworkCore
классы в папку /Data/, там же желательно хранить миграции.

Предыдущая команда выдаст следующий результат:

![image](https://github.com/artemovsergey/Angular/assets/26972859/de9b5d76-5c3d-42dd-8830-5d538fd26e37)

Если мы видим «зеленый» свет, значит, все прошло ОК: первичная миграция настроена и
мы готовы его применить.

Если мы вернемся в Visual Studio и посмотрим на Обозреватель решений нашего проекта, мы увидим:
видите, что есть новая папка /Data/Migrations/, содержащая кучу сгенерированных кодом
файлы. Эти файлы содержат фактические команды SQL низкого уровня, которые будут использоваться Entity.
Framework Core для создания и/или обновления схемы базы данных.

# Обновление базы данных
Применение миграции данных по сути означает создание (или обновление) базы данных для синхронизации.
его содержимое (структура таблиц, ограничения и т. д.) с правилами, определяемыми общим
шаблоны и определения в DbContext, а также с помощью аннотаций данных внутри различных Entity.
занятия. Точнее, первая миграция данных создает всю базу данных с нуля, тогда как при первой миграции данных создается вся база данных с нуля.
последующие будут его обновлять (создавать таблицы, добавлять/изменять/удалять поля таблицы и так далее).
В нашем конкретном сценарии мы собираемся выполнить нашу первую миграцию. Вот одна строка, которая нам нужна
введите в командной строке (в корневой папке проекта, как и раньше), чтобы сделать это:

```dotnet ef database update```

Как только мы нажмем Enter, набор операторов SQL заполнит вывод нашего окна терминала командной строки. По завершении, если все в порядке, мы можем вернуться к инструменту SSMS и обновить сервер.
Просмотрите дерево обозревателя объектов и убедитесь, что база данных WorldCities создана вместе со всеми
соответствующих таблиц:

Ошибка «Не найден исполняемый файл, соответствующий команде dotnet-ef»
На момент написания статьи существовала неприятная проблема, затрагивающая большинство проектов Visual Studio на базе .NET, которые могут
предотвратить правильную работу команды dotnet ef. Более конкретно, нас может побудить
следующее сообщение об ошибке при попытке выполнить любую команду на основе dotnet ef:

Если у нас возникнет эта проблема, мы можем попытаться проверить следующее:
- Дважды проверьте, что мы добавили библиотеку пакетов Microsoft.EntityFrameworkCore.Tools (как
объяснено ранее) правильно, так как это необходимо для работы команды.
- Убедитесь, что мы вводим команду dotnet ef в корневой папке проекта — той же самой.
он также содержит файл <ProjectName>.csproj; больше нигде это не сработает.

По этому вопросу можно сказать гораздо больше, но это выходит за рамки данной книги.
Те из вас, кто хочет узнать больше, могут взглянуть на эту статью, которую я написал об этом, пока
работаю над своей книгой по ASP.NET Core 2 и Angular 5 по адресу https://goo.gl/Ki6mdb.

# Использование консоли диспетчера пакетов
Если у нас возникают проблемы при использовании CLI dotnet, мы часто можем избежать неприятных головных болей, переключившись на
Консоль диспетчера пакетов, предоставляемая графическим интерфейсом Visual Studio. Чтобы активировать его, выберите «Просмотр» > «Другие Windows» > «Консоль диспетчера пакетов» в главном верхнем меню Visual Studio.
Вот полный набор команд PMC, которые можно использовать для замены ранее упомянутой dotnet.
эф:

```Add-Migration Initial -OutputDir "Data/Migrations" Update-Database```

# Проверка автоматически созданных таблиц БД
Независимо от используемого инструмента (интерфейс командной строки dotnet или консоль диспетчера пакетов), наша база данных WorldCities должна
теперь у вас есть несколько автоматически сгенерированных таблиц, содержащих данные о наших городах и странах: давайте
быстро проверьте их, прежде чем продолжить

Откройте инструмент SSMS и подключитесь к SQL Server, как мы это делали некоторое время назад, и откройте файл WorldCities.
база данных, которую мы создали ранее: таблицы «Города» и «Страны», созданные с помощью инструмента dotnet-ef.
действительно должны быть там со своими столбцами и ключами, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/7de4b9f9-fd6d-4fb2-bcad-601bdd2a89fd)

Прежде чем мы продолжим, было бы полезно сказать несколько слов, объясняющих, что на самом деле представляет собой миграция Code-First.
и преимущества, которые мы получаем от их использования.

# Понимание миграции
Всякий раз, когда мы разрабатываем приложение и определяем модель данных, мы можем быть уверены, что она изменится.
несколько раз по многим веским причинам: новые требования владельца продукта, оптимизация
процессы, фазы консолидации и т. д. Множество свойств будет добавлено, удалено или будет иметь свои
типы изменились. Скорее всего, рано или поздно мы также добавим новые сущности и/или изменим их
Модель отношений в соответствии с нашими постоянно меняющимися потребностями.
Каждый раз, когда мы делаем что-то подобное, мы также рассинхронизируем нашу модель данных с ее базовой моделью.
База данных, созданная с помощью кода. Это не будет проблемой, когда мы отлаживаем наше приложение в среде разработки, поскольку этот сценарий обычно позволяет нам воссоздать базу данных с нуля.
всякий раз, когда проект меняется.
При развертывании приложения в производстве мы столкнемся с совершенно другой историей: пока
мы работаем с реальными данными, удаление и воссоздание нашей базы данных больше не будет возможным. Это
для чего предназначена функция миграции Code-First: дать разработчику возможность изменить
схему базы данных без необходимости удалять/пересоздавать все это.

# Требуется ли миграция данных?
Миграция данных может быть очень полезной, но это не обязательная функция, и мы определенно не обязаны это делать.
используйте его, если мы этого не хотим. На самом деле, для многих это может быть довольно трудной для понимания концепцией.
разработчиков, особенно для тех, кто не особо разбирается в проектировании СУБД и/или написании сценариев. Это также может
быть очень сложным для управления в большинстве сценариев, например, в компаниях, где включена роль администратора базы данных.
лицом, находящимся ниже группы ИТ-разработчиков (например, внешним ИТ-консультантом или специалистом).
Всякий раз, когда мы не хотим использовать миграцию данных с самого начала или доходим до момента, когда мы
больше не хотим его использовать — мы можем переключиться на подход «Сначала база данных» и начать проектировать вручную,
создавать и/или изменять наши таблицы: Entity Framework Core будет отлично работать, если типы свойств
которые определены в сущностях, на 100% соответствуют соответствующим полям таблицы базы данных. Это определенно может
быть выполнено, в том числе и тогда, когда мы будем применять на практике образцы проектов, представленные в этой книге (это также
относится к проекту WorldCities), пока мы считаем, что миграция данных не нужна.
Альтернативно, мы можем попробовать и посмотреть, как пойдет. Выбор, как всегда, за вами.

# Заполнение базы данных
Теперь, когда у нас есть база данных SQL и DbContext, который мы можем использовать для чтения и записи.
Благодаря этому мы наконец готовы заполнить эти таблицы данными о наших городах мира.
Для этого нам нужно реализовать стратегию заполнения данных. Мы можем сделать это, используя один из различных
Подходы, поддерживаемые Entity Framework Core:
- Начальное значение данных модели.
- Настройка миграции вручную.
- Пользовательская логика инициализации.
Эти три метода хорошо объяснены в следующей статье, а также их собственные преимущества.
и минусы: https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding.
Поскольку нам приходится обрабатывать относительно большой файл Excel, мы собираемся использовать наиболее настраиваемый шаблон.
мы можем использовать: некоторую пользовательскую логику инициализации, основанную на выделенном контроллере .NET, который мы
может выполняться — вручную или даже автоматически — всякий раз, когда нам нужно заполнить нашу базу данных.

# Реализация SeedController
Наша реализация пользовательской логики инициализации будет опираться на совершенно новый выделенный контроллер, который
будет называться SeedController.

В обозревателе решений нашего проекта выполните следующие действия:
1. Откройте папку /Контроллеры/.
2. Если WeatherForecastController все еще существует, удалите его.
3. Щелкните правой кнопкой мыши папку /Controllers/.
4. Нажмите Добавить | Контроллер
5. Выберите API-контроллер — пустой вариант.
6. Дайте контроллеру имя SeedController и нажмите «Добавить», чтобы создать его.
После этого откройте вновь созданный файл /Controllers/SeedController.cs и посмотрите на
исходный код: вы увидите, что здесь просто пустой класс, как и ожидалось для пустого контроллера! Это
отлично, поскольку нам нужно понять некоторые ключевые понятия и, что наиболее важно, научиться правильно
перевести их в исходный код.
Помните, мы добавили класс ApplicationDbContext в файл Program.cs? Как мы должны
как мы уже знаем из главы 2 «Подготовка», это означает, что мы зарегистрировали Entity Framework.
Службы, связанные с ядром, и наш ApplicationDbContext в контейнере DI: это означает, что мы можем
теперь используйте функцию загрузки внедрения зависимостей, предоставляемую архитектурой .NET, для внедрения
экземпляр этого класса DbContext в наших контроллерах.
Вот как мы можем перевести такую концепцию в исходный код (новые строки выделены):

```Csharp
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using WorldCitiesAPI.Data;
namespace WorldCitiesAPI.Controllers
{
 [Route("api/[controller]")]
 [ApiController]
 public class SeedController : ControllerBase
 {
 private readonly ApplicationDbContext _context;
 public SeedController(ApplicationDbContext context)
 {
 _context = context;
 }
 }
}
```
Как мы видим, мы добавили частную переменную _context и использовали ее для хранения экземпляра объекта
Класс ApplicationDbContext внутри конструктора.

Такой экземпляр будет предоставлен платформой через функцию внедрения зависимостей внутри
метод конструктора SeedController.
Прежде чем эффективно использовать этот экземпляр DbContext для вставки группы сущностей в нашу базу данных, мы
нужно найти способ прочитать значения этих городов мира из файла Excel. Как мы можем сделать это?


# Импортируйте файл Excel
К счастью, есть отличная сторонняя библиотека, которая делает именно то, что нам нужно: чтение (и даже
писать!) Файлы Excel в формате Office Open XML (xlsx), что делает их содержимое доступным.
в любом приложении на базе .NET.
Имя этого замечательного инструмента — EPPlus. Его автор Ян Келлман разместил его в свободном доступе на GitHub и
NuGet по следующим URL-адресам:
- GitHub (исходный код): https://github.com/JanKallman/EPPlus.
- NuGet (пакет .NET): https://www.nuget.org/packages/EPPlus.
Как мы видим, недавно проект изменил модель лицензирования:
- До версии 4.x оно распространялось по лицензии GNU Library General Public License (LGPL) v3.0.
это означает, что нам было разрешено интегрировать его в наше программное обеспечение без ограничений, при условии, что
мы не меняли его.
- Начиная с версии 5.x и ниже используется двойная лицензия PolyForm для некоммерческой и коммерческой деятельности.
что по сути означает, что мы можем использовать его только в некоммерческих целях.
Именно по этой причине, чтобы избежать любого возможного нарушения лицензии, мы собираемся использовать
(сейчас устаревшая) 4.5.3.3, это последняя доступная версия GNU-LGPL.
Тем не менее, те, кто хочет использовать последнюю версию EPPlus с некоммерческой лицензией, могут это сделать.
добавив следующую строку в файл Program.cs:
```
ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
```
Однако версия 4.x по-прежнему достаточно жизнеспособна для целей нашего примера.

Лучший способ установить EPPlus в наш проект WorldCitiesAPI — добавить пакет NuGet с помощью
Графический интерфейс диспетчера пакетов NuGet:
1. В обозревателе решений проекта щелкните правой кнопкой мыши проект WorldCitiesAPI.
2. Выберите «Управление пакетами NuGet…».
3. Используйте вкладку «Обзор» для поиска пакета EPPlus и выберите версию, которую хотите установить.
(в нашем случае 4.5.3.3), а затем инициируйте задачу, нажав кнопку «Установить» вверху справа:

![image](https://github.com/artemovsergey/Angular/assets/26972859/a0b36b35-ab9d-4fde-a9bf-4b40ab6e9937)

Альтернативно введите следующую команду из консоли диспетчера пакетов Visual Studio:

```Install-Package EPPlus -Version 4.5.3.3```

После этого мы можем вернуться к файлу SeedController.cs и использовать замечательные функции EPPlus для
прочитайте файл Excel worldcities.xlsx.
Однако, прежде чем делать это, было бы разумно переместить этот файл так, чтобы он находился в пределах нашего примера проекта.
/Data/, чтобы мы могли прочитать ее, используя возможности файловой системы .NET, предоставляемые
Пространство имен System.IO. Пока мы там, давайте создадим подпапку /Data/Source/ и поместим ее туда.
отделите его от других файлов Entity Framework Core:

![image](https://github.com/artemovsergey/Angular/assets/26972859/7da77826-fb5e-4230-b932-fa4391a7532f)

Вот исходный код, который нам нужно добавить в наш файл SeedController.cs, чтобы читать worldcities.
xlsx и сохраните все строки в списке объектов City:

```Csharp
using System.Security;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using OfficeOpenXml;
using WorldCitiesAPI.Data;
using WorldCitiesAPI.Data.Models;
namespace WorldCitiesAPI.Controllers
{
 [Route("api/[controller]/[action]")]
 [ApiController]
 public class SeedController : ControllerBase
 {
 private readonly ApplicationDbContext _context;
 private readonly IWebHostEnvironment _env;
 public SeedController(
 ApplicationDbContext context,
 IWebHostEnvironment env)
 {
 _context = context;
 _env = env;
 }
 [HttpGet]
 public async Task<ActionResult> Import()
 {
 // prevents non-development environments from running this method
 if (!_env.IsDevelopment())
 throw new SecurityException("Not allowed");
 var path = Path.Combine(
 _env.ContentRootPath,
 "Data/Source/worldcities.xlsx");
 using var stream = System.IO.File.OpenRead(path);
 using var excelPackage = new ExcelPackage(stream);
// get the first worksheet
 var worksheet = excelPackage.Workbook.Worksheets[0];
 // define how many rows we want to process
 var nEndRow = worksheet.Dimension.End.Row;
 // initialize the record counters
 var numberOfCountriesAdded = 0;
 var numberOfCitiesAdded = 0;
 // create a lookup dictionary
 // containing all the countries already existing
 // into the Database (it will be empty on first run).
 var countriesByName = _context.Countries
 .AsNoTracking()
 .ToDictionary(x => x.Name, StringComparer.OrdinalIgnoreCase);
 // iterates through all rows, skipping the first one
 for (int nRow = 2; nRow <= nEndRow; nRow++)
 {
 var row = worksheet.Cells[
 nRow, 1, nRow, worksheet.Dimension.End.Column];
 var countryName = row[nRow, 5].GetValue<string>();
 var iso2 = row[nRow, 6].GetValue<string>();
 var iso3 = row[nRow, 7].GetValue<string>();
 // skip this country if it already exists in the database
 if (countriesByName.ContainsKey(countryName))
 continue;
 // create the Country entity and fill it with xlsx data
 var country = new Country
 {
 Name = countryName,
 ISO2 = iso2,
 ISO3 = iso3
 };
 // add the new country to the DB context
await _context.Countries.AddAsync(country);
 // store the country in our lookup to retrieve its Id later on
 countriesByName.Add(countryName, country);
 // increment the counter
 numberOfCountriesAdded++;
 }
 // save all the countries into the Database
 if (numberOfCountriesAdded > 0)
 await _context.SaveChangesAsync();
 // create a lookup dictionary
 // containing all the cities already existing
 // into the Database (it will be empty on first run).
 var cities = _context.Cities
 .AsNoTracking()
 .ToDictionary(x => (
 Name: x.Name,
 Lat: x.Lat,
 Lon: x.Lon,
 CountryId: x.CountryId));
 // iterates through all rows, skipping the first one
 for (int nRow = 2; nRow <= nEndRow; nRow++)
 {
 var row = worksheet.Cells[
 nRow, 1, nRow, worksheet.Dimension.End.Column];
 var name = row[nRow, 1].GetValue<string>();
 var nameAscii = row[nRow, 2].GetValue<string>();
 var lat = row[nRow, 3].GetValue<decimal>();
 var lon = row[nRow, 4].GetValue<decimal>();
 var countryName = row[nRow, 5].GetValue<string>();
 // retrieve country Id by countryName
 var countryId = countriesByName[countryName].Id;
 // skip this city if it already exists in the database
 if (cities.ContainsKey((
Name: name,
 Lat: lat,
 Lon: lon,
 CountryId: countryId)))
 continue;
 // create the City entity and fill it with xlsx data
 var city = new City
 {
 Name = name,
 Lat = lat,
 Lon = lon,
 CountryId = countryId
 };
 // add the new city to the DB context
 _context.Cities.Add(city);
 // increment the counter
 numberOfCitiesAdded++;
 }
 // save all the cities into the Database
 if (numberOfCitiesAdded > 0)
 await _context.SaveChangesAsync();
 return new JsonResult(new
 {
 Cities = numberOfCitiesAdded,
 Countries = numberOfCountriesAdded
 });
 }
 }
}
```
Как мы видим, мы делаем здесь много интересного. Предыдущий код содержит много комментариев.
и должен быть очень читабельным; однако было бы полезно кратко перечислить наиболее важные части:
- Мы внедрили экземпляр IWebHostEnvironment посредством внедрения зависимостей, точно так же, как мы
сделал для ApplicationDbContext, чтобы мы могли получить путь к веб-приложению и иметь возможность
чтобы прочитать файл Excel.
- Мы добавили метод действия «Импорт», который будет использовать ApplicationDbContext и пакет EPPlus для чтения файла Excel и добавления стран и городов.
- В начале реализации метода Import мы использовали экземпляр IWebHostEnvironment, чтобы определить, работаем ли мы в среде разработки или нет: если это не так,
код выдаст SecurityException. Поступая таким образом, мы не позволим никому, включая наших
пользователей — от вызова этого метода в рабочей среде, тем самым ограничивая всю задачу импорта
только разработчики.
- Страны импортируются первыми, поскольку объектам города требуется внешний ключ CountryId.
значение, которое будет возвращено, когда соответствующая страна будет создана в базе данных как
новый рекорд.
- Мы определили объект-контейнер Dictionary для хранения всех существующих стран (плюс каждую новую страну).
сразу после его создания), чтобы мы могли запросить этот список с помощью LINQ для получения CountryId
вместо выполнения большого количества запросов SELECT: эта логика также не позволит методу
вставляя одну и ту же страну несколько раз, если нам случится выполнить это более одного раза.
- Мы определили еще один объект-контейнер словаря, чтобы предотвратить вставку повторяющихся городов.
также.
- И последнее, но не менее важное: мы создали объект JSON для отображения общих результатов на экране.

Стоит отметить, что мы отправляли запросы с помощью расширения AsNoTracking EF Core.
метод, который возвращает новый запрос, в котором возвращаемые сущности не будут кэшироваться в
DbContext или ObjectContext, если они изменяются внутри кода: по сути это означает
что меньше данных будет кэшироваться и отслеживаться, что дает очевидные преимущества с точки зрения использования памяти.
Для получения дополнительной информации о методе расширения AsNoTracking посетите следующий URL-адрес:
https://docs.microsoft.com/en-us/dotnet/api/system.data.entity.
dbextensions.asnotracking

Если мы хотим поближе познакомиться с тем, как работает вся процедура импорта, мы можем поставить несколько точек останова внутри циклов if, чтобы проверить ее во время работы.
Чтобы выполнить метод действия, нажмите F5, чтобы запустить веб-приложение в режиме отладки, а затем введите команду
следующий URL-адрес в адресную строку браузера: https://localhost:40443/api/Seed/Import.
Имейте в виду, что метод импорта предназначен для импорта более чем в 230 стран и более чем 12 000 городов, поэтому эта задача
вероятно, потребуется некоторое время — от 10 до 30 секунд на средней машине разработки,
в зависимости от объема доступной оперативной памяти, производительности процессора и скорости подключения к базе данных. Его
определенно важное семя данных! Здесь мы как бы подчеркиваем рамки.

Если мы не хотим ждать, мы всегда можем присвоить внутренней переменной nEndRow фиксированное значение:
например 1000, чтобы ограничить общее количество городов (и стран), которые будут считываться и
поэтому загружен в базу данных.

В конце концов мы должны увидеть следующий ответ в окне браузера:

![image](https://github.com/artemovsergey/Angular/assets/26972859/b0fed4da-63f6-4e39-9412-e825b62a9343)

Предыдущий вывод означает, что импорт выполнен успешно: мы это сделали! Наша база данных
теперь в нем 41 001 город и 237 стран, с которыми мы можем играть.

Эти цифры могут незначительно меняться в зависимости от версии базы данных WorldCities:
на момент написания мы использовали версию 1.74, которая была обновлена в июле 2021 г., но все последующие
версия тоже должна работать — при условии, что структура файла MS Excel не изменится. Если вы
хотите использовать тот же самый файл MS Excel, который использовался при написании этой книги, вы можете найти его
в папке /Data/Source/ проекта GitHub.

В следующем разделе мы узнаем, как мы можем читать эти данные, чтобы мы могли перенести
Angular в петлю.

# Контроллеры сущностей
Теперь, когда в нашей базе данных есть тысячи городов и сотни стран, нам нужно найти
способ перенести эти данные в Angular и наоборот. Как мы уже знаем из главы 2 «Подготовка»,
эту роль играют .NET-контроллеры, поэтому мы создадим их два:
- CitiesController для обслуживания (и получения) данных городов.
- CountrysController, чтобы сделать то же самое со странами.
Давайте начнем.

# Контроллер городов
Начнем с городов. Помните, что мы делали, когда создавали SeedController? Что мы собираемся
Сейчас мы делаем то же самое, но на этот раз мы эффективно воспользуемся функциями генерации кода Visual Studio.
В обозревателе решений нашего проекта выполните следующие действия:
1. Щелкните правой кнопкой мыши папку /Controllers/.
2. Нажмите Добавить | Контроллер.
3. Выберите «Добавить контроллер API с действиями», используя параметр Entity Framework (последний
сверху, на момент написания).
4. В появившемся окне модели выберите класс модели City и ApplicationDbContext.
класс контекста данных, как показано на следующем снимке экрана. Назовите контроллер CitiesController.
и нажмите «Добавить», чтобы создать его:

![image](https://github.com/artemovsergey/Angular/assets/26972859/6976648e-0da1-4fd6-9ef5-575b7e940022)

Настройки, которые мы указали на этом этапе, будут использоваться Visual Studio для анализа наших сущностей (и
наш DbContext) и автоматически сгенерировать целый контроллер API, начиненный полезными методами.
После создания файла CitiesController.cs мы можем открыть его и посмотреть, как генератор кода проделал много полезной работы, придерживаясь при этом шаблона, аналогичного тому, который мы использовали для нашего
Класс Сидконтроллер.

Вот разбивка соответствующих методов в порядке появления:
- GetCities() возвращает массив JSON, содержащий все города в базе данных.
- GetCity(id) возвращает объект JSON, содержащий один город.
- PutCity(id, city) позволяет нам изменить существующий город.
- PostCity(city) позволяет нам добавить новый город.
- DeleteCity(id) позволяет нам удалить существующий город.
Похоже, у нас действительно есть все необходимое для нашего фронтенда. Прежде чем перейти к Angular,
давайте сделаем то же самое для наших стран.

# Контроллер стран
В обозревателе решений щелкните правой кнопкой мыши папку /Controllers/ и выполните тот же набор задач, которые мы выполняли для добавления CitiesController, за исключением имени, которое, очевидно, будет CountryController.

В конце процесса генерации кода мы получим заполненный файл CountryController.cs.
с методами действий «Получить», «Поместить», «Опубликовать» и «Удалить», которые нам нужны для обработки стран.

Прежде чем идти дальше, давайте потратим пару минут на рассмотрение некоторых методологических соображений.
относительно использования сущностей в контроллерах так, как мы только что сделали.

# Должны ли мы действительно использовать Entities?
Когда мы недавно создали наши CitiesController и CountryController, мы выбрали
существующие города и страны в качестве наших модельных классов. С точки зрения это кажется наиболее логичным.
что нужно сделать: эти классы уже содержат все, что нам нужно получить от клиента, поэтому они
идеально подходит для использования в качестве входных параметров для необходимых нам методов действий Put() и Post().
Однако использование класса модели для возврата результатов или принятия параметров от клиента вряд ли является хорошим решением.
Практика: эти классы модели предназначены для полного представления таблиц нашей базы данных, а не для интерфейса, используемого для обмена данными с клиентом. Гораздо лучший подход — сохранить объекты модели
которые взаимодействуют с базой данных, отделенной от объектов передачи данных (DTO), которые мы используем для
Методы GET, POST и PUT. Мы поговорим об этом подробнее в главе 8 «Настройка кода и службы данных».
когда мы проведем рефакторинг этих методов действий, заменив эти объекты модели на DTO, тем самым обеспечивая соблюдение
принцип единой ответственности между ними; однако в следующих нескольких главах мы можем извлечь пользу
из простоты, возникающей в результате такого «нерекомендуемого подхода», и вперед.
На этом наше путешествие по Entity Framework завершается. Теперь нам нужно соединить точки и пожинать плоды.
то, что мы посеяли, используя наш любимый интерфейсный фреймворк.

# Тестирование
Теперь, когда наши контроллеры готовы, мы можем провести быструю проверку, чтобы убедиться, что они работают должным образом.
Нажмите F5, чтобы запустить наше веб-приложение в режиме отладки, затем скопируйте следующий URL-адрес в папку браузера.
адресная строка: https://localhost:40443/api/Cities/.

Если мы все сделали правильно, то должны увидеть что-то вроде этого:

![image](https://github.com/artemovsergey/Angular/assets/26972859/6ecaadde-20a5-4692-9a98-f64a05fbeb17)

Вот и наши города!
Раз уж мы здесь, давайте также проверим страны по следующему URL-адресу: https://localhost:40443/
API/Страны/.
Вот что мы должны получить от нашего браузера:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1a8e0b67-728f-4a68-995f-10985c3827a3)

Вот они.
Наша работа на этом закончена: давайте перейдем к следующей главе, где мы увидим, как представить эти данные
передняя часть.

# Краткое содержание
Мы начали эту главу с перечисления ряда вещей, которые просто невозможно сделать без
правильный поставщик данных. Чтобы преодолеть эти ограничения, мы решили снабдить себя СУБД.
движок и постоянную базу данных для чтения и/или записи данных. Чтобы не портить то, что мы сделали
в предыдущих главах мы создали совершенно новый проект веб-приложения для решения этой проблемы.
под названием WorldCities.
Затем мы выбрали подходящий источник данных для нашего нового проекта: список городов и стран мира, которые мы
можно скачать бесплатно в удобном файле MS Excel.
Сразу после этого мы перешли к модели данных: Entity Framework Core показался очевидным выбором.
чтобы получить то, что мы хотели, поэтому мы добавили соответствующие пакеты в наш проект. Мы кратко перечислили
доступные подходы к моделированию данных и прибегли к использованию Code-First из-за его гибкости.
После этого мы создали две сущности: Город и Страна, обе из которых основаны на источнике данных.
значения, которые нам пришлось хранить в нашей базе данных, а также набор аннотаций к данным и связей.
воспользовавшись преимуществами известного подхода Entity Framework Core, основанного на соглашениях над конфигурацией.
Затем мы соответствующим образом создали наш класс ApplicationDbContext.
После того как мы создали нашу модель данных, мы оценили различные варианты настройки и развертывания нашей
Механизм СУБД: мы рассмотрели локальные экземпляры DMBS и облачные решения, такие как MS Azure,
и мы объяснили, как реализовать оба из них.
И последнее, но не менее важное: мы создали классы контроллеров .NET для работы с данными: SeedController для чтения.
файл Excel и заполните нашу базу данных, CitiesController для работы с городами и CountryController.
для работы со странами.
После выполнения всех этих задач мы запустили наше приложение в режиме отладки, чтобы убедиться, что все работает.
все еще работает как задумано. Теперь мы готовы заняться фронтенд-частью нашего приложения. В следующей главе
научимся правильно получать эти данные с сервера и модным способом доставлять их пользователю.
Angular, вот и мы!

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: веб-API, веб-API в памяти, данные.
источник, сервер данных, модель данных, поставщик данных, ADO.NET, ORM, Entity Framework Core, Code-First,
«Сначала база данных», «Сначала модель», класс сущностей, аннотации к данным, DbContext, операции CRUD, миграция данных, внедрение зависимостей, сопоставление ORM, JSON, ApiController.






















