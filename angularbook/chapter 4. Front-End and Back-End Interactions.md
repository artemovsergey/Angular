# Front-End and Back-End Interactions

Теперь, когда у нас есть минималистичное, но полностью работающее веб-приложение Angular, работающее и подключенное.
с помощью нашего ASP.NET Core API мы можем начать что-то создавать. В этой главе мы собираемся изучить
основы взаимодействия на стороне клиента и сервера: другими словами, как интерфейс (Angular) может получать данные
некоторые соответствующие данные из серверной части (ASP.NET Core) и отображать их на экране в удобочитаемом виде.
На самом деле, мы уже должны были понять суть того, как это работает, в главе 3 «Оглядка вокруг», когда
мы работали с FetchDataComponent Angular и WeatherForecastController.cs ASP.NET Core.
классы и файлы. Компонент Angular (внешний интерфейс) извлекает данные из контроллера ASP.NET (внутренняя часть).
а затем помещает его на экран браузера (UI) для отображения.
Однако контроллеры — не единственный способ для нашей серверной части ASP.NET Core передавать данные во внешний интерфейс:
мы также можем обслуживать статические файлы или использовать любое другое промежуточное программное обеспечение, предназначенное для обработки запросов и вывода.
поток ответов или какой-либо контент, если мы добавляем его в конвейер нашего приложения. Такой
Высокомодульный подход — одна из наиболее актуальных концепций ASP.NET Core. В этой главе мы будем
используйте это, вводя (и играя) встроенное промежуточное программное обеспечение, в котором мало или вообще ничего нет.
связано с контроллерами .NET, хотя он может обрабатывать запросы и ответы так же, как и они:
HealthChecksПромежуточное ПО.
Вот краткий обзор того, что мы собираемся рассказать:
- Знакомство с проверками работоспособности ASP.NET Core: что это такое и как мы можем использовать их для обучения.
некоторые полезные понятия о взаимодействии ASP.NET Core и Angular
- HealthCheckMiddleware: как правильно реализовать его в нашей серверной части ASP.NET Core,
настройте его в конвейере нашего веб-приложения и выведите сообщение в формате JSON, которое
может использоваться нашим приложением Angular
- HealthCheckComponent: как создать компонент Angular для получения структурированных данных HealthCheck из серверной части ASP.NET Core и перенести все это на внешний интерфейс в удобочитаемом виде.
мода
- Рестайлинг пользовательского интерфейса: как улучшить внешний вид нашего приложения Angular с помощью Angular Material,
библиотека компонентов пользовательского интерфейса, содержащая множество многоразовых и красивых компонентов пользовательского интерфейса.
Вы готовы? Давай сделаем это!

# Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, с
никаких дополнительных ресурсов, библиотек или пакетов.
Файлы кода для этой главы можно найти здесь: https://github.com/PacktPublishing/ASP.NETCore-6-and-Angular/tree/master/Chapter_04/.

# Знакомство с проверками работоспособности ASP.NET Core
Мы не зря назвали наш первый проект HealthCheck: веб-приложение, которое мы собираемся создать, будет действовать как
Служба мониторинга и отчетности, которая будет проверять состояние работоспособности целевого сервера и/или его инфраструктуры и отображать его на экране в режиме реального времени.
Для этого мы собираемся эффективно использовать Microsoft.AspNetCore.Diagnostics.
Пакет HealthChecks — встроенная функция платформы ASP.NET Core, впервые представленная в версии 2.2, усовершенствованная и улучшенная для выпуска ASP.NET Core 3 и все еще доступная до текущей версии .NET.
Этот пакет предназначен для того, чтобы позволить службе мониторинга проверять состояние другого работающего
сервис — например, другой веб-сервер — именно это мы и собираемся сделать.

# Добавление промежуточного программного обеспечения HealthChecks
Первое, что нам нужно сделать, это добавить промежуточное программное обеспечение HealthChecks в наше веб-приложение. Это можно сделать
открыв файл Program.cs и добавив следующие строки:

```Csharp
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddHealthChecks();
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/
swashbuckle
builder.Services.AddSwaggerGen();
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
 app.UseSwagger();
 app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.UseHealthChecks(new PathString("/api/health"));
app.MapControllers();
app.Run();
```

The /api/health parameters we passed to the UseHealthChecks middleware will create a server-side route for the health checks. It’s also worth noting that we added that middleware right before
MapControllers, so that our new route won’t be overridden by any controller that could share that
same name in the future.
We can immediately check out the new route by doing the following:
1. Press F5 so that our web application will run in debug mode
2. Navigate to the https://localhost:40443/api/health URL and hit Enter
As soon as we do that, we should be able to see something like this:

![image](https://github.com/artemovsergey/Angular/assets/26972859/4159663f-3182-4f24-a68a-de9239c428d1)

Как мы видим, наша система работоспособна: это довольно очевидно, поскольку у нас еще не определены проверки.
Как насчет добавления одного? Это то, что мы собираемся сделать в следующем разделе.

# Добавление проверки протокола управляющих сообщений Интернета (ICMP)
Первая проверка, которую мы собираемся реализовать, — одна из самых популярных: контрольное сообщение Интернета.
Проверка запроса протокола (ICMP) к внешнему хосту, также известная как PING.
Как вы, скорее всего, уже знаете, запрос PING — это довольно простой способ проверить присутствие и
следовательно, доступность сервера, к которому, как мы знаем, мы должны иметь доступ в пределах локальной области.
подключение к сети (LAN) или глобальной сети (WAN). Вкратце, это работает следующим образом:
машина, выполняющая PING, отправляет один или несколько пакетов эхо-запроса ICMP на целевой хост
и ждет ответа. Если он его получает, он сообщает время прохождения туда и обратно всей задачи; в противном случае, это
тайм-аут и сообщает об ошибке «Хост недоступен».
Ошибка «Хост недоступен» может быть вызвана рядом возможных сценариев, перечисленных здесь:
- Целевой хост недоступен.-
- Целевой хост доступен, но активно отказывается от любых соединений TCP/IP.
- Целевой хост доступен и принимает входящие соединения, но он настроен на
явно отклонять запросы ICMP и/или не отправлять обратно эхо-ответы ICMP
- Целевой хост доступен и правильно настроен для приема запросов ICMP и отправки эха.
отвечает, но соединение очень медленное или затруднено по неизвестным причинам (производительность,
большая нагрузка и т. д.), поэтому время прохождения туда и обратно занимает слишком много времени или даже истекает.
Как мы видим, это идеальный сценарий для проверки работоспособности: если мы правильно настроим целевой хост для
принять PING и всегда отвечать на него, мы определенно можем использовать его, чтобы определить, находится ли хост в состоянии
здоровый статус или нет.

# Возможные результаты
Теперь, когда мы знаем общие сценарии запроса теста PING, мы можем составить список возможных результатов следующим образом:
- Исправен: мы можем считать хост работоспособным, если PING завершается успешно и без ошибок или ошибок.
таймауты
- Деградация: мы можем считать хост деградировавшим при каждом успешном PING, но обратный путь занимает слишком много времени.
- Неработоспособен: мы можем считать хост неработоспособным в случае сбоя PING, то есть проверки
тайм-аут перед любым ответом
Теперь, когда мы определили эти три статуса, нам осталось только правильно реализовать их в рамках нашей
проверка здоровья.

# Создание класса ICMPHealthCheck.
Первое, что нам нужно сделать, это создать новый класс ICMPHealthCheck.cs в корневой папке нашего проекта.
После этого заполните его следующим содержимым:

```Csharp
using Microsoft.Extensions.Diagnostics.HealthChecks;
using System.Net.NetworkInformation;
namespace HealthCheckAPI
{
 public class ICMPHealthCheck : IHealthCheck
 {
 private readonly string Host = $"10.0.0.0";
 private readonly int HealthyRoundtripTime = 300;
 public async Task<HealthCheckResult> CheckHealthAsync(
 HealthCheckContext context,
 CancellationToken cancellationToken = default)
 {
 try
 {
 using var ping = new Ping();
 var reply = await ping.SendPingAsync(Host);
 switch (reply.Status)
 {
 case IPStatus.Success:
 return (reply.RoundtripTime > HealthyRoundtripTime)
 ? HealthCheckResult.Degraded()
 : HealthCheckResult.Healthy();
 default:
 return HealthCheckResult.Unhealthy();
 }
 }
 catch (Exception e)
 {
 return HealthCheckResult.Unhealthy();
 }
 }
 }
}
```
Как мы видим, мы реализовали интерфейс IHealthCheck, поскольку это официальный способ .NET справиться с
проверки работоспособности: для такого интерфейса требуется один асинхронный метод — CheckHealthAsync, который мы использовали.
чтобы определить, был ли запрос ICMP успешным или нет.

Код очень прост для понимания и обрабатывает три возможных сценария, которые мы определили в предыдущем разделе. Давайте рассмотрим, что можно считать хостом:
• Исправно, если на запрос PING получен успешный ответ со временем прохождения туда и обратно 300 мс или меньше.
• Деградация, если на запрос PING получен успешный ответ со временем прохождения туда и обратно более 300 мс.
• Неработоспособно, если запрос PING завершается неудачей или выдается исключение.

И последнее замечание относительно единственной строки кода, которую мы использовали для установки значения Host:
```Csharp
private readonly string Host = $"10.0.0.0";
```
Как мы видим, мы установили для Host немаршрутизируемый IP-адрес, что может показаться довольно неудобным. Мы
сделали это в демонстрационных целях, чтобы мы могли смоделировать «нездоровый» сценарий: мы
обязательно поменяю позже.
Вот и все. Наша проверка работоспособности готова к тестированию — нам просто нужно найти способ загрузить ее в
конвейер нашего веб-приложения.

# Добавление ICMPHealthCheck
Чтобы загрузить нашу проверку работоспособности ICMP в конвейер веб-приложения, нам нужно добавить ее в файл
Промежуточное программное обеспечение HealthChecks. Для этого снова откройте класс Program.cs и измените первую строку, которую мы
ранее добавлено следующим образом:

```Csharp
// ...existing code...
builder.Services.AddHealthChecks()
 .AddCheck<ICMPHealthCheck>("ICMP");
// ...existing code...
```
Стоит отметить, что, поскольку мы добавили ссылку на класс ICMPHealthCheck, который мы только что
созданный в пространстве имен HealthCheckAPI, мы также должны добавить ссылку на это пространство имен.
Здесь мы воспользуемся еще одной удобной функцией C# 10, называемой Global using: как следует из названия,
эта функция позволяет нам определить некоторые общие операторы использования, которые будут автоматически доступны.
для использования в рамках всего проекта.
Для этого нам просто нужно добавить ключевое слово global перед оператором using, который мы хотим сделать.
Глобальный. Поскольку HealthCheckAPI является пространством имен нашего проекта API, оно кажется идеальным
кандидат на это.
Вот единственная строка, которую нам нужно добавить вверху файла Program.cs:

```global using HealthCheckAPI;```

Теперь мы можем нажать F5 и попробовать. Вот что мы должны увидеть:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1ac49572-48c5-45dd-b17a-08691e270b40)

Как и ожидалось, жестко закодированный запрос ICMP к 10.0.0.0 не удался, поэтому мы получаем статус «Неработоспособно».
Это здорово, правда?
Ну, на самом деле, это не так уж и здорово. Наша проверка работоспособности действительно работает, но имеет следующее
три главных недостатка:
- Жестко запрограммированные значения: переменные Host и HealthyRoundtripTime следует передавать в качестве параметров, чтобы мы могли установить их программно.
- Неинформативный ответ: Здоровое и нездоровое не так уж и хороши – мы должны найти способ
вместо этого используйте собственное (и лучшее) выходное сообщение
- Нетипизированный вывод: текущий ответ отправляется в виде обычного текста — если мы хотим получить его с помощью
Angular, тип контента JSON определенно был бы лучше (и более удобен в использовании, как мы увидим в
проверки работоспособности в разделе Angular позже)
Давайте исправим эти проблемы по одной.

# Улучшение класса ICMPHealthCheck.
В этом разделе мы улучшим наш класс ICMPHealthCheck, добавив хост и healthRoundtripTime.
параметры, пользовательское сообщение о результатах для каждого возможного статуса и выходные данные в формате JSON.

## Добавление параметров и ответных сообщений
Откройте файл класса ICMPHealthCheck.cs и выполните следующие изменения (добавлены/изменены строки
выделены):

```Csharp
using Microsoft.Extensions.Diagnostics.HealthChecks;
using System.Net.NetworkInformation;
namespace HealthCheckAPI
{
 public class ICMPHealthCheck : IHealthCheck
 {
 private readonly string Host;
 private readonly int HealthyRoundtripTime;
 public ICMPHealthCheck(string host, int healthyRoundtripTime)
 {
 Host = host;
 HealthyRoundtripTime = healthyRoundtripTime;
 }
 public async Task<HealthCheckResult> CheckHealthAsync(
 HealthCheckContext context,
 CancellationToken cancellationToken = default)
 {
 try
 {
 using var ping = new Ping();
 var reply = await ping.SendPingAsync(Host);
 switch (reply.Status)
 {
 case IPStatus.Success:
 var msg =
 $"ICMP to {Host} took {reply.RoundtripTime} ms.";
return (reply.RoundtripTime > HealthyRoundtripTime)
 ? HealthCheckResult.Degraded(msg)
 : HealthCheckResult.Healthy(msg);
 default:
 var err =
 $"ICMP to {Host} failed: {reply.Status}";
 return HealthCheckResult.Unhealthy(err);
 }
 }
 catch (Exception e)
 {
 var err =
 $"ICMP to {Host} failed: {e.Message}";
 return HealthCheckResult.Unhealthy(err);
 }
 }
 }
}
```

Как мы видим, мы изменили пару вещей, а именно:
- Мы добавили конструктор, принимающий два параметра, которые мы хотели бы установить программно: хост
и здоровоеВремя туда и обратно. Старые жестко запрограммированные переменные теперь устанавливаются конструктором при
инициализацию, а затем использовать внутри класса (например, в основном методе).
- Мы создали различные исходящие сообщения, содержащие целевой хост, результат PING,
и длительность туда и обратно (или ошибку времени выполнения) и добавил их в качестве параметров в
HealthCheckResult возвращает объекты.

Вот и все. Теперь нам просто нужно программно установить имя хоста и healthRoundtripTime, поскольку старые жестко запрограммированные значения по умолчанию больше не используются. Для этого нам необходимо обновить нашу
настройка промежуточного программного обеспечения в файле Program.cs.

# Обновление настройки промежуточного программного обеспечения
Снова откройте файл Program.cs и измените существующую реализацию HealthChecksMiddleware.
следующим образом:

```Csharp
// ...existing code...
builder.Services.AddHealthChecks()
 .AddCheck("ICMP_01",
 new ICMPHealthCheck("www.ryadel.com", 100))
 .AddCheck("ICMP_02",
 new ICMPHealthCheck("www.google.com", 100))
 .AddCheck("ICMP_03",
 new ICMPHealthCheck($"www.{Guid.NewGuid():N}.com", 100));
// ...existing code...

```

Начнем: как мы видим, еще одним преимуществом возможности программной настройки хоста является
что мы можем добавлять проверку работоспособности ICMP несколько раз — по одному разу для каждого хоста, который мы хотим проверить.
В предыдущем примере мы воспользовались возможностью протестировать три разных хоста: www.ryadel.com, www.
google.com и тот же несуществующий хост, который мы использовали ранее, что позволяет нам эмулировать неработоспособный
статус, а также здоровые.
Теперь у нас может возникнуть соблазн нажать F5 и попробовать это... Однако, если бы мы это сделали, мы столкнулись бы с проблемой.
довольно разочаровывающий результат, как показано на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/6bd6ab44-f870-4b71-bf66-9a712eb0a5a8)

Причина этого вполне очевидна: даже если мы проводим несколько проверок, мы все равно полагаемся на
сообщение о результатах по умолчанию, которое представляет собой не что иное, как булевую сумму статусов, возвращаемых всеми
проверенные хосты. Именно поэтому, если хотя бы один из них Неработоспособен, вся проверка будет
также помечен как нездоровый.
К счастью, мы можем избежать этой суммы и получить гораздо более детализированный результат, имея дело с
Третий недостаток нашей ICMPHealthCheck: реализация специального выходного сообщения со структурой JSON.

# Реализация пользовательского выходного сообщения
Чтобы реализовать собственное выходное сообщение, нам нужно переопределить класс HealthCheckOptions. Делать
для этого добавьте новый файл CustomHealthCheckOptions.cs в корневую папку проекта и заполните его
следующее содержание:

```Csharp
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using System.Net.Mime;
using System.Text.Json;
namespace HealthCheckAPI
{
 public class CustomHealthCheckOptions : HealthCheckOptions
 {
 public CustomHealthCheckOptions() : base()
 {
 var jsonSerializerOptions = new JsonSerializerOptions()
 {
 WriteIndented = true
 };
 ResponseWriter = async (c, r) =>
 {
 c.Response.ContentType =
 MediaTypeNames.Application.Json;
 c.Response.StatusCode = StatusCodes.Status200OK;
 var result = JsonSerializer.Serialize(new
 {
 checks = r.Entries.Select(e => new
 {
 name = e.Key,
 responseTime =
 e.Value.Duration.TotalMilliseconds,
 status = e.Value.Status.ToString(),
 description = e.Value.Description
 }),
 totalStatus = r.Status,
 totalResponseTime =
r.TotalDuration.TotalMilliseconds,
 }, jsonSerializerOptions);
 await c.Response.WriteAsync(result);
 };
 }
 }
}
```

Код говорит сам за себя: мы переопределяем стандартный класс, который выводит однословный результат.
мы хотим изменить — с помощью нашего собственного класса, чтобы мы могли изменить его свойство ResponseWriter,
чтобы он выводил все, что мы хотим.
Точнее, мы хотим вывести пользовательское сообщение со структурой JSON, содержащее много полезного.
из каждого из наших чеков, перечисленных здесь:
- name: Идентифицирующая строка, которую мы указали при добавлении проверки в промежуточное программное обеспечение HealthChecks в файле Program.cs: «ICMP_01», «ICMP_02» и т. д.
- responseTime: вся продолжительность одной проверки.
- статус: индивидуальный статус чека, не путать со статусом всей проверки.
HealthCheck — то есть булева сумма всех статусов внутренних проверок.
- описание: пользовательское информационное сообщение, которое мы настроили ранее, когда уточняли
Класс ICMPHealthCheck
Все эти значения будут свойствами элементов массива, содержащихся в выходных данных JSON: по одному для каждого
проверять. Стоит отметить, что файл JSON, помимо этого массива, также будет содержать следующее:
два дополнительных свойства:
- TotalStatus: булева сумма всех статусов внутренних проверок. Неработоспособно, если есть хотя бы
Неработоспособный хост, Деградированный, если есть хотя бы деградировавший хост, и Исправный в противном случае.
- TotalResponseTime: общая продолжительность всех проверок.
Это много полезной информации, не так ли? Нам просто нужно настроить наше промежуточное программное обеспечение для их вывода.
вместо тех односложных ответов, которые мы видели раньше.

# Об ответах проверки работоспособности и кодах состояния HTTP
Прежде чем идти дальше, стоит отметить, что в предыдущем классе CustomHealthCheckOptions мы установили
Код состояния HTTP ResponseWriter в фиксированный StatusCodes.Status200OK. Есть ли причина для этого?
На самом деле он есть, и он тоже весьма важен. Промежуточное программное обеспечение HealthChecks по умолчанию
поведение возвращает либо код состояния HTTP 200, если все проверки в порядке (исправны), либо код состояния HTTP.
503, если одна или несколько проверок нокаутированы (неработоспособны). Поскольку мы перешли на вывод в формате JSON, мы
код 503 больше не нужен, так как он, скорее всего, нарушит логику пользовательского интерфейса нашего внешнего клиента, если только
правильно обработаны. Поэтому для простоты мы просто принудительно отправили ответ HTTP 200, независимо от того,
конечного результата. Мы найдем способ правильно подчеркнуть ошибки в предстоящем Angular UI.

# Настройка выходного сообщения
Откройте файл Program.cs и соответствующим образом измените следующие строки (обновленный код выделен):

```Csharp
// ... existing code
app.UseHealthChecks(new PathString("/api/health"),
 new CustomHealthCheckOptions());
// ... existing code
```
После этого мы наконец можем нажать F5 и правильно протестировать это. На этот раз мы не будем разочарованы
результат, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/808279f2-03a7-44de-823f-ce5a238d24fa)

Это довольно приятный ответ, не так ли?
Теперь каждая проверка должным образом документируется, как и общие данные о результатах, в структурированном виде.
JSON-объект. Это именно то, что нам нужно для подачи некоторых компонентов Angular, которые мы можем показать на экране.
в удобной для чтения (и модной) форме, что мы и собираемся сделать, начиная со следующего раздела.

# Проверки работоспособности в Angular
Пришло время создать компонент Angular, способный извлекать и отображать структурированные данные.
Данные JSON, которые нам удалось получить в предыдущих разделах.
Как мы знаем из главы 3 «Осмотр», компонент Angular обычно состоит из четырех отдельных файлов, а именно:
- Файл компонента (.ts), написанный на TypeScript и содержащий класс компонента вместе
со всеми ссылками на модули, функциями, переменными и т. д.
- Файл шаблона (.html), написанный на HTML и дополненный синтаксисом шаблона Angular.
который определяет архитектуру макета пользовательского интерфейса
- Файл стиля (.css), написанный на CSS и содержащий правила и определения каскадных таблиц стилей для отрисовки пользовательского интерфейса.
- Тестовый файл (.spec.ts), написанный на TypeScript и содержащий тесты, которые будет запускать Karma.

Давайте теперь воспользуемся Angular CLI для создания первых трех файлов для нового компонента HealthCheck.
(пропуская тестовый файл), как мы это делали в главе 3 «Осмотр».

Создание компонента Angular
Откройте командную строку, перейдите в папку /src/app нашего проекта Angular и введите
следующая команда:
> ng generate component HealthCheck --module=app --skip-tests
Как всегда, CLI создаст файлы компонентов и добавит необходимые ссылки в AppModule.
для нас.

Замечание: Стоит отметить, что, поскольку наше приложение имеет несколько модулей (AppModule и
AppRoutingModule), каждый раз, когда мы создаем новый модуль, нам нужно указать, какой модуль
чтобы добавить ссылки на компонент с помощью переключателя --module (как описано в главе
3, Осмотр вокруг).

Как только CLI сгенерирует новые файлы компонентов, мы сможем заполнить их следующим содержимым.

Health-check.comComponent.ts
Вот исходный код /src/app/health-check/health-check.comComponent.ts:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from ' ./../../environments/environment';
@Component({
 selector: 'app-health-check',
 templateUrl: './health-check.component.html',
 styleUrls: ['./health-check.component.css']
})
export class HealthCheckComponent implements OnInit {
 public result?: Result;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.http.get<Result>(environment.baseUrl + 'api/health').subscribe(result
=> {
 this.result = result;
 }, error => console.error(error));
 }
}
interface Result {
 checks: Check[];
 totalStatus: string;
 totalResponseTime: number;
}
interface Check {
 name: string;
 responseTime: number;
 status: string;
 description: string;
}
```

Если вам интересно, что мы там делали, вот разбивка наиболее важных вещей:
- В начале файла мы обязательно импортировали все директивы Angular, каналы, сервисы и
компоненты — одним словом, модули — которые нам нужны во всем классе.
- В объявлении класса мы явно реализовали интерфейс OnInit, добавив
реализует инструкцию OnInit для повышения безопасности типов: таким образом мы не будем рисковать печатать или писать
ошибки в хуке жизненного цикла ngOnInit.
- В конструкторе компонента мы создали экземпляр службы HttpClient, используя зависимость.
инъекционный (ДИ).
- И последнее, но не менее важное: мы определили два интерфейса для обработки ожидаемого запроса JSON.
получить от HealthChecksMiddleware: Result and Check, который мы разработали для размещения
весь результирующий объект JSON и каждый элемент внутреннего массива соответственно.
Прежде чем идти дальше, было бы полезно потратить немного драгоценного времени на рассмотрение некоторых очень важных вопросов.
темы, с которыми мы только что познакомились, реализовав предыдущий код, следующим образом:
- Imports and modules
- Dependency injection
- ngOnInit (and other lifecycle hooks)
- Constructor
- HttpClient
- Observables
- Interfaces
Поскольку мы собираемся увидеть их все в этой книге, определенно рекомендуется просмотреть их сейчас.

# Импорт и модули
Статический оператор импорта, который мы использовали несколько раз в предыдущем HealthCheckComponent:
используется для импорта привязок, экспортируемых другими модулями JavaScript.
Концепция работы с модулями началась с ECMAScript 2015 и была полностью адаптирована.
TypeScript и, следовательно, Angular. Модуль — это, по сути, набор переменных, функций, классов,
и так далее, сгруппированные внутри класса: каждый модуль выполняется в своей области, а не в глобальной.
область видимости, что означает, что все элементы, объявленные внутри нее, не видны снаружи, если они не
экспортируются явно с помощью оператора экспорта.

И наоборот, чтобы использовать переменную, функцию, класс, интерфейс и т. д., содержащиеся (и экспортированные) внутри
модуль, этот модуль необходимо импортировать с помощью оператора импорта. Это очень похоже на то, что мы
делать с пространствами имен в большинстве языков программирования (например, в C# есть операторы using).
Фактически, все директивы, каналы, сервисы и компоненты Angular также упакованы в коллекции модулей JavaScript, которые мы должны импортировать в любой класс TypeScript, когда захотим.
использовать их. Эти коллекции по сути представляют собой библиотеки модулей: мы можем легко их распознать, поскольку
их имя начинается с префикса @angular. Наш файл packages.json (файл пакета NPM), который
мы видели в предыдущих главах, содержит большинство из них.

Модули JavaScript не следует путать с собственной системой модульности Angular, основанной на
на декораторе @NgModule. Как мы уже знаем из предыдущих глав, NgModules Angular
строительные блоки — то есть контейнеры для связного блока кода, предназначенного для домена приложения,
рабочий процесс или общий набор функций. Из вышеупомянутых глав мы знаем, что каждый Angular
приложение имеет как минимум один класс NgModule, называемый корневым модулем, который обычно называется AppModule.
и находится в файле app.module.ts в корне приложения; дополнительные NgModules будут добавлены в
ближайшие главы.
К сожалению, система модулей JavaScript и система Angular NgModule используют довольно схожий подход.
словарный запас (импорт против импорта, экспорт против экспорта), который может привести к путанице, особенно
учитывая, что приложения Angular требуют, чтобы разработчик использовал их оба одновременно (и часто в
тот же файл класса). К счастью, хотя необходимость переплетать эти две системы может оказаться
поначалу это немного сложно, но со временем мы познакомимся с различными контекстами, в которых они используются.

Вот пример снимка экрана, взятый из файла класса AppModule нашего приложения HealthCheck, который должен помочь.
вы различаете две разные системы:

![image](https://github.com/artemovsergey/Angular/assets/26972859/b3c4f41f-d94d-4aae-ad6a-899ca355e4b8)

# Внедрение зависимостей (DI)
Мы уже говорили о DI несколько раз, и на то есть веские причины, поскольку это важный шаблон проектирования приложений как для ASP.NET Core, так и для Angular, причем обе платформы широко разрабатываются.
его использование для повышения их эффективности и модульности.
Чтобы объяснить, что такое DI на самом деле, мы должны сначала поговорить о том, какие зависимости есть в классе: это могут быть
определяются как службы или объекты, экземпляры которых классу необходимо преобразовать в переменные или свойства, чтобы
выполнить одну или несколько задач.

В классическом шаблоне кодирования экземпляры этих зависимостей создаются на лету внутри самого класса.
например, на этапе инициализации, например, в методе конструктора. Вот типичный пример:

```ts
public MyClass() {
 var myElement = new Element();
 myElement.doStuff();
}
```

В предыдущем примере переменная myElement является экземпляром объекта типа Element, а также
(локальная) зависимость MyClass: как мы видим, она создается в конструкторе, потому что мы чаще всего
вероятно, придется использовать его там. Отсюда мы можем либо использовать ее как локальную переменную (и позволить ей умереть в конце
области действия конструктора) или присвоить его свойству класса, чтобы еще больше продлить срок его действия и область действия.
DI — это альтернативный шаблон проектирования программного обеспечения, в котором класс запрашивает зависимости от внешних
источники, а не создавать их самостоятельно. Чтобы лучше понять эту концепцию, попробуем переписать
тот же код, что и раньше, с подходом DI, например:

```ts
public MyClass(Element myElement) {
 myElement.doStuff();
}
```

Как мы видим, нет необходимости создавать экземпляр переменной myElement, поскольку эта задача уже выполняется инжектором зависимостей — внешним кодом, который отвечает за создание внедряемых объектов.
и внедрение их в классы.
Весь шаблон кодирования DI основан на концепции инверсии управления (IoC) для решения
зависимости. Такая концепция вращается вокруг основной идеи о том, что формально, если ObjectA зависит от
ObjectB, то ObjectA не должен создавать или импортировать ObjectB напрямую, но должен предоставлять способ внедрения ObjectB.
вместо. В предыдущем примере блока кода ObjectA, очевидно, является MyClass, а ObjectB — это
экземпляр myElement.

В Angular среда DI предоставляет объявленные зависимости классу при создании экземпляра этого класса.
В предыдущем классе HealthCheckComponent мы использовали DI в методе конструктора компонента, чтобы
внедрить экземпляр службы HttpClient; как мы видим, мы также воспользовались возможностью назначить частное
модификатор доступа к ним обоим. Благодаря этому модификатору эти переменные будут доступны через
целый класс компонентов.

Замечание: Согласно соглашениям Angular, параметр, введенный без модификатора доступа, может быть только
доступ внутри конструктора; и наоборот, если он получает модификатор доступа, например частный
или общедоступный, он будет определен как член класса, следовательно, его область действия изменится на класс.
Такая техника называется областью видимости переменных, и мы собираемся часто использовать ее в нашем Angular.
компоненты с этого момента.

# ngOnInit (и другие перехватчики жизненного цикла)
Метод ngOnInit, который мы использовали в классе HealthCheckComponent, является одним из методов компонента.
методы перехвата жизненного цикла: в этом разделе мы попытаемся пролить на них некоторый свет, поскольку мы собираемся использовать
их много на протяжении всей книги.
Каждый компонент Angular имеет жизненный цикл, которым управляет Angular. Каждый раз, когда пользователь посещает представление
внутри нашего приложения платформа Angular создает и отображает необходимые компоненты (и директивы).
вместе со своими дочерними элементами, реагирует на их изменения всякий раз, когда пользователь взаимодействует с ними, и в конечном итоге уничтожает и удаляет их из объектной модели документа (DOM) при навигации пользователя.
в другом месте. Все эти «ключевые моменты» запускают некоторые методы перехвата жизненного цикла, которые Angular предоставляет
разработчиков, чтобы они могли что-то выполнить, когда каждое из них действительно происходит.
Вот список доступных хуков в порядке их выполнения (по мере возможности, поскольку некоторые из них называются
несколько раз в течение жизненного цикла компонента):
- ngOnChanges(): реагирует, когда Angular (пере) устанавливает свойства ввода, привязанные к данным. Метод получает объект SimpleChanges с текущими и предыдущими значениями свойств. Звонил раньше
ngOnInit(), а также при каждом изменении одного или нескольких входных свойств, связанных с данными.
- ngOnInit(): инициализирует директиву/компонент после того, как Angular сначала отображает привязанную к данным
свойства и устанавливает входные свойства директивы/компонента. Позвонили один раз, после первого
метод ngOnChanges().
- ngDoCheck(): обнаруживает изменения, которые Angular не может или не хочет обнаружить самостоятельно, и реагирует на них.
Вызывается во время каждого запуска обнаружения изменений, сразу после ngOnChanges() и ngOnInit().
- ngAfterContentInit(): реагирует после того, как Angular проецирует внешний контент в файл компонента.
представление/представление, в котором находится директива. Вызывается один раз после первого метода ngDoCheck().
- ngAfterContentChecked(): отвечает после того, как Angular проверяет содержимое, проецируемое в
директива/компонент. Вызывается после метода ngAfterContentInit() и каждого последующего
метод ngDoCheck().
- ngAfterViewInit(): отвечает после того, как Angular инициализирует представления компонента и дочерние представления/
представление, в котором находится директива. Вызывается один раз после первого метода ngAfterContentChecked().
- ngAfterViewChecked(): отвечает после того, как Angular проверяет представления компонента и дочерние представления/
представление, в котором находится директива. Вызывается после метода ngAfterViewInit() и каждого последующего
ngAfterContentChecked().
- ngOnDestroy(): очищает непосредственно перед тем, как Angular уничтожает директиву/компонент. Отписка
Наблюдает и отключает обработчики событий, чтобы избежать утечек памяти. Вызывается непосредственно перед Angular
уничтожает директиву/компонент.

Предыдущие методы перехвата жизненного цикла доступны для всех компонентов и директив Angular. Делать
используя их, мы можем просто добавить их в наш класс компонентов — именно это мы и сделали в
предшествующий HealthCheckComponent.
Теперь, когда мы поняли роль ngOnInit(), нам нужно потратить время, чтобы объяснить, почему мы поместили
исходный код HttpClient в методе перехвата жизненного цикла ngOnInit() вместо использования
Методstructor(): не следовало ли нам использовать его вместо этого?
Следующий раздел должен во многом помочь нам понять причину такого выбора.

# Конструктор
Как мы, скорее всего, уже знаем, все классы TypeScript имеют метод конструктор(), который будет вызываться
всякий раз, когда мы создаем экземпляр этого класса: поскольку TypeScript, безусловно, является надмножеством JavaScript,
любой метод конструктора TypeScript() будет перенесен в функцию конструктора() JavaScript.
В следующем блоке кода показан пример класса TypeScript:

```ts
class MyClass() {
 constructor() {
 console.log("MyClass has been instantiated");
 }
}
```
Это будет транспилировано в следующую функцию JavaScript:

```
function MyClass() {
 console.log("MyClass has been instantiated");
}
```
Если мы опустим конструктор в TypeScript, транспилированная функция JavaScript будет пустой; однако,
всякий раз, когда фреймворку необходимо создать его экземпляр, он все равно будет вызывать его следующим образом, независимо от
есть ли у него конструктор или нет:

```
var myClassInstance = new MyClass();
```

Понимание этого очень важно, потому что оно очень помогает нам понять разницу между
метод конструктора компонента и его хук жизненного цикла ngOnInit(), и это огромная разница,
по крайней мере, с точки зрения фазы инициализации компонента.
Весь процесс Angular Bootstrap можно разделить на два основных (и последующих) этапа:
- Создание экземпляров компонентов
- Выполнение обнаружения изменений.
Как мы можем легко догадаться, метод конструктор() вызывается на первом этапе, в то время как все
перехватчики жизненного цикла, включая метод ngOnInit(), вызываются во всем последнем.

Если мы посмотрим на эти методы с этой точки зрения, то довольно легко понять следующий ключевой момент:
понятия:
- Если нам нужно создать или внедрить некоторые зависимости в компонент Angular, мы должны использовать
метод конструктора(); на самом деле, это также единственный способ сделать это, поскольку
Конструктор — единственный метод, который вызывается в контексте инжектора Angular.
- И наоборот, всякий раз, когда нам нужно выполнить какую-либо задачу инициализации и/или обновления компонента —
например, выполнение HTTP-запроса или обновление DOM — нам обязательно следует сделать это,
используя один из перехватчиков жизненного цикла.
Метод ngOnInit(), как следует из его названия, часто является отличным выбором для инициализации компонента.
задач, поскольку это происходит сразу после установки входных свойств директивы и/или компонента. Это
почему мы использовали это для реализации нашего HTTP-запроса, используя встроенный сервис HttpClient Angular.

# HttpClient
Вероятно, возможность эффективно отправлять и получать данные JSON от наших контроллеров ASP.NET Core
самое важное требование для нашего одностраничного приложения (SPA). Мы решили сделать это с помощью
Сервис Angular HttpClient, впервые представленный в Angular 4.3.0-RC.0, который является одним из лучших
ответы, которые фреймворк может дать для выполнения работы. Именно по этой причине мы будем часто использовать его повсюду.
эта книга; однако, прежде чем это сделать, возможно, было бы целесообразно правильно понять, что это такое, почему это
лучше, чем предыдущая реализация, и как ее правильно реализовать.
Новый сервис HttpClient был представлен в июле 2017 года как улучшенная версия прежнего сервиса Angular.
HTTP-клиентский API, также известный как @angular/http или просто HTTP. Вместо замены старой версии
в пакете @angular/http команда разработчиков Angular поместила новые классы в отдельный
пакет — @angular/common/http. Они решили сделать это, чтобы сохранить обратную совместимость с
существующие базы кода, а также обеспечить медленный, но устойчивый переход на новый API.
Те, кто хоть раз использовал старый сервисный класс HTTP Angular, скорее всего, помнят его основную
ограничения, перечисленные здесь:
- JSON не был включен по умолчанию, что вынудило разработчиков явно указать его в запросе.
заголовки и данные JSON.parse/JSON.stringify при работе с API RESTful.
- Не было простого способа доступа к конвейеру запросов/ответов HTTP, что предотвращало
разработчик не может перехватывать или изменять запросы и/или ответные вызовы после их отправки.
или получено с помощью каких-то уродливых и ломающих шаблоны хаков. Фактически, расширения и
Классы-оболочки были, по сути, единственным способом настройки сервиса, по крайней мере, в глобальном масштабе.
- Не было встроенной строгой типизации для объектов запроса и ответа, хотя это можно было бы
решается путем использования JSON в качестве интерфейсов в качестве обходного пути.
Хорошая новость заключается в том, что новый HttpClient делает все это и многое другое; другие функции включают в себя
поддержка тестируемости и лучшая обработка ошибок через API, полностью основанные на Observables.

Замечание: Стоит отметить, что размещение службы HttpClient внутри самого компонента не является
хорошая практика, потому что это часто приводит к ненужному повторению кода среди различных
компоненты, которым необходимо выполнять HTTP-вызовы и обрабатывать их результаты. Это известный
проблема, которая сильно влияет на приложения производственного уровня, которые, вероятно, потребуют постобработки.
полученных данных, обработку ошибок, добавление логики повторов для борьбы с прерывистым подключением и т. д.
Чтобы лучше справляться с такими сценариями, настоятельно рекомендуется разделить логику доступа к данным.
и роль представления данных, инкапсулируя первую в отдельный сервис, который может
затем внедряться во все компоненты, которые в этом нуждаются, стандартизированным и централизованным способом.
способ. Мы поговорим об этом подробнее в главе 8 «Настройка кода и службы данных», где мы
в конечном итоге заменить несколько реализаций HttpClient и централизовать их источник
код в нескольких службах передачи данных.

# Observables
Observables — мощная функция управления асинхронными данными; они являются основой ReactiveX
Библиотека JavaScript (RxJS), которая является одной из обязательных зависимостей Angular. Те, кто знаком
с ES6 Promises можно рассматривать как улучшенную версию этого подхода.
Наблюдаемый объект можно настроить для отправки литеральных значений, структурированных значений, сообщений и событий.
синхронно или асинхронно: значения можно получить, подписавшись на сам наблюдаемый объект.
используя хук метода подписки, что означает, что весь поток данных обрабатывается внутри него — до тех пор, пока мы
программно выбрать отказ от подписки. Самое замечательное в этом подходе то, что независимо от
выбранный подход (синхронный или асинхронный), частота потоковой передачи и тип данных, программный интерфейс для
прислушиваться к ценностям и перестать слушать — одно и то же.
Огромные преимущества наблюдаемых являются причиной того, что Angular широко использует их, когда
работа с данными. Если мы внимательно посмотрим на исходный код нашего HealthCheckComponent, мы увидим, как
мы также используем их, когда наша служба HttpClient извлекает данные с сервера и сохраняет
результат в локальной переменной this.result. Такая задача выполняется вызовом двух последовательных методов:
get<Result>() и subscribe().
Попробуем резюмировать, что они делают, следующим образом:
• get<Result>(): Как следует из названия, этот метод отправляет стандартный HTTP-запрос нашему ASP.
NET Core HealthChecks для получения результирующего объекта ответа JSON. Этот метод
нужен параметр URL, который мы создаем на лету, добавляя строку-литерал hc (тот же
строка, которую мы установили ранее в файле Program.cs) к базовому URL-адресу веб-API.
• subscribe(): этот метод вызывает наблюдаемую величину, возвращаемую вызовом get, которая выполнит
два совершенно разных действия сразу после результата и/или в случае ошибки. Излишне говорить, что все это
будет выполняться асинхронно, то есть приложение не будет ждать результата и продолжит выполнение.
остальная часть кода.

# Интерфейсы
Теперь, когда мы знаем, как работает сервис Angular HttpClient, мы имеем полное право задать себе вопрос:
пара вопросов: зачем мы вообще используем эти интерфейсы? Разве мы не можем просто использовать необработанные данные JSON?
отправленные промежуточным программным обеспечением ASP.NET Core HealthChecks, которое мы определили ранее, потребляя их как
анонимные объекты JavaScript?
Теоретически мы можем, так же как и выводить необработанный JSON из контроллеров, вместо того, чтобы создавать
все классы ViewModel, как мы это сделали. Однако в хорошо написанном приложении мы всегда должны сопротивляться
искушение обрабатывать необработанные данные JSON и/или использовать анонимные объекты по ряду веских причин:
• Мы выбрали TypeScript вместо JavaScript, поскольку хотим работать с определениями типов:
Анонимные объекты и свойства являются полной противоположностью; они ведут к способу JavaScript
делать что-то, чего мы хотели избежать в первую очередь.
• Анонимные объекты (и их свойства) нелегко проверить: нам не нужны наши данные.
элементы будут подвержены ошибкам или вынуждены иметь дело с отсутствующими свойствами.
• Анонимные объекты вряд ли можно использовать повторно. Другими словами, они не выиграют от множества удобных
Функции Angular, такие как сопоставление объектов, которые требуют, чтобы наши объекты были реальными экземплярами
интерфейс и/или тип.
Первые два аргумента очень важны, особенно если мы хотим создать готовое к использованию приложение; какой бы простой ни казалась на первый взгляд наша задача разработки, мы никогда не должны думать, что мы
могут позволить себе потерять этот уровень контроля над исходным кодом нашего приложения.
Третья причина также имеет решающее значение, если мы хотим использовать Angular в полной мере. Если это так,
использование неопределенного массива свойств, например необработанных данных JSON, практически исключено; и наоборот, использование структурированного интерфейса TypeScript, возможно, является самым легким способом работы с
структурированные данные JSON строго типизированным образом.

Замечание: Стоит отметить, что мы не добавили оператор экспорта в наш интерфейс: мы это сделали.
специально, поскольку мы собираемся использовать это только в классе HealthCheckComponent.
Если нам понадобится изменить это поведение в будущем, например, создать внешний
data service — нам придется добавить этот оператор (и, возможно, переместить каждый из них в
отдельный файл), чтобы мы могли импортировать их в другие классы.

# health-check.component.html
Вот исходный код /src/app/health-check/health-check.comComponent.html:

```html
<h1>Health Check</h1>
<p>Here are the results of our health check:</p>
<p *ngIf="!result"><em>Loading...</em></p>
<table class='table table-striped' aria-labelledby="tableLabel" *ngIf="result">
 <thead>
 <tr>
 <th>Name</th>
 <th>Response Time</th>
 <th>Status</th>
 <th>Description</th>
 </tr>
 </thead>
 <tbody>
 <tr *ngFor="let check of result.checks">
 <td>{{ check.name }}</td>
 <td>{{ check.responseTime }}</td>
 <td class="status {{ check.status }}">{{ check.status }}</td>
 <td>{{ check.description }}</td>
 </tr>
 </tbody>
</table>
```

Как мы уже знаем из главы 3 «Осмотр», часть шаблона нашего компонента Angular
по сути, это HTML-страница, содержащая таблицу с некоторой директивой Angular. Прежде чем двигаться дальше, давайте
более пристальный взгляд, а именно:
• ngIf: это структурная директива, которая условно включает HTML-элемент контейнера на основе
по значению логического выражения, указанному после знака равенства (=): когда такое выражение
оценивается как true, Angular отображает элемент; в противном случае это не так. Его можно связать с
блок else, который (если он присутствует) будет отображаться, когда выражение принимает значение false или null. В
предыдущий блок кода, мы используем его внутри элемента <table>, чтобы он появлялся только тогда, когда
внутренняя переменная результата (которую мы определили ранее в классе компонента) перестает быть
undefined, что произойдет после получения данных с сервера.
• ngFor: еще одна структурная директива, которая отображает шаблон для каждого элемента, содержащегося в данном
коллекция. Директива размещается на элементе, который становится родителем клонированного элемента.
шаблоны. В предыдущем блоке кода мы используем его внутри основного элемента <table> для создания
и покажите элемент <tr> (строку) для каждого элемента проверки в массиве result.checks.
{{ check.name }}, {{ check.responseTime }} и т. д. Это называются интерполяцией и
может использоваться для включения рассчитанных строк в текст между тегами элементов HTML и/или
внутри присвоений атрибутов. Другими словами, мы можем использовать их в качестве заполнителей для нашего класса.
значения свойств переменных. Как мы видим, разделителями по умолчанию для интерполяции являются двойные
фигурные скобки, {{ и }}.

health-check.component.css
Вот исходный код /src/app/health-check/health-check.comComponent.css:

```css
.status {
 font-weight: bold;
}
.Healthy {
 color: green;
}
.Degraded {
 color: orange;
}
.Unhealthy {
 color: red;
}
```
Здесь особо нечего отметить; просто немного ванильного CSS для оформления шаблона компонента. Обратите внимание, как
мы немного поигрались со стилем ячейки таблицы, которая будет содержать статус различных проверок.
Настоятельно рекомендуется выделить их как можно сильнее, поэтому мы сделали их жирными и цветными.
соответствующий типу статуса: зеленый — «Здоров», оранжевый — «Ухудшен» и красный — «Нездоров».

Замечание: Из-за ограниченности места мы не сможем много говорить о стилях CSS в этой книге: мы
просто примет как должное, что средний веб-программист знает, как справиться с
простые определения, селекторы и правила оформления, которые мы будем использовать в наших примерах.
Тем, кто хочет (или нуждается) больше узнать о CSS и CSS3, рекомендуется
взгляните на этот замечательный онлайн-руководство: https://developer.mozilla.org/en-US/docs/
Веб/CSS.

# Несколько слов о стилизации компонентов Angular
На самом деле Angular дает нам как минимум два способа определения пользовательских правил CSS для наших компонентов:
• Установка их в свойстве стилей в метаданных компонента.
• Загрузка стилей из внешних файлов CSS путем добавления свойства styleUrls в компонент.
метаданные
Оба предыдущих подхода основаны на свойствах, которые необходимо добавить в @ компонента.
Декоратор компонентов; последний используется шаблоном по умолчанию, который мы рассматривали еще в главе.
3, «Осмотр», и в большинстве случаев предпочтительнее, поскольку позволяет разделить структуру HTML.
из стиля CSS.
Если бы мы хотели перейти к первому варианту, вот как нам следует вместо этого установить свойство стилей:

```ts
@Component({
 selector: 'app-health-check',
 templateUrl: './health-check.component.html',
 styles: ['
 .status { font-weight:bold; }
 .Healthy { color: green; }
 .Degraded { color: orange; }
 .Unhealthy { color: red; }
 ']
})
```

Единственное реальное преимущество такого подхода заключается в том, что для него не требуется добавление отдельного файла CSS.
что может сделать его достаточно жизнеспособным для небольших и легких компонентов, не требующих особого стиля:
тем не менее, в подавляющем большинстве случаев свойство styleUrls определенно является подходящим вариантом.

Замечание: Само собой разумеется, что мы лишь прикоснулись к огромной и сложной теме;
однако, по понятным причинам нехватки места, в остальном мы не пойдем далеко дальше этого
книги.
Тем, кто хочет узнать больше о стилизации компонентов, настоятельно рекомендуется пройти
посмотрите официальное руководство Angular: https://angular.io/guide/comComponent-styles.

Теперь, когда наш компонент готов, нам нужно правильно добавить его в наше приложение Angular.

# Добавление компонента в приложение Angular

Поскольку мы сгенерировали компонент с помощью Angular CLI, нам не нужно обновлять app.module.
ts: все необходимые изменения были автоматически выполнены CLI.
Однако, если мы хотим, чтобы наш новый компонент был доступен нашим пользователям в нашем приложении Angular, мы
необходимо внести минимальные изменения в следующие файлы:
- приложение-routing.module.ts
- nav-menu.comComponent.ts
- nav-menu.comComponent.html

Давайте сделаем это.

# Модуль AppRoutingModule
Поскольку мы создали специальный AppRoutingModule для управления маршрутизацией, нам также необходимо обновить его, выполнив
добавление новой записи маршрутизации, чтобы наши пользователи могли перейти на эту страницу.
Откройте файл /src/app/app-routing.module.ts и добавьте следующие выделенные строки:

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { FetchDataComponent } from './fetch-data/fetch-data.component';
import { HealthCheckComponent } from './health-check/health-check.component';
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'fetch-data', component: FetchDataComponent },
 { path: 'health-check', component: HealthCheckComponent }
];
@NgModule({
 imports: [RouterModule.forRoot(routes)],
 exports: [RouterModule]
})
export class AppRoutingModule { }
```

То, что мы здесь сделали, нетрудно понять: мы добавили специальный маршрут проверки работоспособности, который будет обрабатывать навигацию к нашему новому компоненту. После этого нам просто нужно добавить его в наш NavMenuComponent.
чтобы наши пользователи могли видеть и использовать его в пользовательском интерфейсе приложения, чем мы сейчас и займемся.

# NavMenuComponent
Добавление нашего нового пути навигации по компонентам в RoutingModule было необходимым шагом, чтобы убедиться, что наши пользователи
способны достичь этого; однако нам также необходимо добавить ссылку, по которой наши пользователи смогут нажать. Поскольку NavMenuComponent
— это компонент, который обрабатывает пользовательский интерфейс навигации, нам нужно выполнить там некоторые действия, например
хорошо.
Откройте файл /src/app/nav-menu/nav-menu.comComponent.html и добавьте следующие выделенные строки:

```html
<header>
 <nav>
 <a [routerLink]="['/']">Home</a>
 |
 <a [routerLink]="['/fetch-data']">Fetch Data</a>
 |
 <a [routerLink]="['/health-check']">Health Check</a>
 </nav>
</header>
```

Теперь, когда наш новый компонент добавлен в наше приложение Angular, нам просто нужно его протестировать.


# Тестирование
Чтобы увидеть наш новый HealthCheckComponent во всей красе, нам просто нужно сделать следующее:
- Нажмите F5, чтобы запустить проект в режиме отладки.
- Когда загрузится домашний вид, нажмите новую ссылку «Проверка работоспособности» в левом верхнем углу меню навигации.
Если мы все сделали правильно, браузер должен загрузить новое представление «Проверка работоспособности», которое должно выглядеть
так же, как на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/a2ace458-6aa7-4385-820d-16ea1ac4b669)

Похоже, что мы это сделали!
Наша проверка работоспособности запущена и с гордостью показывает результаты трех установленных нами ICMP-запросов.
в рамках HealthChecksMiddleware нашего ASP.NET Core.
Тем не менее, мы должны признать, что внешний вид такого стола не так уж и хорош. И остальная часть
приложение выглядит не лучше. Тот факт, что мы почти не используем стили, начинает сказываться.
точки зрения визуального опыта.
По этой причине, прежде чем двигаться дальше, возможно, было бы полезно потратить некоторое драгоценное время на решение
такие проблемы навсегда. Давайте проясним: мы не собираемся превращать наши «минималистичные» HTML-шаблоны в
потрясающий макет: мы просто добавим несколько незначительных настроек пользовательского интерфейса с помощью бесплатного и открытого исходного кода.
известный интерфейсный фреймворк

# Рестайлинг пользовательского интерфейса
Вы можете подумать, что мы имеем в виду Bootstrap, поскольку он один из наиболее часто используемых.
выбор при создании адаптивных, ориентированных на мобильные устройства интерфейсных приложений. Однако мы не собираемся
используйте его: вместо этого мы выберем Angular Material, поскольку он изначально интегрируется с большинством приложений Angular, предоставляет широкий набор компонентов пользовательского интерфейса и обеспечивает отличный внешний вид, возможно, даже лучше, чем Bootstrap.

# Представляем Angular Material

Angular Material — это библиотека компонентов пользовательского интерфейса, которая реализует дизайн материалов в Angular. Как и ты
скорее всего, уже знаете, что Material Design — это язык дизайна пользовательского интерфейса, разработанный Google в 2014 году, который
основное внимание уделяется использованию макетов на основе сетки, адаптивной анимации, переходов, отступов и эффектов глубины.
такие как освещение и тени.

Материальный дизайн был представлен дизайнером Google Матиасом Дуарте 25 июня 2014 года.
на конференции Google I/O 2014. Чтобы дизайнеры пользовательского интерфейса ознакомились с его
основные концепции, он объяснил, что «в отличие от настоящей бумаги, наш цифровой материал может расширяться и
реформируйте разумно. Материал имеет физические поверхности и края. Швы и тени обеспечивают
имеется в виду то, к чему можно прикоснуться».
Основная цель Material Design — создать новый язык пользовательского интерфейса, сочетающий принципы
хорошего дизайна с техническими и научными инновациями, чтобы обеспечить последовательное
взаимодействие с пользователем не только на всех платформах и приложениях Google, но и на любых других
веб-приложения, стремящиеся принять такие концепции. Язык был обновлен в 2018 году.
обеспечивая большую гибкость и расширенные функции настройки на основе тем.

По состоянию на 2020 год Material Design используется почти во всех веб-приложениях и инструментах Google, включая Gmail,
YouTube, Google Drive, Google Docs, Sheets, Slides, Google Maps и все приложения под брендом Google Play.
приложения, а также большинство элементов пользовательского интерфейса ОС Android и Google. Такое широкое распространение также включает
Angular, которому предоставлен специальный пакет NPM, который можно добавить в любой проект на основе Angular для реализации Material Design в любом приложении Angular; этот пакет называется @angular/
материал и включает в себя собственные элементы пользовательского интерфейса, комплект разработчика компонентов (CDK), набор анимаций,
и другие полезные вещи.

# Установка углового материала
Установка Angular Material — довольно простой процесс: лучше всего следовать официальным инструкциям.
со следующего URL-адреса:
https://material.angular.io/guide/getting-started
Что мы и сделаем прямо сейчас.
Начнем с открытия окна командной строки: после этого перейдите в корень проекта Angular.
папку — точно так же, как мы делаем, когда добавляем новый компонент — и введите следующую команду:
```ng add @angular/material@13.0.1```
Запустится мастер установки Angular Material, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/3bce3e22-3c8e-4be7-ae0a-2e56080fa632)

Angular CLI автоматически найдет наиболее подходящую/совместимую версию, в зависимости от версии.
самого CLI. Тем не менее, настоятельно рекомендуется использовать версию, использованную в этой книге (см. выше).
Мастер задаст следующие вопросы:
- Выберите предварительно созданное название темы: Индиго/Розовый.
- Настроить глобальные стили оформления Angular Material? Да
- Настроить анимацию браузера для Angular Material? Да

На самом деле, мы можем выбрать любую тему по умолчанию и отказаться от анимации браузера, если она нам не нужна: однако добавление глобальных стилей типографики
настоятельно рекомендуется, поскольку у нас нет дополнительных CSS-фреймворков — и
типографика браузера по умолчанию не очень хороша.

Вот что мастер сделает с нашим приложением Angular:
- Добавьте необходимые пакеты NPM и зависимости в файл package.json: @angular/material.
и @angular/cdk
- Добавьте BrowserAnimationModule в файл /src/app/app.module.ts (если мы ответили ДА
на вопрос «добавить анимацию в браузере»)
- Добавьте шрифт Roboto и значок Material Design в файл /src/index.html.
- Добавьте CSS-класс mat-typography в элемент <body> файла/src/index.html.
- Добавьте базовые стили в файлы /src/style.css.
После установки Angular Material мы можем приступить к изменению стиля наших компонентов.

# Добавление панели инструментов MatToolbar
Первый компонент, который мы обновим, — это NavMenuComponent, который выглядит не так уж хорошо. Точнее, мы заменим его базовый HTML-шаблон на собственный компонент Angular Material.
предназначен для размещения меню навигации: MatToolbar.
1. Для его установки нам необходимо выполнить следующие задачи:
2. Добавьте необходимые ссылки в класс AppModule.
Соответствующим образом обновите HTML-шаблон NavMenuComponent.
Давай сделаем это.

# Обновление AppModule
Откройте файл /src/app/app.module.ts и добавьте следующие выделенные строки чуть ниже уже
существующий оператор импорта AppRoutingModule:

```ts
import { AppRoutingModule } from './app-routing.module';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';
```
Затем добавьте следующие выделенные строки в конец массива импорта @NgModule:

```ts
imports: [
 BrowserModule,
 HttpClientModule,
 AppRoutingModule,
 BrowserAnimationsModule,
 MatButtonModule,
 MatIconModule,
 MatToolbarModule
 ]
```
Как мы видим, мы добавили три модуля Angular Material:
- MatButtonModule, который добавляет поддержку компонентов кнопок.
- MatIconModule, позволяющий использовать значки материалов.
- MatToolbarModule, основной компонент, который мы хотим добавить.
  
Мы собираемся использовать все три из них, чтобы обновить наш файл шаблона NavMenuComponent.

# Обновление HTML-шаблона NavMenuComponent
Откройте файл /src/app/nav-menu/nav-menu.comComponent.html и замените все существующее содержимое.
со следующим кодом:

```html
<header>
 <mat-toolbar color="primary">
 <button mat-icon-button [routerLink]="['/']">
 <mat-icon>
 home
 </mat-icon>
 </button>
 <a mat-flat-button color="primary" [routerLink]="['/fetch-data']">
 Fetch Data
 </a>
 <a mat-flat-button color="primary" [routerLink]="['/health-check']">
 Health Check
 </a>
 </mat-toolbar>
</header>
```

Как мы видим, мы заменили нашу предыдущую реализацию, созданную вручную, которая была основана на простом
HTML-элемент <nav> — новый, основанный на трех только что добавленных модулях:
- Синтаксис модуля Angular Material довольно прост для понимания: каждый компонент имеет свой
собственный тег; например, вся панель инструментов определяется тегом <mat-toolbar>.
- Этим компонентам можно задать стиль с использованием стандартных классов CSS или пользовательских директив атрибутов.
особый вид директивы, специально предназначенный для изменения внешнего вида или поведения DOM.
элементы и компоненты Angular: например, ссылки меню оформляются с помощью директивы mat-flatbutton, которая применяет некоторые классы CSS к самому элементу <a>, чтобы он выглядел так:
кнопка.

# Первый тестовый запуск
Давайте сделаем небольшой перерыв в кодировании и стилизации, чтобы посмотреть, что мы только что сделали. Нажмите F5, чтобы запустить наш проект(ы)
в режиме отладки и посмотрите, выглядит ли наше новое меню навигации верхнего уровня лучше, чем раньше.

Если вы не видите обновленное приложение Angular после нажатия F5, вы можете попробовать закрыть его вручную.
все окна консоли (включая то, где запущен ngcc), а затем запустите
проекты снова.

Если мы все сделали правильно, то должны увидеть что-то вроде того, что показано на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/e0249853-0e0b-43fe-ab6d-8106c89c30ae)

Совсем неплохо! Возможно, немного отступов, примененных к содержимому под меню, сделало бы его более ровным.
лучше: давайте быстро добавим его, прежде чем двигаться дальше.
Откройте файл /src/app/app.comComponent.css и добавьте следующее правило CSS:

```css
.container {
 padding: 5px 10px;
}
```
Это создаст небольшой интервал между содержимым и меню, а также между содержимым.
и внешние границы страницы.
Теперь мы можем продолжить стилизацию других наших компонентов.

# Игра с (S)CSS

Следующее, что мы собираемся сделать, — это улучшить внешний вид наших HTML-таблиц.
их у нас два: один в DataFetchComponent, который мы переместили туда из AppComponent
некоторое время назад — и еще один в HealthCheckComponent.
Однако прежде чем сделать это, мы воспользуемся возможностью заменить существующие файлы CSS на SCSS.
файлы, чтобы мы могли использовать расширенный синтаксис CSS, предоставляемый мощным препроцессором Sass.

Подождите минуту? Что такое Сасс?
Если вы чувствуете желание задать этот вопрос, прочитайте следующий раздел: если вы уже знаете, что
о чем мы говорим, можете пропустить это, так как вы наверняка уже знаете эту историю

# Знакомство с Sass
Если вы работали с таблицами стилей в течение последних нескольких лет, то наверняка вы о них не слышали.
Сасс; однако ради тех, кто еще этого не сделал, давайте поговорим об этом несколько слов.
Однако прежде чем перейти к этому, мы должны кратко представить концепцию таблиц стилей.

Этот раздел в основном предназначен для тех, кто никогда раньше не использовал Sass. Если у вас есть некоторые
уже имеете опыт работы с Sass или чувствуете, что вам больше ничего не нужно знать о том, почему
мы воспользуемся им, вы можете полностью пропустить его и перейти к следующему разделу: Замена CSS.
с Сассом.

# Краткая история CSS
Язык таблиц стилей, также известный как язык стилей, — это язык программирования, используемый для определения правил проектирования пользовательского интерфейса уровня представления структурированного документа. Мы можем думать об этом как о скине или теме, которая
мы можем применить к логическому элементу (структурированному документу) изменить его внешний вид. Например, мы
можно сделать его синим, красным или желтым; мы можем сделать персонажей больше или меньше и тоньше или
Шире; мы можем изменить интервал, выравнивание и порядок текста; и так далее.
Использование специальных языков таблиц стилей дает разработчикам возможность разделить уровень представления.
код и структуру (соответственно, JavaScript и HTML) из правил проектирования пользовательского интерфейса, тем самым обеспечивая соблюдение
Принцип разделения ответственности (SoC) внутри самого уровня представления.
Когда дело доходит до веб-страниц, веб-приложений и всего остального, что в основном использует HTML, XHTML,
XML и других документах на основе языка разметки, наиболее важным языком таблиц стилей, несомненно, является CSS.
Это было 17 декабря 1996 года, когда Консорциум Всемирной паутины (W3C) опубликовал официальный документ W3C.
Рекомендация CSS для языка таблиц стилей, который будет известен как CSS1. CSS2 вышел меньше, чем
два года спустя (май 1998 г.), а его исправленная версия CSS2.1 заняла значительно больше времени (июнь 2011 г.).
Начиная с CSS3, все стало усложняться, поскольку W3C отказался от подхода к единой, монолитной спецификации, разделив ее на отдельные документы, называемые модулями, каждый из которых
следуя своей собственной истории публикаций, принятия и рекомендаций. Начиная с 2012 года, с
четыре из них (медиа-запросы, пространства имен, селекторы и цвет) опубликованы в качестве официальных рекомендаций и имеют полную обратную совместимость с CSS2.1. CSS3 быстро стал наиболее распространенной таблицей стилей.
языковой стандарт для разработки новых веб-сайтов.

# Пример CSS-кода
Независимо от версии, каждая из них добавляет новые функции, сохраняя при этом обратную совместимость с
предыдущий(ие) CSS придерживается следующего синтаксиса:

```ts
<selector> [sub-selector] [sub-sub-selector] {
 <property>: <value>;
 <another-property>: <value>;
 <yet-another-property>: <value>;
 /* ... and so on... */
}
This translates as follows:
.container {
 padding: 5px 10px;
}
```

Мы видели этот код недавно; это класс-контейнер, который мы только что добавили в файл /src/app/app.
компонент.css, чтобы добавить отступы к содержимому нашего приложения.
Этот класс по сути говорит, что любой элемент HTML с назначенным классом контейнера будет иметь отступы.
5 пикселей (сверху и снизу) и 10 пикселей (слева и справа).
Чтобы назначить класс CSS элементу HTML, мы можем использовать атрибут class следующим образом:

```html
<div class="container">
 [...some content...]
</div>
```
Если атрибут class уже присутствует, можно назначить дополнительные классы CSS, разделив их.
с одним пробелом:

<div class="контейнерotherClass someOtherClass">
  [...некоторый контент...]
</div>

# Что такое Sass и зачем его использовать?
Sass — препроцессор каскадных таблиц стилей; мы можем думать об этом как о «улучшетеле синтаксиса» для файлов CSS,
позволяя нам делать ряд вещей, которые CSS не поддерживает (пока), точно так же, как это могут делать PHP и/или ASP.
для HTML-страницы.
Следующая диаграмма должна помочь нам лучше понять концепцию:

![image](https://github.com/artemovsergey/Angular/assets/26972859/2c1b9dcf-100a-413e-8aab-cc9dc1e8a9dd)

Это основные преимущества использования препроцессора гипертекста вместо написания необработанных HTML-страниц;
мы говорим о PHP, но то же самое касается веб-форм ASP.NET, Razor и практически всего остального.
Ниже приведены преимущества использования Sass вместо написания необработанных файлов CSS:

![image](https://github.com/artemovsergey/Angular/assets/26972859/60ff100a-cdec-4601-9573-d4257ecd16ab)

Как мы видим, они служат одной и той же цели с точки зрения помощи, улучшения и расширения возможностей.
усилия по развитию.
Переключиться со статических таблиц стилей на динамические так же просто, как переключиться с
статические HTML-страницы в динамические страницы PHP или ASP; они оба имеют вложенный метаязык, который может
расширить базовый статический язык с помощью чистой обратной совместимости. Это означает, что действительный CSS
файл также является допустимым файлом Sass, точно так же, как действительный файл HTML также является допустимым файлом PHP или ASP.
Существуют также некоторые ключевые различия между препроцессорами гипертекста и препроцессорами таблиц стилей.
наиболее важным является то, как с ними справляются веб-серверы.
Препроцессоры гипертекста, такие как PHP и ASP, компилируются веб-сервером при каждом запросе; тот
веб-сервер компилирует их на лету, а затем передает полученный HTML-код для каждого запроса/ответа.
поток. И наоборот, файлы препроцессора таблицы стилей обычно перед этим компилируются в стандартные файлы CSS.
публикуется; другими словами, веб-сервис не знает о существовании этих файлов, так как
просто обслуживает полученный результат, скомпилированный с помощью CSS.
Это также означает, что использование препроцессора таблицы стилей не повлияет на производительность сервера.
если только мы не решим установить какие-нибудь экспериментальные и пока крайне неэффективные обработчики, расширения, модули или клиентские скрипты, которые будут компилировать исходные файлы на лету.

ВАЖНОЕ ПРИМЕЧАНИЕ. С этого момента мы будем считать само собой разумеющимся, что читатель имеет приличное
знание файлов CSS, синтаксиса, селекторов и их общего использования на страницах HTML. Если
это не так, мы настоятельно рекомендуем вам изучить основные концепции CSS и Sass.
прежде чем идти дальше. Следующие URL-адреса могут существенно помочь новичкам понять суть
Отличительные черты обоих языков:
CSS: https://www.w3.org/Style/CSS/learning.
Сасс: https://sass-lang.com/guide

# Замена CSS на Sass
Как мы знаем из главы 3 «Оглядываясь вокруг», поведение Angular CLI по умолчанию заключается в создании стандартных
Файлы CSS: чтобы выполнить переключение с CSS на SCSS, первое, что нам нужно сделать, — это изменить такое поведение.
Для этого откройте файл angular.json и добавьте следующие выделенные строки в существующий файл:
раздел "схемы":

```json
"schematics": {
 "@schematics/angular:application": {
 "strict": true
 },
 "@schematics/angular:component": {
 "style": "scss"
 }
}
```
Вот и все: с этого момента всякий раз, когда мы будем использовать Angular CLI для создания наших компонентов,
Файлы Sass (SCSS) будут созданы вместо стандартных файлов CSS.
Единственное, что нам нужно сделать сейчас, это переименовать все расширения файлов таблиц стилей нашего существующего
компонентов, а также обновление ссылок styleUrls в файлах TypeScript компонента: в обоих
случаях нам нужно переключиться с .css на .scss.

Переименование файлов таблиц стилей наших компонентов — довольно простая задача.
это можно легко сделать в графическом интерфейсе Visual Studio через обозреватель решений: нам просто нужно
добавьте букву «s» ко всем файлам с расширениями .css, присутствующим в /src/app.
папку (и подпапки), а затем обновите ссылку на этот файл в соответствующем файле .ts.
Те, кому нужны дополнительные рекомендации, могут ознакомиться с проектом GitHub для этой главы, где
все файлы были обновлены с правильным расширением.

После этого во всем проекте останется единственный файл с расширением .css — /src/.
Файл Styles.css — тот, который содержит правила CSS, действительные для всего приложения. Мы можем переименовать
это также в .scss; однако, поскольку это не файл таблицы стилей компонента, нам также необходимо обновить его
соответствующие ссылки в файле angular.json следующим образом:

```json
"styles": [
 "./node_modules/@angular/material/prebuilt-themes/indigo-pink.css",
 "src/styles.scss"
]
```
ВАЖНО: Обязательно обновите все ссылки (их две). Кроме того, будьте уверены
вручную закрыть все окна консоли и снова перезапустить проекты после обновления
файл angular.json.

После этого мы наконец можем использовать синтаксис Sass (вместе с синтаксисом CSS) в любом месте нашего проекта Angular.

# Рестайлинг таблиц
Давайте немедленно воспользуемся преимуществами синтаксиса Sass, изменив стиль наших существующих HTML-таблиц. С тех пор, как мы
если их два, мы можем определить глобальный класс в наших новых (переименованных) файлах /src/styles.scss,
в котором размещены правила таблицы стилей для всего приложения:
Откройте этот файл и добавьте следующие выделенные строки в существующий код:

```css
html, body { height: 100%; }
body { margin: 0; font-family: Roboto, "Helvetica Neue", sans-serif; }
table {
border: 0px;
 border-spacing: 0px;
 border-collapse: collapse;
 tr {
 border-bottom: 1px solid #dddddd;

 &:nth-child(even) {
 background-color: #f4f4f4;
 }

 th, td {
 text-align: left;
 padding: 5px 10px;
 }
 }
}
```
После этого сохраните файл и нажмите F5, чтобы проверить новый стиль таблицы. Чтобы увидеть это, нам нужно перейти к нашему
FetchDataComponent и к нашему HealthCheckComponent, что можно сделать с помощью нашего нового Angular
Меню материалов.
Если мы все сделали правильно, мы сможем увидеть новые правила CSS, влияющие на таблицы обоих
компоненты, как на следующих скриншотах:

![image](https://github.com/artemovsergey/Angular/assets/26972859/0a811ee3-5a39-4c62-9a96-cd4e7f04fb97)

Вот и все: наш пользовательский интерфейс все еще не идеален, но мы можем быть довольны этими улучшениями, по крайней мере, на данный момент.

Стоит отметить, что вместо изменения стиля существующих HTML-таблиц мы могли бы использовать
компонент MatTable Angular Material, чтобы полностью заменить их: делая это, мы
получил бы множество мощных функций, таких как фильтрация, сортировка, разбиение на страницы и так далее.
Однако для простоты мы выбрали «более быстрый» подход, который также
позволил нам интегрировать Sass в наш проект Angular. Мы будем широко использовать
MatTable в следующих главах, когда нам придется иметь дело с более сложными
(и чрезмерно заполненные) таблицы.

Теперь, когда мы изучили основы, мы перейдем к совершенно другой теме. Однако читатель
уже должен иметь возможность (и это настоятельно рекомендуется) расширить этот пример проекта за счет большего количества
сложные сценарии использования, такие как:
- Создайте дополнительные проверки, используя тот же подход, который мы использовали для ICMPHealthCheck.
класс: проверка соединения с СУБД, разрешения на чтение/запись для UNC-папки или ресурсов,
наличие/отсутствие сторожевых файлов, подключение к Интернету, использование процессора/памяти/пропускной способности,
и так далее.
- Активно обрабатывать различные состояния нашего приложения в зависимости от различных состояний здоровья.
результаты проверки: показать сообщение нашим пользователям, если приложение не работает должным образом, отключить
компоненты приложения, которые не работают, переключиться на запасной вариант, отправить
оповещения по электронной почте администраторам и т. д.
- Расширьте возможности HealthChecksMiddleware с помощью LiteXHealthChecks, легкого, но
мощный пакет NuGet с рядом модульных надстроек, которые позволяют нам проверять статус
компонента приложения, например серверной службы, базы данных или некоторого внутреннего состояния.
Улучшите внешний вид нашего приложения Angular, применив дополнительные правила стиля с помощью
Синтаксис CSS и/или Sass.
Тем не менее, мы только что получили некоторые важные знания об Angular Material и Sass, двух очень
полезные инструменты, которые мы обязательно будем использовать в следующих главах.

# Краткое содержание
Давайте потратим минуту на краткое повторение того, что мы узнали в этой главе. Прежде всего, мы признали
что контроллеры .NET — не единственный инструмент в сарае: на самом деле любое промежуточное ПО практически
способен обрабатывать цикл HTTP-запросов и ответов — пока он находится в конвейере нашего приложения.
Чтобы продемонстрировать такую концепцию, мы представили HealthChecksMiddleware — изящную встроенную программу ASP.NET Core.
функция, которую можно использовать для реализации служб мониторинга состояния, и затем мы ее реализовали. Мы
начали с серверной части ASP.NET Core, совершенствуя нашу работу, пока не смогли создать JSON-структурированный
выход; затем мы перешли на Angular, где научились правильно получать его с помощью компонента и
покажите его на экране через пользовательский интерфейс браузера на основе HTML.
И последнее, но не менее важное: мы потратили ценное время на улучшение пользовательского интерфейса и UX нашего приложения Angular,
добавление пары мощных функций макетирования: Angular Material и Sass. В конце концов, финал
Результат был достаточно хорошим, чтобы вознаградить нас за нашу тяжелую работу.
Для приложения HealthCheck этого достаточно, по крайней мере, на данный момент. Начиная со следующей главы, мы
верните стандартный шаблон контроллеров .NET и посмотрите, как мы можем использовать его для изучения чего-то нового.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: Мониторинг работоспособности, Проверки работоспособности,
HealthChecksMiddleware, HealthCheckOptions, HTTP-запросы, HTTP-ответы, ICMP, PING, ResponseWriter, JSON, JsonSerializerOptions, Компоненты, Маршрутизация, Модули, AppModule, HttpClient,
ngIf, ngFor, Директивы, Структурные директивы, Интерполяции, NgModule, Система модулей Angular, Система модулей JavaScript (импорт/экспорт), Angular Material, Каскадные таблицы стилей (CSS), Sass.















































