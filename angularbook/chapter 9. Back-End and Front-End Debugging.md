# Back-End and Front-End Debugging

Одной из наиболее важных особенностей всех языков программирования (таких как C#) и большинства языков сценариев (таких как JavaScript) являются возможности отладки, которые они предлагают разработчикам.

«Если отладка — это процесс устранения ошибок в программном обеспечении, то программирование должно быть
процесс их введения».
- Э. В. Дейкстра

Термин «отладка» повсеместно относится к процессу поиска и решения проблем и/или проблем, обычно называемых ошибками, которые мешают программе или приложению работать должным образом. В
Вкратце, можно сказать, что процесс отладки позволяет разработчику лучше понять, как
исходный код выполняется «под капотом» и почему он дает такой результат.
Отладка — очень важный навык для любого разработчика, возможно, такой же, как и само программирование; это
навык, который все разработчики должны осваивать с помощью теории, практики и опыта, точно так же, как программирование.
Лучший способ выполнить эти задачи — использовать отладчик — инструмент, позволяющий запустить целевую программу.
программу в контролируемых условиях. Это позволяет разработчику отслеживать свои операции в режиме реального времени.
остановка их с помощью точек останова, их пошаговое выполнение, просмотр значений базового типа,
и так далее. Расширенные функции отладчика также позволяют разработчику получать доступ к содержимому памяти, процессору и
регистры, действия устройств хранения и т. д., просматривая или изменяя их значения для воспроизведения конкретных
условия, которые могут быть причиной рассматриваемых проблем.
К счастью, Visual Studio предоставляет набор отладчиков, которые можно использовать для отслеживания любого приложения .NET. Хотя большинство его функций были разработаны для отладки части управляемого кода нашей
app (например, наши файлы C#), некоторые из них — при правильной настройке — могут быть очень полезны для отслеживания
клиентский код также.

В этой главе мы узнаем, как их использовать, а также различные инструменты отладки, встроенные в
некоторые веб-браузеры, такие как Chrome, Firefox и Edge, для постоянного мониторинга и контроля.
весь рабочий процесс HTTP нашего приложения WorldCities.
По практическим соображениям процесс отладки разделен на два отдельных раздела:
- Серверная часть, где задачи отладки в основном выполняются с помощью Visual Studio и
Основные инструменты .NET
- Интерфейсная часть, где важную роль играют как Visual Studio, так и веб-браузер.
Последний раздел главы посвящен внутреннему ведению журналов с использованием API ведения журналов .NET и
сторонний поставщик журналов (Serilog).
К концу этой главы мы научимся правильно отлаживать веб-API нашего веб-приложения.
а также наши компоненты Angular, используя различные инструменты отладки и журналирования, предоставляемые Visual
Studio и ASP.NET Core в полной мере.

Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, а также
следующие внешние библиотеки:
- Пакет NuGet EFCore.BulkExtensions.
- Пакет NuGet Serilog.AspNetCore.
- Пакет NuGet Serilog.Settings.Configuration.
- NuGet-пакет Serilog.Sinks.MSSqlServer.
Файлы кода для этой главы можно найти здесь: https://github.com/PacktPublishing/ASP.NETCore-6-and-Angular/tree/master/Chapter_09/.

# Внутренняя отладка
В этом разделе мы узнаем, как использовать функции отладки, предлагаемые средой Visual Studio, чтобы взглянуть на жизненный цикл нашего веб-приложения на стороне сервера и понять, как мы можем
должным образом устранить некоторые потенциальные недостатки.
Однако прежде чем сделать это, давайте потратим пару минут на то, чтобы посмотреть, как это работает в различных доступных операционных системах.

# Винда или Линукс?
Для простоты мы будем считать само собой разумеющимся, что мы используем версию Visual Studio Community, Professional или Enterprise для операционных систем Windows. Однако, поскольку .NET и .NET Core
были разработаны как кроссплатформенные, для тех, кто хочет отладить, есть как минимум два варианта.
в других средах, таких как Linux или macOS:
- Использование Visual Studio Code — облегченной альтернативы Visual Studio с открытым исходным кодом.
для Windows, Linux и macOS с полной поддержкой отладки
- Использование Visual Studio благодаря инструментам контейнеров Docker, доступным начиная с Visual Studio 2017.
и встроен в Visual Studio начиная с версии 2019 (16.3).

В этой книге для простоты мы будем придерживаться среды Windows, используя таким образом
набор отладчиков Visual Studio, доступный для Windows.

# Основы
Мы будем считать само собой разумеющимся, что каждый, кто читает эту книгу, уже знает все основы отладки.
функции, предлагаемые Visual Studio, например следующие:
- Режимы конфигурации сборки «Отладка» и «Выпуск».
- Точки останова и способы их установки и использования.
- Вход в программу и выход из нее
- Окна «Наблюдение», «Стек вызовов», «Локальные» и «Немедленные».

В следующем разделе мы кратко представим некоторые расширенные параметры отладки, которые могут быть полезны в
наши конкретные сценарии.

# Условные точки останова
Условная точка останова — это полезная функция отладки, которая часто неизвестна (или используется недостаточно)
автор) большинство разработчиков; он действует как обычная точка останова, но срабатывает только при определенных условиях.
которые встретились.

Чтобы установить условную точку останова, просто нажмите на контекстный значок «Настройки» (тот, что с шестеренкой).
оно появляется, когда мы создаем стандартную точку останова, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c4847026-a47e-41ae-a121-00c64965c404)

Как только мы это сделаем, внизу окна появится панель, показывающая ряд возможных
условные настройки, которые мы можем настроить для этой точки останова:

![image](https://github.com/artemovsergey/Angular/assets/26972859/3cfdac0a-30bb-46a1-83a9-1996d01b0aa1)

Как мы видим, доступно множество возможных настроек (Условия, Действия и т. д.). Давайте
посмотрим, как мы можем их использовать.

# Условия
Если мы установим флажок «Условия», мы сможем определить условие кода, которое будет запускать
точка останова.
Чтобы лучше объяснить, как это работает, давайте проведем быстрый отладочный тест:
1. В обозревателе решений выберите проект WorldCitiesAPI и откройте файл /Controllers/.
Файл CitiesController.cs.
2. Установите точку останова на последней строке метода GetCity() (того, который возвращает город в
клиент, как только он будет найден — подробности см. на следующем снимке экрана).
3. Щелкните значок «Настройки», чтобы получить доступ к панели «Настройки точки останова».
4. Установите флажок Условия.
5. В двух раскрывающихся списках выберите «Условное выражение» и «Истина».
6. Введите следующее условие в текстовое поле справа: city.Name == «Москва».
После этого наша панель настроек точки останова должна выглядеть так, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/6480fb1e-d436-4fee-b205-827d72c80712)

Как мы видим, наше состояние создано; интерфейс позволяет нам добавлять другие условия, а также
выполнить определенные Действия, установив флажок под ним.

# Действия
Функцию «Действия» можно использовать для отображения специального сообщения в окне «Вывод» (например, «Эй, мы
в настоящее время редактируем Москву из нашего приложения Angular!) и/или выберите, должно ли выполнение кода
продолжать или нет. Если действие не указано, точка останова будет вести себя нормально, без выдачи сообщений и остановки выполнения кода.
Раз уж мы здесь, давайте также воспользуемся возможностью протестировать функцию «Действия». Активируйте флажок, затем
введите сообщение из предыдущего абзаца в самое правое текстовое поле. После этого наша точка останова
Панель настроек должна выглядеть так, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/42fafa92-6d60-4230-90de-2a5abea98d72)

Мы только что создали нашу первую условную точку останова; давайте быстро проверим это, чтобы увидеть, как это работает.

# Тестирование условной точки останова
Чтобы проверить, что происходит при достижении точки останова, запустите приложение WorldCities в режиме отладки (нажав
F5), перейдите к представлению «Города», отфильтруйте таблицу, чтобы найти город Москва, и щелкните его название, чтобы
войти в режим редактирования.
Если все сделано правильно, наша условная точка останова должна сработать и вести себя так, как
следующим образом:

![image](https://github.com/artemovsergey/Angular/assets/26972859/85606fdc-9ee1-44e4-8ade-b52c884b480b)

Как мы видим, окно вывода также заполнено нашим пользовательским сообщением. Если мы сейчас
повторите тот же тест с любым другим городом с другим названием (например, Рим, Прага или Новый
Йорк), та же самая точка останова вообще не сработает; ничего не случится.

Стоит отметить, что в нашей базе данных WorldCities есть два города под названием Москва:
столица России и город в штате Айдахо, США. Само собой разумеется, что наше условное
Точка останова сработает на них обоих, поскольку она проверяет только свойство Name. Если
мы хотели ограничить его область действия только российским городом, нам следует уточнить условное выражение
выражение, которое также соответствует CityId, CountryId или любому другому подходящему свойству.

Пока все хорошо; Давайте двигаться дальше.

# Окно вывода
В предыдущем разделе мы говорили об окне вывода Visual Studio, которое мы использовали для написания
пользовательское сообщение всякий раз, когда была достигнута наша условная точка останова.

Если у вас есть некоторый опыт работы с отладчиком Visual Studio, вы знаете, насколько важно это окно для понимания того, что происходит за кулисами. В окне вывода отображается
сообщения о состоянии различных функций IDE, что означает, что большинство промежуточных программ .NET, библиотек,
и пакеты записывают туда свою соответствующую информацию, точно так же, как мы это делали с нашей условной точкой останова.

Чтобы открыть окно «Вывод», выберите «Вид | Вывод из главного меню или
нажмите Ctrl+Alt+O.

Если мы посмотрим, что произошло в окне «Вывод» во время только что выполненного теста, мы увидим:
можно увидеть кое-что интересное:

![image](https://github.com/artemovsergey/Angular/assets/26972859/bf79f147-35b1-4f92-9147-d4ad3b9f99cf)

Окно вывода заполнено информацией, поступающей из EntityFrameworkCore, включая фактические SQL-запросы, используемые для сопоставления свойств сущности City и содержимого базы данных; однако у нас нет информации
из любого другого источника. Почему мы отслеживаем только сообщения о состоянии, поступающие от Microsoft.
Пространство имен EntityFrameworkCore?
Причина такого поведения довольно проста: все зависит от уровня LogLevel, который мы установили для
различные пространства имен (или префиксы пространств имен) в файле appsettings.json.
Если мы откроем файлы appsettings.Development.json нашего проекта WorldCitiesAPI, мы увидим, что наш
текущие настройки LogLevel для префикса пространства имен Microsoft.AspNetCore в настоящее время имеют значение «Предупреждение».

```json
"Logging": {
 "LogLevel": {
 "Default": "Information",
"Microsoft.AspNetCore": "Warning"
 }
 }
```
Мы кратко видели эти настройки LogLevel еще в главе 3 «Осмотр», когда говорили о
файлы appsettings.json и appsettings.<Среда>.json. Однако мы не потратили время
объясняя, как на самом деле работают такие настройки и как мы можем использовать их, чтобы повлиять на окно вывода.
– и любой другой поставщик журналов, который мы, возможно, захотим использовать: давайте сделаем это сейчас.

# Типы уровней журнала
Параметры LogLevel определяют минимальный уровень регистрации для любого данного пространства имен (или префикса пространства имен). Этот уровень соответствует одному из семи возможных значений, поддерживаемых платформой, каждое из которых
имеющие отличительное имя и соответствующий инкрементальный номер: Trace (0), Debug (1), Information.
(2), Предупреждение (3), Ошибка (4), Критическое (5) и Нет (6).
Вот краткий обзор каждого из них:
- Трассировка: внутренние действия и значения приложения — обычно полезны только для отладки.
операции низкого уровня. Это редко используемый уровень журнала, поскольку он часто содержит конфиденциальные данные.
например, контроль ключей шифрования или другой «конфиденциальной» информации, которая не должна быть разглашена.
запоминается или просматривается: по этой причине его использование в производстве крайне не рекомендуется и может
привести к серьезным проблемам с безопасностью.
- Отладка: интерактивный анализ и информация об отладке. Это журналы, которые следует отключить в
производственных средах, поскольку они могут содержать информацию, которая не подлежит разглашению.
- Информация: Информационные сообщения, то есть описывают события, относящиеся к нормальному поведению системы.
- Предупреждение: ненормальное или неожиданное поведение, но такое, которое не приводит к зависанию приложения.
прекратить бег.
- Ошибка: информация сохраняется, когда текущий поток выполнения прерывается из-за ошибки: это
означает, что это сообщения об ошибках, связанных с текущей деятельностью, не путать с
ошибки выполнения всего приложения (см. Критические).
- Критический: события, описывающие необратимый сбой приложения.
- Нет: значение-заполнитель, которое мы можем использовать, если хотим полностью отключить ведение журнала («не регистрировать
что-либо").
Все события и/или сообщения о состоянии, создаваемые любой библиотекой ASP.NET Core, попадают в одну из семи категорий, указанных выше: настройки LogLevel позволяют нам выбирать, что «захватывать», а что игнорировать.

Важно понимать, что значение, присутствующее в настройке LogLevel, определяет
минимальный уровень для регистрации: например, если мы установим для LogLevel значение «Предупреждение», система будет
регистрировать предупреждения, ошибки и критические события и сообщения о состоянии.

Теперь, когда мы понимаем, как работают настройки LogLevel, давайте еще раз взглянем на настройки нашего приложения.
Настройки LogLevel Development.json и придают смысл этим значениям:
- Для пространства имен по умолчанию установлено значение «Информация», что означает, что мы хотим видеть всю информацию,
Предупреждения, ошибки и критические события и сообщения о состоянии для всех пространств имен, в которых нет
более конкретные правила.
- Для пространства имен Microsoft.AspNetCore установлено значение «Предупреждение». Это означает, что мы хотим видеть все
Предупреждения, ошибки и критические события и сообщения о состоянии для всего, что связано с пространством имен, которое начинается с Microsoft.AspNetCore.
Стоит отметить, что специализированный ключ Microsoft.AspNetCore переопределяет значение общего ключа.
Ключ по умолчанию, который действует как всеобъемлющий для любого неопределенного пространства имен: если мы учтем, что мы почти
использовались только встроенные промежуточные программы и службы, принадлежащие пространству имен Microsoft.AspNetCore,
теперь мы можем легко понять, почему мы не видим ни одного из них в окне вывода: мы явно указали
сказал нашему приложению не показывать их.
В то же время пространства имен Microsoft.EntityFrameworkCore начинаются с другого префикса: for
именно по этой причине они вернутся к поведению по умолчанию и, следовательно, получат настройки информации,
и именно поэтому мы видим их и все их информационные события и сообщения о состоянии (в дополнение к
«Предупреждение», «Ошибка» и «Критическая»).

# Тестирование уровня журнала
Чтобы быстро продемонстрировать, как работают настройки LogLevel, давайте проведем быстрый тест.
Откройте файл appsettings.Development.json и добавьте Microsoft.EntityFrameworkCore в
Ключ JSON LogLevel с использованием тех же настроек пространства имен Microsoft.AspNetCore следующим образом:

```json
"Logging": {
 "LogLevel": {
 "Default": "Debug",
 "Microsoft.AspNetCore": "Warning",
 "Microsoft.EntityFrameworkCore": "Warning"
 }
 }
```
Сразу после этого снова запустите наш проект(ы) и выполните те же самые действия, пока они не сработают.
условную точку останова «Москва», которую мы установили ранее.

На этот раз окно вывода будет более кратким, чем раньше, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/dc94b297-34c9-40b3-b509-00a4f209b55b)

Теперь давайте настроим все параметры LogLevel на информацию следующим образом:

```json
"Logging": {
 "LogLevel": {
 "Default": "Information",
 "Microsoft.AspNetCore": "Information"
 }
 }
```
После этого снова запустите проект и выполните еще один тест до условной точки останова «Москва»,
затем еще раз взгляните на окно вывода:

![image](https://github.com/artemovsergey/Angular/assets/26972859/98812938-76fc-4357-a1a9-b397d6b63fe2)

Как мы видим, сейчас из разных источников поступает информация.
включая следующее:
- Microsoft.AspNetCore.Hosting.Diagnostics: промежуточное ПО ASP.NET Core, предназначенное для
обработка исключений, страницы отображения исключений и диагностическая информация. Он обрабатывает разработчика
промежуточное программное обеспечение страницы исключений, промежуточное программное обеспечение обработчика исключений, промежуточное программное обеспечение информации времени выполнения,
промежуточное программное обеспечение кодовой страницы состояния и промежуточное программное обеспечение страницы приветствия. Короче говоря, это король
Окно вывода при отладке веб-приложений.
- Microsoft.AspNetCore.Mvc.Infrastructure: пространство имен, которое обрабатывает (и отслеживает)
действия контроллера и реагирует на промежуточное программное обеспечение .NET Core MVC.
- Microsoft.AspNetCore.Routing: промежуточное программное обеспечение ASP.NET Core, которое обрабатывает статическую и динамическую маршрутизацию, например, для всех конечных точек URI нашего веб-приложения.
- Microsoft.EntityFrameworkCore: промежуточное ПО ASP.NET Core, которое обрабатывает соединения.
к источнику данных; например, наш SQL-сервер, о котором мы подробно говорили в главе
5. Модель данных с ядром Entity Framework.
Вся эта информация по сути представляет собой последовательный журнал всего, что происходит во время выполнения нашего веб-приложения. Мы можем многому научиться из жизненного цикла ASP.NET Core, просто выполнив управляемую пользователем
действие и чтение его.

# Настройка окна вывода
Излишне говорить, что интерфейс Visual Studio позволяет нам фильтровать вывод и/или выбирать уровень
Детализация полученной информации.

Чтобы настроить, что показывать, а что скрывать, выберите «Отладка | Параметры главного меню, затем перейдите
в окно вывода из пункта древовидного меню справа. На этой панели мы можем выбрать (или отменить выбор)
количество выходных сообщений: сообщения об исключениях, сообщения о загрузке модуля/сообщения о выгрузке модуля,
Сообщения о выходе из процесса, сообщения о пошаговой фильтрации и т. д.:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5bdba688-d44e-4207-9ae1-c123248dbbac)

Теперь, когда мы поняли суть выходных данных серверной отладки, давайте переключим внимание на одно из промежуточных программ, которое, возможно, требует особого внимания: Entity Framework (EF) Core.

# Отладка EF Core
Если мы посмотрим на окно вывода сразу после запуска одного из наших веб-приложений в режиме отладки, мы увидим:
должен иметь возможность видеть кучу SQL-запросов, написанных в виде обычного текста. Это SQL-запросы, созданные EF Core на основе наших лямбда-выражений, выражений запросов, объектов IQueryable и выражений.
деревья в действительные запросы T-SQL.
Вот строка выходной информации, создаваемая промежуточным программным обеспечением Microsoft.EntityFrameworkCore.
содержащий SQL-запрос, используемый для получения города Москвы (собственный SQL-запрос выделен):

```
Microsoft.EntityFrameworkCore.Database.Command: Information: Executed DbCommand
(36ms) [Parameters=[@__p_0='?' (DbType = Int32), @__p_1='?' (DbType = Int32)],
CommandType='Text', CommandTimeout='30']
SELECT [t].[Id], [t].[Name], [t].[Lat], [t].[Lon], [c0].[Id] AS [CountryId],
[c0].[Name] AS [CountryName]
FROM (
 SELECT [c].[Id], [c].[CountryId], [c].[Lat], [c].[Lon], [c].[Name]
 FROM [Cities] AS [c]
 WHERE [c].[Name] LIKE N'Moscow%'
 ORDER BY [c].[Name]
 OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY
) AS [t]
INNER JOIN [Countries] AS [c0] ON [t].[CountryId] = [c0].[Id]
ORDER BY [t].[Name]
```
Неплохо, правда? Эти SQL-запросы в виде открытого текста могут быть очень полезны для определения того, является ли EF Core
хорошо или нет справляется с преобразованием наших лямбда-выражений или выражений запросов LINQ в SQL с точки зрения
производительность.

# SQL-запрос GetCountries()
Давайте попробуем использовать тот же метод для получения SQL-запроса, соответствующего
Реализация метода GetCountries() в CountryController, которую мы усовершенствовали в ходе главы
8, «Настройки кода и службы данных», включая количество городов.
Вот фрагмент исходного кода:

```Csharp
return await ApiResult<CountryDTO>.CreateAsync(
 _context.Countries.AsNoTracking()
 .Select(c => new CountryDTO()
 {
 Id = c.Id,
 Name = c.Name,
 ISO2 = c.ISO2,
 ISO3 = c.ISO3,
 TotCities = c.Cities!.Count
 }),
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder,
 filterColumn,
 filterQuery);
```
Чтобы увидеть, как он был преобразован в T-SQL, выполните следующие действия:
1. Нажмите F5, чтобы запустить веб-приложение в режиме отладки.
2. Перейдите к представлению «Страны».
3. Посмотрите на появившееся окно вывода (там поможет поиск TotCities).

Вот SQL-запрос, который мы должны там найти:

```sql
SELECT [c].[Id], [c].[Name], [c].[ISO2], [c].[ISO3], (
 SELECT COUNT(*)
 FROM [Cities] AS [c0]
 WHERE [c].[Id] = [c0].[CountryId]) AS [TotCities]
FROM [Countries] AS [c]
ORDER BY [c].[Name]
OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY
```
Это неплохо; EF Core преобразовал наше выражение LINQ в SQL с помощью подзапроса, что является хорошим выбором.
с точки зрения производительности. Часть OFFSET SQL-запроса вместе с параметрами DBCommand.
упомянутый в предыдущем фрагменте кода, обрабатывает нумерацию страниц и гарантирует, что мы получаем только
строки, которые мы просили.
Однако окно вывода Visual Studio — не единственный способ просмотреть эти SQL-запросы.
мы можем предоставить себе еще лучшую альтернативу, добавив еще один отличный сторонний NuGet
package, как мы увидим в следующих разделах.

# Получение кода SQL программным способом
Окно вывода достаточно хорошо для большинства сценариев, но что, если мы хотим получить код SQL?
из IQueryable<T> программно? Такая опция может быть очень полезна для отладки (или условной отладки) некоторых частей нашего приложения, особенно если мы хотим автоматически сохранять эти SQL-запросы.
за пределами окна вывода (например, файл журнала или служба агрегатора журналов).
Для достижения такого результата мы можем сделать одно из следующих действий:
- Создайте специальную функцию, которая сможет делать это с помощью System.Reflection, .NET.
пространство имен, содержащее типы, которые можно использовать для получения информации о сборках, модулях, членах, параметрах и других объектах в управляемом коде путем изучения их метаданных.
- Установите сторонний пакет NuGet, который уже делает это.
Иногда может быть полезно (и поучительно) написать что-то вручную вместо того, чтобы полагаться на существующую библиотеку; однако когда дело доходит до задач System.Reflection, это часто не так, поскольку
практика извлечения информации из непубличных членов может легко привести к нестабильным обходным путям кода,
который часто также очень сложно поддерживать.
Именно по этой причине вместо того, чтобы изобретать велосипед, давайте установим EFCore.BulkExtensions NuGet.
пакет для нашего проекта WorldCitiesAPI. Как всегда, мы можем сделать это с помощью графического интерфейса Visual Studio (Управление
NuGet Packages) или интерфейс консоли диспетчера пакетов следующим образом:

```
PM>Install-Package EFCore.BulkExtensions
```
В этой книге мы будем использовать версию 6.2.3, которая является последней на момент написания и обеспечивает
полная поддержка Entity Framework Core 6.

После установки пакета мы сможем использовать новое расширение ToParameterizedSql().
метод из любого из наших существующих объектов IQueryable<T>, просто добавив ссылку на файл EFCore.
BulkExtensions.IqueryableExtensions в пространстве имен класса.
Такое пространство имен предоставляет несколько методов расширения для типа IQueryable<T>: очень удобный
подход к расширению функциональности этого типа без создания нового производного типа и изменения
исходный тип или создание статической функции, которая будет явно требовать его в качестве ссылочного параметра.

Давайте посмотрим, как мы можем реализовать метод расширения ToParameterizedSql() в нашем ApiResult.cs.
class, в котором выполняется большинство наших объектов IQueryable<T>.

# Реализация метода ToParameterizedSql()
В обозревателе решений выберите файл /Data/ApiResult.cs, откройте его для редактирования и добавьте следующее:
строки существующей реализации метода CreateAsync (новые строки выделены):

```Csharp
using Microsoft.EntityFrameworkCore;
using System.Linq.Dynamic.Core;
using System.Reflection;
using EFCore.BulkExtensions;
// ...existing code...
 source = source
 .Skip(pageIndex * pageSize)
 .Take(pageSize);
 // retrieve the SQL query (for debug purposes)
 var sql = source.ToParametrizedSql();
 var data = await source.ToListAsync();
```

Как мы видим, мы добавили одну переменную для хранения результатов метода ToParameterizedSql непосредственно перед вызовом метода ToListAsync(), который требует выполнения результирующего
SQL-запрос.

Давайте быстро проверим это, чтобы увидеть, как это работает. Поставьте точку останова на строке класса ApiResult.cs,
сразу под новыми строками, которые мы добавили ранее. После этого нажмите F5, чтобы запустить веб-приложение.
в режиме отладки, затем перейдите к представлению «Страны». Подождите, пока достигнет точки останова, затем переместите
Наведите курсор мыши на переменную sql и щелкните значок лупы.
После всего этого мы сможем увидеть SQL-запрос в окне визуализатора текста, как показано на рисунке.
на следующем скриншоте.

![image](https://github.com/artemovsergey/Angular/assets/26972859/9bf2df5a-9464-4711-be69-d01963cb4b31)

Теперь мы знаем, как быстро просмотреть SQL-запросы, созданные EF Core, из нашего IQueryable<T>.
объекты.

# Использование директивы препроцессора #if
Если нас беспокоит снижение производительности задачи метода ToParameterizedSql(), мы определенно можем настроить предыдущий код, используя директиву препроцессора #if следующим образом:

```Csharp
#if DEBUG
 // retrieve the SQL query (for debug purposes)
 var sql = source.ToParametrizedSql();
 // TODO: do something with the sql string
#endif
```

Как мы видим, мы обернули вызов метода ToParameterizedSql() в директиву препроцессора #if.
блок: когда компилятор C# встречает эти директивы, он скомпилирует код только между ними.
если указанный символ определен. Точнее, символ DEBUG, который мы использовали в предыдущем
код предотвратит компиляцию этого обернутого кода, если только веб-приложение не запускается в
режим отладки, что позволяет избежать потери производительности в выпускных/производственных сборках.

Еще многое можно сказать о функциях внутренней отладки, предлагаемых Visual Studio и .NET;
однако для наших целей лучше пока на этом остановиться и перейти к фронтенду.

# Внешняя отладка
В этом разделе мы кратко рассмотрим различные доступные варианты внешней отладки (визуальная
Studio или инструменты разработчика браузера). Сразу после этого мы рассмотрим некоторые функции Angular.
которые мы можем использовать, чтобы повысить осведомленность о различных задачах, выполняемых нашим клиентским приложением, и отладить их.

# Отладка JavaScript в Visual Studio
Внешняя отладка работает так же, как и внутренняя отладка, благодаря функции отладки JavaScript.
Visual Studio. Отладчик JavaScript по умолчанию не включен, но интегрированная среда разработки Visual Studio будет
автоматически спрашивать, активировать его или нет, когда мы в первый раз ставим точку останова на JavaScript (или
TypeScript) и запустите наше приложение в режиме отладки.
На момент написания поддержка отладки на стороне клиента предоставляется только для Chrome и Microsoft.
Край. Кроме того, поскольку мы используем TypeScript, а не JavaScript напрямую, использование карт исходного кода
требуется, если мы хотим установить и поразить точки останова в файле TypeScript (наш класс компонента Angular
файл), а не в файле, транспилированном JavaScript.
К счастью, шаблон Angular, который мы используем, уже обеспечивает поддержку карты исходного кода, насколько это возможно.
посмотрите, взглянув на значение параметра sourceMap в файле /tsconfig.json нашего WorldCities.
Угловой проект:

```json
[...]
"sourceMap": true
[...]
```
Это означает, что мы можем сделать следующее:
1. Откройте файл /src/app/countries/countries.comComponent.ts.
2. Поместите точку останова внутри подписки на Observable, возвращаемую CountryService.
(подробности см. на следующем снимке экрана).
3. Нажмите F5, чтобы запустить веб-приложение в режиме отладки.

Если мы все сделали правильно, среда выполнения остановит выполнение программы, как только
мы переходим к представлению «Страны».

Поскольку, вероятно, мы впервые используем для этого функцию отладки JavaScript.
проект, Visual Studio может спросить нас, хотим ли мы включить отладку JavaScript.
функция: если да, обязательно включите ее.

Как только точка останова будет достигнута, мы сможем проверить различные члены компонента Angular.
класс, например объект результата, возвращаемый методом getData() и содержащий данные о странах,
как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c471613e-a112-4e2c-a185-63bcf9fa3826)

Это довольно круто, правда? Мы даже можем определить условные точки останова и использовать Watch, Call Stack,
Местные, и сразу окна без существенных изъянов.

В следующем разделе мы представим еще один важный ресурс для отладки интерфейса: карты исходного кода JavaScript.

# Карты исходного кода JavaScript
Для тех, кто не знает, что на самом деле представляют собой исходные карты, попробуем кратко изложить концепцию.

С технической точки зрения, исходная карта — это файл, который отображает код внутри сжатого, объединенного, минимизированного и/или транспилированного файла обратно в исходное положение в исходном файле. Благодаря этим отображениям мы
может отлаживать наши приложения даже после оптимизации наших ресурсов.

Минификация, также известная как минимизация или минимизация, — это процесс удаления
все ненужные символы из исходного кода интерпретируемых языков программирования
или языки разметки без изменения его функциональности; сюда входят пробелы, новые
возврат строки/каретки, комментарии и все, что не требуется для того, чтобы код был
казнён. Минимизация хороша для производственной среды, поскольку она уменьшит
размер исходного кода, что делает его передачу более эффективной с точки зрения пропускной способности.

Как мы только что видели, карты исходного кода широко используются отладчиком JavaScript Visual Studio.
чтобы мы могли устанавливать точки останова в исходном коде TypeScript, и они также поддерживаются
Инструменты разработчика Google Chrome, Mozilla Firefox и Microsoft Edge, что позволяет этим браузерам
встроенные отладчики для отображения неминифицированного и необъединенного исходного кода разработчику, даже если
работа со сжатыми и минифицированными файлами.

Однако, учитывая наш конкретный сценарий, возможности отладки вышеупомянутых браузеров
может быть не идеальным; в следующем разделе мы постараемся объяснить, почему.

# Инструменты разработчика браузера
Как мы можем легко догадаться, функция отладки JavaScript в Visual Studio — не единственный способ отладки.
клиентский скрипт. Однако, поскольку мы имеем дело с приложением TypeScript, возможно, это лучший вариант.
доступный вариант, поскольку он позволяет отлаживать файлы .ts с помощью автоматически сгенерированного
исходные карты.
Хотя встроенные инструменты отладки браузера определенно могут использовать исходные карты, чтобы заставить нас разобраться
с неминифицированными и необъединенными файлами они не могут ничего сделать, чтобы вернуть эти перенесенные файлы.
обратно в свои прежние классы TypeScript, потому что они никогда их не видели.

Именно по этой причине, если мы попытаемся активировать, например, инструменты разработчика Chrome для отладки наших
CountrysComponent Angular, мы увидим что-то вроде этого:

![image](https://github.com/artemovsergey/Angular/assets/26972859/b074576a-2797-4d5c-96a5-db7b435c9cf6)

Как мы видим, файла TypeScript там нет. Браузер имеет дело с огромным перенесенным файлом main.js.
файл, который в основном содержит все компоненты Angular. В этом файле класс CountrysComponent
(длина которого в настоящее время составляет менее 100 строк) соответствует строке 888 этого файла main.js (фактический
номер строки может отличаться).
Однако в верхней части окна есть информативное предупреждение, показывающее код JavaScript, который информирует
нам, что исходная карта была обнаружена: благодаря ее наличию браузер сможет идентифицировать
исходный файл, используя информацию, содержащуюся в исходной карте. Чтобы быстро продемонстрировать это, давайте посмотрим, что
произойдет, если мы поместим точку останова в ту же строку исходного кода, что и раньше – внутри подписки
возвращено CountryService.
Как только мы щелкнем по этой строке, чтобы установить там точку останова, соответствующий файл TypeScript также будет
станут доступными, как в Visual Studio:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c7b8b45d-085e-42d7-8a3b-45c3a2d12842)

Как такое возможно? Разве мы только что не сказали, что браузер ничего не знает о
Класс TypeScript?
Если мы прочитаем информативную строку, расположенную внизу окна разработки, мы увидим, что
браузер дает нам ответ: источник TypeScript сопоставлен с файлом main.js. Теперь, поскольку мы
запуск приложения на сервере разработки Angular Live (как описано в главе 2 «Подготовка»)
браузер, хотя и получает только транспилированный файл main.js JavaScript, может следовать исходной карте для
добраться до базовых файлов TypeScript.
Если мы установим точку останова на странице TypeScript, как только она сработает, мы должны
вернемся в Visual Studio, где мы сможем отладить файл TypeScript CountrysComponent точно так же, как мы это делали.
когда мы поместим туда точку останова.

# Отладка Angular формы
В этом разделе мы собираемся потратить немного драгоценного времени на понимание некоторых ключевых концепций, связанных с
сформировать отладку.
Как мы упоминали в главе 7 «Формы и проверка данных», одним из преимуществ подхода, основанного на модели, является тот факт, что он позволяет нам иметь детальный контроль над элементами формы. Как
Можем ли мы использовать эти возможности в своих интересах и преобразовать их в написание более надежного кода?

В следующих разделах мы попытаемся ответить на этот вопрос, показав некоторые полезные методы, которые
можно использовать для получения большего контроля над нашими формами.

# Взгляните на модель формы
Мы много говорили о модели формы в главе 7 «Формы и проверка данных», но никогда ее не видели.
вблизи. Было бы очень полезно иметь его на экране при разработке шаблонов форм, особенно если
его можно обновлять в режиме реального времени по мере того, как мы играем с вводами формы и элементами управления.
Вот удобный фрагмент HTML, содержащий синтаксис шаблона, необходимый для этого:

```html
<!-- Form debug info panel -->
<div class="info">
 <div class="info-header">Form Debug Info</div>
 <div class="info-body">
 <div class="info-label">
 Form Value:
 </div>
 <div class="info-value">
 {{ form.value | json }}
 </div>
 <hr />
 <div class="info-label">
 Form Status:
 </div>
 <div class="info-value">
 {{ form.status | json }}
 </div>
 </div>
</div>
```
А вот его стиль SCSS:

```scss
.info {
 margin-top: 20px;
 background-color: #efefef;
 border: 1px solid #cdcdcd;
 border-radius: 10px;
 .info-header {
 font-weight: 500;
 padding: 10px 20px;
 border-bottom: 1px solid #cdcdcd;
 }
 .info-body {
 background-color: #fafafa;
 padding: 10px 20px;
 border-radius: 0 0 10px 10px;
 .info-label {
 }
 .info-value {
 padding: 2px 0;
 font-size: 0.8em;
 }
 hr {
 border: 0;
 border-top: 1px solid #cdcdcd;
 }
 }
}
```

Добавьте первый фрагмент в HTML-файл CityEditComponent, а второй — в CityEditComponent.
SCSS, чтобы получить следующий результат:

![image](https://github.com/artemovsergey/Angular/assets/26972859/47433a71-29d2-417d-9133-5fb50ee1ee1a)

Довольно полезно, правда? Если мы немного поиграем с формой, то увидим, как значения, содержащиеся в форме,
Панель «Информация об отладке» будет меняться по мере изменения элементов управления вводом; что-то подобное обязательно будет
удобно при работе со сложными формами.

# Оператор pipe
Глядя на выделенные строки предыдущего исходного кода, мы можем увидеть, как мы использовали канал
оператор (|), еще один полезный инструмент, взятый из синтаксиса шаблонов Angular.
Подводя краткий итог тому, что он делает, можно сказать следующее: оператор трубы позволяет использовать некоторые
функции преобразования, которые можно использовать для выполнения различных задач, таких как форматирование строк, объединение массивов
элементы в строку, текст в верхнем/строчном регистре и сортировку списка.
Вот каналы, встроенные в Angular:
- DatePipe
- UpperCasePipe
- LowerCasePipe
- CurrencyPipe
- PercentPipe
- JsonPipe
Все эти операторы каналов доступны для использования в любом шаблоне. Излишне говорить, что мы использовали последнюю трубку в
предыдущий скрипт для преобразования объектов form.value и form.status в читаемые строки JSON.

Стоит отметить, что мы также можем объединить несколько каналов и определить собственные каналы; однако,
нам пока не нужно этого делать, и разговор на такую тему занял бы у нас
далеко за пределами данной главы. Тем, кто хочет узнать больше о трубах, следует
ознакомьтесь с официальной документацией Angular по адресу: https://angular.io/guide/pipes.

# Реакция на изменения
Одной из причин, по которой мы выбрали реактивный подход, была возможность реагировать на изменения, вносимые
Пользователь. Мы можем сделать это, подписавшись на свойство valueChanges, предоставляемое FormGroup, и
Классы FormControl, которые возвращают Observable RxJS, который выдает последние значения.
Мы используем Observables с главы 4 «Взаимодействие с внешним и внутренним интерфейсом», когда подписались.
к методу get() HttpClient для обработки HTTP-ответа, полученного веб-сервером для
первый раз. Мы снова использовали их в главе 7 «Формы и проверка данных», когда нам нужно было реализовать
поддержка методов put() и post().
И последнее, но не менее важное: мы подробно говорили о них в главе 8 «Настройка кода и службы данных», когда
мы объяснили их плюсы и минусы по сравнению с Promises, узнали о некоторых наиболее важных функциях и интегрировали их в наши CityService и CountryService. На самом деле, мы, скорее всего,
продолжайте использовать их везде и всякий раз, когда нам нужно получить данные JSON, которые используются в нашей модели данных.
интерфейсы и объекты модели формы.

В следующем разделе мы собираемся использовать их, чтобы продемонстрировать, как мы можем выполнять некоторые произвольные действия.
операции всякий раз, когда пользователь меняет что-то в форме. Точнее, попытаемся наблюдать
наблюдаемое путем реализации специального журнала активности.

# Журнал активности
И снова CityEditComponent будет нашей лабораторной крысой.
Откройте файл класса /src/app/cities/city-edit.comComponent.ts и обновите его код следующим образом.
выделенные строки:

```ts
// Activity Log (for debugging purposes)
 activityLog: string = '';
 constructor(
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private cityService: CityService) {
 super();
 }
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl('', Validators.required),
 lat: new FormControl('', [
 Validators.required,
 Validators.pattern(/^[-]?[0-9]+(\.[0-9]{1,4})?$/)
 ]),
 lon: new FormControl('', [
 Validators.required,
 Validators.pattern(/^[-]?[0-9]+(\.[0-9]{1,4})?$/)
 ]),
 countryId: new FormControl('', Validators.required)
 }, null, this.isDupeCity());
 // react to form changes
 this.form.valueChanges
 .subscribe(() => {
 if (!this.form.dirty) {
 this.log("Form Model has been loaded.");
 }
else {
 this.log("Form was updated by the user.");
 }
 });
 this.loadData();
 }
 log(str: string) {
 this.activityLog += "["
 + new Date().toLocaleString()
 + "] " + str + "<br />";
 }
```
В предыдущем коде мы предоставили нашей модели формы простую, но эффективную функцию ведения журнала, которая
будет регистрировать любые действия по изменению, выполненные платформой и/или пользователем.
Как мы видим, вся логика была помещена в ngOnInit, потому что именно здесь находится класс компонента.
инициализируется вместе с наблюдаемой, которую нам нужно отслеживать. Функция log() — это просто ярлык
чтобы добавить базовую временную метку к строке активности журнала и добавить ее в локальную переменную ActivityLog в
централизованный способ.
Чтобы в полной мере воспользоваться нашей новой функцией ведения журнала, нам нужно найти способ разместить ActivityLog
на экране.
Для этого откройте файл шаблона /src/app/cities/city-edit.comComponent.html и добавьте
следующий фрагмент HTML-кода в конце файла, прямо под предыдущей панелью «Информация об отладке формы»:

```html
<div class="info">
 <div class="info-header">Form Activity Log</div>
 <div class="info-body">
 <div class="info-value">
 <span *ngIf="activityLog"
 [innerHTML]="activityLog">
 </span>
 </div>
 </div>
</div>
```
Вот и все; теперь журнал активности будет отображаться в режиме реального времени, то есть по-настоящему реактивным способом

Стоит отметить, что здесь мы не использовали двойные фигурные скобки интерполяции — мы пошли
вместо этого прямо для директивы [innerHTML]. Причина этого очень проста. 
интерполяция удаляет теги HTML из исходной строки; следовательно, мы бы потеряли
Тег <br />, который мы использовали в функции log() для разделения всех строк журнала переводом строки. Если
в противном случае мы бы использовали синтаксис {{ ActivityLog }}.

# Тестирование журнала активности
Все, что нам нужно сделать сейчас, это протестировать наш новый журнал активности.
Для этого запустите проект в режиме отладки, перейдите прямо в CityEditComponent, отредактировав уже существующий город (например, Прагу), поиграйте с полями формы и посмотрите, что произойдет в активности формы.
Панель журнала:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5f582a87-0d8f-4621-ab52-798564fc9526)

Первая строка журнала должна сработать автоматически, как только HttpClient получит JSON города из
серверный веб-API и модель формы обновляются. Затем форма будет регистрировать любые обновления, выполненные пользователем; все, что мы можем сделать, это изменить различные поля ввода, но этого более чем достаточно для
наш скромный тест на реактивность завершился успешно.

# Расширение журнала активности
Реагировать на изменения модели формы — это не единственное, что мы можем сделать; мы можем продлить нашу подписку
также соблюдать любой контроль формы. Давайте выполним дальнейшее обновление нашей текущей реализации журнала активности, чтобы продемонстрировать это.
Откройте файл класса /src/app/cities/city-edit.comComponent.ts и обновите код в ngOnInit.
метод со следующими выделенными строками:

```ts
// react to form changes
this.form.valueChanges
 .subscribe(val => {
 if (!this.form.dirty) {
 this.log("Form Model has been loaded.");
 }
 else {
this.log("Form was updated by the user.");
 }
 });
// react to changes in the form.name control
this.form.get("name")!.valueChanges
 .subscribe(() => {
 if (!this.form.dirty) {
 this.log("Name has been loaded with initial values.");
 }
 else {
 this.log("Name was updated by the user.");
 }
 });
```
Приведенный выше код добавит дополнительные строки журнала в журнал активности формы, все они связаны с изменениями.
происходит в элементе управления формой имени, который содержит название города, следующим образом:

![image](https://github.com/artemovsergey/Angular/assets/26972859/7e35941c-6c12-4a2f-b039-859252d04796)

Того, что мы только что сделали, более чем достаточно, чтобы продемонстрировать чудеса наблюдаемого свойства valueChanges; давайте перейдем к следующей теме.

Мы определенно можем сохранить панели «Информация об отладке формы» и «Журнал активности формы» в
Шаблон CityEditComponent для дальнейшего использования, но его не нужно копировать/вставлять.
в шаблонах других компонентов на основе форм или где-либо еще: в конце концов, это журналирование
информация будет ненужной для обычного пользователя и не должна быть видна в приложении.
пользовательский интерфейс для демонстрационных целей.

# Отладка на стороне клиента
Еще одним большим преимуществом Observables является то, что мы можем использовать их для отладки значительной части всего процесса.
Реактивный рабочий процесс путем размещения точек останова в исходном коде нашей подписки. Чтобы быстро продемонстрировать

Для этого просто добавьте точку останова Visual Studio в нашу последнюю подписку следующим образом:

![image](https://github.com/artemovsergey/Angular/assets/26972859/79ecf8bd-2faf-4e69-bb6a-ece9b7cfd492)

После этого запустите проект в режиме отладки и перейдите к CityEditComponent; точка останова будет
нажать сразу после загрузки модели формы, поскольку элемент управления именем также будет обновлен, а также
каждый раз, когда мы вносим изменения в этот элемент управления. Всякий раз, когда это произойдет, мы сможем использовать все визуальные возможности.
Инструменты и функции отладки JavaScript Studio, доступные при отладке на стороне клиента, например
Просмотр, Местные жители, Автомобили, Немедленно, Стек вызовов и многое другое.

# Отписка от Observables
Observables — отличный способ отслеживать поведение нашего клиентского приложения: как только мы подписываемся на них, мы
можете быть уверены, что наши обработчики событий будут вызваны при выдаче нового значения. Однако с большим
сила приходит с большой ответственностью: всякий раз, когда мы подписываемся на Observable, такая подписка будет действовать.
до тех пор, пока Observable не завершит свою работу, если мы заранее не откажемся от подписки. Однако большинство Observables
(например, упомянутые выше изменения значений) не предназначены для завершения: если мы подпишемся на эти
«бесконечные Observables» и не отписывайтесь от них, эти подписки будут действовать бесконечно,
даже когда компонент, который их создал, уничтожается, что приводит к утечке памяти до тех пор, пока
все приложение Angular удаляется из памяти, например, когда мы переходим на другой сайт.
Чтобы избежать такого поведения, нам нужно научиться правильно с ними бороться: словом, отписываться. Давайте кратко представим некоторые способы сделать это, используя императивный, декларативный и автоматический методы.
подходы.

# Метод unsubscribe() 
Первый подход, который нам следует рассмотреть, — это собрать все подписки, которые мы можем объявить в рамках нашего
CityEditComponent в одном экземпляре подписки следующим образом:

```ts
import { Observable, Subscription } from 'rxjs';
// ... existing code...
private subscriptions: Subscription = new Subscription();
```
А затем используйте его для хранения всех наших существующих подписок:

```ts
// react to form changes
this.subscriptions.add(this.form.valueChanges
 .subscribe(val => {
 if (!this.form.dirty) {
 this.log("Form Model has been loaded.");
 }
 else {
 this.log("Form was updated by the user.");
 }
 }));
// react to changes in the form.name control
this.subscriptions.add(this.form.get("name")!.valueChanges
 .subscribe(() => {
 if (!this.form.dirty) {
 this.log("Name has been loaded with initial values.");
 }
 else {
 this.log("Name was updated by the user.");
 }
 }));
```
Если мы это сделаем, мы сможем отказаться от подписки на все «собранные» подписки в жизненном цикле ngOnDestroy.
хук, который вызывается при уничтожении компонента:

```ts
ngOnDestroy() {
  this.subscriptions.unsubscribe();
}
```
Вот и все: в предыдущем коде мы эффективно используем аккуратный встроенный механизм, предоставляемый классом
Класс подписки, который выполняет за нас большую часть работы по отмене подписки; нам просто нужно «подвести итоги»
подписки, от которых мы хотим избавиться, и реализуем описанный выше метод ngOnDestroy.

# Оператор takeUntil()
Если мы предпочитаем использовать декларативный подход, мы можем использовать другой причудливый механизм, предоставляемый RxJS.
библиотека: оператор takeUntil.
Вот как мы можем реализовать это в классе CityEditComponent, заменив предыдущую функцию unsubscribe().
подход (выделены новые/обновленные строки):

```ts
import { Observable, Subject } from 'rxjs';
import { map, takeUntil } from 'rxjs/operators';
// ...existing code...
private destroySubject = new Subject();
// ...existing code...
 // react to form changes
 this.form.valueChanges
 .pipe(takeUntil(this.destroySubject))
 .subscribe(() => {
 if (!this.form.dirty) {
 this.log("Form Model has been loaded.");
 }
 else {
 this.log("Form was updated by the user.");
 }
 });
// react to changes in the form.name control
 this.form.get("name")!.valueChanges
 .pipe(takeUntil(this.destroySubject))
 .subscribe(() => {
 if (!this.form.dirty) {
 this.log("Name has been loaded with initial values.");
 }
 else {
 this.log("Name was updated by the user.");
 }
 });
// ...existing code...
ngOnDestroy() {
 // emit a value with the takeUntil notifier
 this.destroySubject.next(true);
 // complete the subject
 this.destroySubject.complete();
}
```

Вкратце, вот что мы сделали:
- Мы добавили внутреннюю переменную DestroySubject типа Тема, специальный тип Observable.
представленный в главе 8 «Настройки кода и службы данных», который позволяет выполнять многоадресную передачу значений.
многим наблюдателям
- Мы передали оператор takeUntil() во все наблюдаемые цепочки; оператор зарегистрирует
DestroySubject в качестве уведомителя, что означает, что он будет выдавать значения, испускаемые наблюдаемым источником, до тех пор, пока не будет выдан DestroySubject.
- Мы реализовали перехватчик жизненного цикла ngOnDestroy, где наш уведомитель выдает значение (таким образом
прекращение всех подписок) и помечает себя как выполненное: завершая тему, все
существующие подписки будут отменены
Как мы видим, этот метод позволяет нам заранее объявить нашу наблюдаемую цепочку со всем необходимым.
что он должен учитываться на протяжении всего жизненного цикла от начала до конца: жизнеспособная альтернатива
unsubscribe()… при условии, что мы не забудем реализовать интерфейс ngOnDestroy! Помогать
если мы это помним, мы могли бы приобрести (хорошую) привычку явно объявлять интерфейс OnDestroy в
все наши классы компонентов:

```ts
import { Component, OnInit, OnDestroy } from '@angular/core';
export class CityEditComponent
 extends BaseFormComponent implements OnInit, OnDestroy {
```
А пока давайте сделаем это в нашем CityEditComponent и двинемся дальше.
Чтобы дать читателю правильную ссылку на исходный код, мы реализовали функцию takeUntil().
метод, а также явное объявление OnDestroy, в CityEditComponent: код можно найти
в репозитории книги на GitHub для этой главы.

# Другие жизнеспособные альтернативы
Есть много других способов отписаться от Observables, большинство из них еще более эффективны.
и кратким для некоторых конкретных сценариев.
Например, если нам нужно выдать только один результат, мы можем использовать операторы first() или take(1): эти операторы могут быть «переданы по конвейеру» перед подпиской точно так же, как оператор takeUntil() и
автоматически завершится после получения первого результата без необходимости создания объекта уничтожения
уведомитель; если мы хотим отказаться от подписки на исходный поток, как только выдаваемое значение больше не соответствует
определенное условие, мы можем использовать оператор takeWhile()

Большим преимуществом всех этих операторов RxJS является то, что они автоматически отписываются,
без необходимости выполнять это вручную (что исключает риск забыть об этом).
Однако, если их неправильно использовать, они все равно могут вызвать утечки памяти: например, если мы используем
first(), и компонент уничтожается до того, как исходный наблюдаемый объект выдаст for
в первый раз этот оператор в игру не вступит и подписка продолжит жить.
Именно по этой причине даже при использовании этих операторов настоятельно рекомендуется принять
некоторые методы удаления, такие как шаблон takeUntil(destroy) или подписка.
объект, описанный выше.

Более того, всякий раз, когда мы используем подписку для подачи данных в наши шаблоны, мы можем использовать Angular
асинхронный канал, который автоматически подписывается и отписывается при уничтожении компонента. Этот
по сути это означает, что в нашем файле класса TypeScript CityEditComponent вместо этого:

```ts
// the countries array for the select
countries?: Country[];
// ...
loadCountries() {
 // fetch all the countries from the server
 this.cityService.getCountries(
 0,
 9999,
 "name",
null,
 null,
 null,
 ).subscribe(result => {
 this.countries = result.data;
 }, error => console.error(error));
}
```
Мы могли бы сделать это:

```ts
// the countries observable for the select (using async pipe)
countries?: Observable<Country[]>;
// ...
loadCountries() {
 // fetch all the countries from the server
 this.countries = this.cityService
 .getCountries(
 0,
 9999,
 "name",
 "asc",
 null,
 null,
 ).pipe(map(x => x.data));
}
```

А затем обработайте обновленную переменную стран (которая теперь является наблюдаемой), изменив файл шаблона cityedit.comComponent.html следующим образом:

```html
<mat-form-field *ngIf="countries | async as result">
 <mat-label>Select a Country...</mat-label>
 <mat-select formControlName="countryId">
 <mat-option *ngFor="let country of result" [value]="country.id">
 {{country.name}}
 </mat-option>
</mat-select>
</mat-form-field>
```
Теперь асинхронный канал автоматически подпишется на наблюдаемый объект, вернет последнее значение, а затем
отписаться от него при уничтожении компонента, избежав таким образом утечек памяти.
Давайте быстро реализуем этот ценный пример в нашем CityEditComponent (файлы TypeScript и HTML).
и двигаться дальше; как всегда, те, кто сталкивается с проблемами при попытке сделать это, могут найти полный исходный код.
ссылка на код в репозитории GitHub.

# Должны ли мы всегда отказываться от подписки?
На самом деле нет; однако, чтобы определить, когда нам следует отказаться от подписки, нам нужно
понять, где на самом деле скрывается наш «враг».
Короче говоря, утечки памяти, которых мы хотели бы избежать, происходят, когда мы уничтожаем и воссоздаем наши
компоненты без очистки существующих подписок: если эти компоненты создаются заново, что
скорее всего, произойдет, если пользователь продолжит просматривать приложение, он будет порождать все больше и больше подписок и т. д., что приведет к утечке.
Этого краткого анализа должно быть более чем достаточно, чтобы помочь вам понять, когда нам следует использовать метод(ы) отписки, описанный ранее: как правило, мы должны делать это для Observables, которые
подписываться на компоненты, экземпляры которых предназначены для многократного создания и уничтожения, например
как компоненты, содержащие представления.
И наоборот, любой компонент, экземпляр которого создается только один раз во время запуска приложения, не будет иметь
возможность генерировать несколько «бесконечных подписок» и, следовательно, не требует какой-либо логики «отписки». AppComponent, как и большинство сервисов, являются хорошими примерами: они предназначены
жить в течение всего срока службы приложения и не вызывать утечек памяти, пока
приложение работает.

Теперь, когда мы разобрались с отменой подписки и знаем, как правильно отлаживать наш внутренний код, давайте
переключитесь на немного другую тему.

# Регистрация приложений
Как, скорее всего, знают все разработчики, термин «ведение журнала» — при использовании в любом ИТ-контексте, от программирования
языки для информатики — в основном используется для определения процесса записи действий приложения.
и состояние на вторичный канал. Чтобы лучше понять это определение, нам нужно уловить разницу.
между первичным и вторичным каналом.
Все приложения предназначены для общения со своими пользователями через специальный интерфейс, который
часто называемый пользовательским интерфейсом или UI:
- Например, настольные приложения используют графический интерфейс пользователя (GUI), предоставляемый
Библиотеки Windows (или других операционных систем)
- Консольные приложения используют терминал операционной системы.
- Веб-приложения отображают свои данные через веб-браузер.
… и так далее. Во всех предыдущих примерах пользовательский интерфейс является основным механизмом вывода, используемым
программное обеспечение для общения с пользователями, являющееся, таким образом, основным каналом приложения.
В то же время приложению часто бывает очень полезно отслеживать различные действия, которые оно выполняет.
пока работает: изменение состояния, доступ к внутренним ресурсам, обработчики событий, которые срабатывают в ответ на
взаимодействие с пользователем и так далее. Мы сделали нечто подобное в Angular в начале этой главы, когда
мы реализовали журнал активности.
Однако обычному пользователю этот уровень информации часто не нужен, пока приложение работает нормально.
ожидал; не говоря уже о том факте, что такие низкоуровневые детали могут легко раскрыть некоторые внутренние механизмы и/или поведение нашего веб-приложения, которые не должны быть доступны публике для
очевидные соображения безопасности.
В то же время эти журналы могут оказаться чрезвычайно полезными для разработчиков и системных администраторов.
всякий раз, когда приложение зависает или ведет себя неожиданным образом, потому что они могут очень помочь им
понять, что происходит не так и как это исправить. По правде говоря, любой опытный разработчик знает
что ведение журнала является обязательной функцией для любого приложения, поскольку оно необходимо для обнаружения, расследования,
и проблемы отладки.

Это подводит нас к главному вопросу: если основной канал невозможен, то куда нам следует его поставить?
такая информация? Ответ кроется в определении ведения журнала, которое мы дали недавно: во вторичном
канал, доступный только разработчикам, системным администраторам и другим заинтересованным (и уполномоченным) лицам
будет иметь доступ.
Если мы думаем о клиентской среде, такой как Angular, лучший вторичный канал, который у нас есть, — это
журнал консоли браузера, доступ к которому можно получить с помощью JavaScript console.log и/или debug.log.
команды; в идеале, это место, куда мы должны переместить все результаты нашего журнала активности, таким образом сохранив
пользовательский интерфейс — основной канал — максимально понятен.
Сделать это было бы просто, и нам нужно всего лишь изменить пару вещей:
- Удалить панель журнала активности формы (до корневого элемента <div>).
- Удалите переменную this.activityLog (в файле city-edit.comComponent.ts).
- Измените метод журнала CityEditComponent следующим образом:

```js
log(str: string) {
 console.log("["
 + new Date().toLocaleString()
 + "] " + str);
 }
```
Вот и все, что касается клиентской стороны.

Предыдущая «экранная» реализация будет сохранена в исходном коде книги на GitHub.
для справочных целей; однако читателю настоятельно рекомендуется полагаться на консоль.
log для большинства реальных сценариев.

А как насчет журналирования на стороне сервера? Ранее мы видели, что у нас есть окно вывода, но это
доступно только тогда, когда мы запускаем наше приложение из Visual Studio, верно?
Или нет?

# Знакомство с ведением журнала ASP.NET Core
.NET обеспечивает поддержку стандартизированного API-интерфейса общего назначения для ведения журналов через Microsoft.
Пакет NuGet Extensions.Logging, который неявно включается при сборке ASP.NET Core.
приложение; этот API можно использовать для сбора, отображения и/или хранения журналов с использованием интерфейса по умолчанию (ILogger).
это было реализовано различными встроенными и сторонними поставщиками журналов.
В типичном веб-приложении ASP.NET Core встроенные поставщики журналов автоматически добавляются в список.
наше веб-приложение с помощью вспомогательного метода CreateDefaultBuilder файла Program.cs, который мы видели
еще в главе 3, «Оглядываясь вокруг». Точнее, включены следующие провайдеры:
- Консоль, которая записывает вывод на консоль.
- Debug: запись результатов журнала с использованием класса System.Diagnostics.Debug.
- Источник событий, который записывает в кросс-платформенный источник событий с именем MicrosoftExtensions-Logging.
- EventLog, который отправляет выходные данные журнала в журнал событий Windows (только для операционной системы Windows).
Фактически, содержимое, которое мы видим в окне вывода Visual Studio, полностью получено из
встроенный поставщик отладки. Это также означает, что если мы хотим добавить дополнительные функции ведения журнала, все, что мы
Нам нужно найти больше провайдеров, которые смогут записывать эти журналы, когда мы захотим.

# Структурированное журналирование СУБД с помощью Serilog
Как мы видим, не существует собственных поставщиков журналов, которые можно было бы использовать для хранения этих журналов внутри.
систему управления базами данных (СУБД), которая, безусловно, была бы очень полезна, поскольку позволила бы нам
просматривать наши журналы, используя структурированный подход. На самом деле, структурированное журналирование определенно будет
быть отличным способом создания читаемых, фильтруемых, индексируемых и экспортируемых журналов.
К счастью, мы можем добиться этого, используя одного из многих сторонних поставщиков журналов, которые реализуют интерфейс ILogger, доступный в NuGet: его имя — Serilog, и он довольно потрясающий.
В следующих разделах мы увидим, как мы можем реализовать это в нашем проекте WorldCitiesAPI, чтобы
сохранять свои журналы в выделенной базе данных SQL Server в структурированном виде.
Установка пакетов NuGet
Первое, что нам нужно сделать, это добавить следующие пакеты NuGet в наш проект WorldCitiesAPI:
- Серилог.AspNetCore
- Serilog.Настройки.Конфигурация
- Серилог.Синкс.MSSqlServer
Как всегда, эти пакеты можно установить с помощью графического интерфейса Visual Studio (управление пакетами NuGet) или
Интерфейс консоли диспетчера пакетов следующим образом:

```
PM> Install-Package Serilog.AspNetCore
PM> Install-Package Serilog.Settings.Configuration
PM> Install-Package Serilog.Sinks.MSSqlServer
```
В нашем сценарии требуется Serilog.Sinks.MSSqlServer, поскольку мы используем MS SQL Server; однако,
существует множество других коннекторов («приемников») для MySQL, MariaDB, PostgreSQL и даже NoSQL.
базы данных, такие как RavenDB и MongoDB.

# Настройка Serilog
После установки необходимых пакетов NuGet мы можем настроить Serilog, используя файлы конфигурации нашего веб-приложения. Точнее, мы собираемся обновить файл Program.cs, где
IHostBuilder создан с набором встроенных поставщиков журналов.
В обозревателе решений откройте файл Program.cs и добавьте следующий код (выделены новые строки):

```Csharp
using Microsoft.EntityFrameworkCore;
using WorldCitiesAPI.Data;
using Serilog;
using Serilog.Events;
using Serilog.Sinks.MSSqlServer;
var builder = WebApplication.CreateBuilder(args);
// Adds Serilog support
builder.Host.UseSerilog((ctx, lc) => lc
 .ReadFrom.Configuration(ctx.Configuration)
 .WriteTo.MSSqlServer(connectionString:
 ctx.Configuration.GetConnectionString("DefaultConnection"),
 restrictedToMinimumLevel: LogEventLevel.Information,
 sinkOptions: new MSSqlServerSinkOptions
 {
 TableName = "LogEvents",
 AutoCreateSqlTable = true
 }
 )
 .WriteTo.Console()
 );
```

Как мы видим, здесь мы выполнили несколько разных задач:
1. Мы добавили необходимые ссылки на различные пространства имен Serilog.
2. Мы добавили поддержку Serilog в IHostBuilder, который в конечном итоге будет использоваться для сборки ASP.
NET Core-приложение.
3. Мы сказали Serilog прочитать настройки конфигурации из IConfiguration контекста, в котором хранятся
значения, объявленные и/или переопределенные в файле appsettings.json, appsettings.<Environment>.
json и комбинированные файлы secrets.json.
4. Мы настроили Serilog для записи журналов на SQL Server, используя существующую строку подключения, и
на консоль.
Приемник Serilog SQL Server, который мы здесь используем, записывает журналы в специальную таблицу [LogEvents],
создание этой таблицы, если она еще не существует. Теперь, поскольку мы использовали ту же строку подключения, что и
мы использовали для создания экземпляра нашего ApplicationDbContext в главе 5 «Модель данных с Entity Framework Core»,
такая таблица будет создана в нашей существующей базе данных WorldCities.
Автоматическое создание таблицы [LogEvents] в нашем сценарии допустимо, поскольку у нас нет существующей таблицы.
Таблица [LogEvents], которую мы хотим сохранить: если бы она у нас была, мы могли бы либо изменить настройки Serilog по умолчанию,
имя таблицы журнала или отключите поведение по умолчанию «создать, если оно не существует» приемника MSSQLServer, используя
параметры TableName и AutoCreateSqlTable, указанные выше.

Прежде чем протестировать нашу реализацию, давайте потратим минуту на добавление еще одной полезной функции ведения журнала в нашу программу.
приложение: промежуточное программное обеспечение SerilogRequestLogging.

# Логирование HTTP-запросов
Еще одна замечательная особенность Serilog заключается в том, что мы можем использовать его для регистрации входящих HTTP-запросов. После реализации эта функция выдаст следующее сообщение журнала:

```
HTTP GET /cities responded 200 in 1348.6188 ms
```

Для этого нам нужно добавить промежуточное ПО UseSerilogRequestLogging в наш Program.cs.
файл следующим образом:

```Csharp
var app = builder.Build();
app.UseSerilogRequestLogging();
```
Давайте сделаем это.
Теперь, когда все настроено, нам просто нужно выполнить быстрый тест, чтобы подтвердить, что наш новый сервер на базе Serilog
поставщик журналов действительно работает.

# Доступ к журналам
Поскольку мы сказали Serilog автоматически создавать таблицу LogEvents, если она еще не существует, нам просто нужно запустить
наш проект в режиме отладки, нажав F5, и посмотрите, что произойдет с базой данных.
Как только веб-приложение будет полностью загружено, откройте SQL Server Management Studio и получите доступ к базе данных WorldCities, следуя инструкциям, приведенным в главе 5 «Модель данных с Entity Framework Core».

Если мы сделали все как ожидалось, мы сможем увидеть новую таблицу LogEvents и кучу
журналы инициализации, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1a5b740c-0844-4c5d-a4c0-53d2d6cfcd5a)

Теперь мы можем удобно получить структурированный доступ к нашему журналу с помощью SQL-запросов.
Кроме того, мы можем использовать эту новую функцию для регистрации всего, что захотим, используя удобный Serilog.Log.
статическая точка входа, предоставляемая библиотекой.
Вот как мы можем сделать это с контроллера:

```Csharp
public class SampleController : Controller
{
 public SampleController()
 {
 Serilog.Log.Information("SampleController initialized.");
 }
}
```
А вот как это вызвать в представлении:

```
@Serilog.Log.Information("SampleView shown to the user");
```
Если нам не нравится статическая точка входа Serilog.Log, мы все равно можем использовать стандартный интерфейс ILogger, используя
внедрение зависимостей и достижение того же результата, поскольку он также будет использовать новые выходы/приемники Serilog.
Вот как реализовать интерфейс ILogger в контроллере:

```Csharp
using Microsoft.Extensions.Logging;
[...]
public class SampleController : Controller
{
 public ILogger<SampleController> Logger { get; set; }
 public SampleController(ILogger<SampleController> logger)
 {
 Logger = logger;
 Logger.LogInformation("SampleController initialized.");
 }
}
```
И вот тот же подход в представлении:

```Csharp
@using Microsoft.Extensions.Logging
@inject ILogger<_Views_Dress_Edit> logger
@logger.LogInformation("SampleView shown to the user");
```

Статическая точка входа Serilog.Log великолепна и предоставляет множество дополнительных функций; Тем не менее, стандартный интерфейс ILogger часто является наиболее целесообразным подходом, поскольку он облегчит подключение наших
приложение с другими инструментами телеметрии и мониторинга на базе MS (такими как Application Insights в MS Azure).

Важно понимать, что здесь мы лишь коснулись поверхности Serilog, просто чтобы продемонстрировать
насколько легко настроить запись журналов в выбранную нами СУБД; например, мы могли бы использовать другой
база данных в том же экземпляре SQL Server или даже в другом ядре СУБД; мы могли бы изменить
имя таблицы EventLog по умолчанию и/или имена столбцов, а также добавление дополнительных столбцов; и так далее.

# Краткое содержание
В этой главе мы говорили о ряде функций и методов отладки, которые можно использовать.
очень полезно во время разработки. Давайте попробуем быстро подвести итог тому, что мы узнали на данный момент.
Мы начали свое путешествие с функций отладки на стороне сервера Visual Studio. Это набор функций отладки во время выполнения, которые можно использовать для предотвращения большинства ошибок компилятора в нашем веб-API и позволяют
нам отслеживать весь жизненный цикл серверного приложения: от инициализации промежуточного программного обеспечения до
весь конвейер HTTP-запросов/ответов, вплоть до контроллеров, сущностей и объектов IQueryable.
Сразу после этого мы перешли к функции отладки на стороне клиента Visual Studio. Это аккуратный JavaScript
отладчик, который благодаря картам исходного кода, созданным транспилятором TypeScript, позволяет нам напрямую
отлаживайте наши классы TypeScript и получайте доступ к переменным, подпискам и инициализаторам по-настоящему эффективным способом.
Кроме того, мы разработали и внедрили журнал активности в режиме реального времени. Это быстрый и эффективный способ
использовать реактивные функции различных Observables, предоставляемых модулями Angular, чтобы сохранить
отслеживать, что происходит с нашими компонентами; не говоря уже о том, что Visual Studio TypeScript
Транспилятор (и IntelliSense), мы надеемся, защитит нас от большинства синтаксических, семантических и логических ошибок программирования, освободив нас от вредителей программирования на основе сценариев, по крайней мере, по большей части.
И последнее, но не менее важное: мы увидели, как реализовать удобную стороннюю библиотеку (Serilog) для хранения журналов наших приложений в базе данных, чтобы мы могли иметь к ним структурированный доступ.
Однако что, если мы хотим протестировать наши формы на предмет конкретных случаев использования? Есть ли способ, которым мы можем
издеваться над поведением наших внутренних контроллеров ASP.NET Core, а также над поведением нашего внешнего Angular
компоненты и выполнять модульные тесты?
Ответ: да. На самом деле, две выбранные нами платформы предоставляют различные инструменты тестирования с открытым исходным кодом для выполнения модульных тестов. В следующей главе мы узнаем, как использовать их для улучшения качества.
нашего кода и предотвращать ошибки во время рефакторинга, регрессии и новых процессов реализации.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: код Visual Studio, отладчик, отладка на стороне сервера, отладка на стороне клиента, методы расширения, директивы препроцессора C#, JavaScript.
карты исходного кода, Angular каналы, Observable, Тема, отписка, операторы RxJS, асинхронный канал, ILogger,
и Серилог.


