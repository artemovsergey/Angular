# Fetching and Displaying Data

В предыдущей главе мы создали новое решение WorldCities, содержащее проект WorldCities.
(наше приложение Angular) и проект WorldCitiesAPI (наш веб-API ASP.NET) и внесли значительный вклад в
усилия по расширению возможностей последнего с помощью поставщика данных на основе СУБД, построенного на Entity Framework Core.
используя подход Code-First. Теперь, когда у нас есть постоянство данных, мы готовы доверить нашим пользователям
с возможностью взаимодействия с нашим приложением; это означает, что мы можем переключиться на приложение Angular и
реализовать некоторые столь необходимые вещи, такие как следующие:
- Извлечение данных: запрос поставщика данных со стороны клиента с использованием HTTP-запросов и получение
структурированные результаты со стороны сервера
- Отображение данных: заполнение типичных клиентских компонентов, таких как таблицы и списки, и тем самым
обеспечение хорошего пользовательского опыта для конечного пользователя
- Добавление стран в цикл. Для простоты мы научимся реализовывать выборку.
и отображать задачи, сосредоточив внимание на сущности «Город»: в последней части главы мы будем использовать
знания, полученные для применения тех же методов к субъекту «Страна», а также

В этой главе мы рассмотрим темы выборки и отображения, добавив несколько взаимодействий клиент-сервер.
обрабатывается стандартными цепочками запросов/ответов HTTP; само собой разумеется, что Angular будет играть
здесь важную роль, а также пару полезных пакетов, которые помогут нам достичь нашей цели.

# Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, а также
следующую внешнюю библиотеку:
- System.Linq.Dynamic.Core (пакет .NET Core NuGet) для приложения WorldCitiesAPI ASP.NET.
Как всегда, желательно не устанавливать их сразу; мы собираемся привезти их во время
эту главу, чтобы лучше понять их цель в рамках нашего проекта.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/master/Chapter_06/.

# Получение данных
Как мы уже знаем из главы 2 «Подготовка», чтение данных из базы данных в основном является задачей
чтобы приложение Angular (интерфейсная часть) отправляло HTTP-запросы приложению ASP.NET (внутренняя часть) и
получение соответствующих ответов HTTP соответственно; эта передача данных будет в основном реализована с использованием нотации объектов JavaScript (JSON), облегченного формата обмена данными, который изначально
поддерживается обеими платформами.
В этом разделе мы в основном будем говорить о HTTP-запросах и ответах, посмотрим, как мы можем получать данные из
приложение ASP.NET и выложите несколько необработанных примеров пользовательского интерфейса с использованием компонентов Angular, которые будут далее
уточняется в следующих разделах.
Мы готовы? Давайте начнем!

# Запросы и ответы
Давайте начнем с рассмотрения тех HTTP-запросов и ответов, с которыми мы будем иметь дело: нажмите F5, чтобы запустить
проекты WorldCities и WorldCitiesAPI в режиме отладки — или щелкните правой кнопкой мыши WorldCitiesAPI.
проект и выберите «Отладка» > «Начать новый экземпляр», чтобы запустить только этот проект, и введите следующую команду:
URL-адрес в адресной строке браузера: https://localhost:40443/api/Cities/.
Если мы все сделали правильно, мы должны увидеть список городов, каждый из которых имеет уникальный идентификатор. Из этого списка,
мы можем легко выбрать идентификатор каждого города и добавить его в наш URL-адрес, чтобы получить только этот конкретный город: например, мы можем использовать 13, что в нашем конкретном сценарии соответствует городу Нью-Йорк.

![image](https://github.com/artemovsergey/Angular/assets/26972859/8492c941-d150-499f-978e-382d6aa13191)

Важное примечание: идентификаторы различных городов и стран, упомянутых в
книга может отличаться от тех, которые присутствуют в собственной базе данных читателя, в зависимости от различных
факторы: версия/прогресс файла городов мира, начальный автоматически увеличивающийся идентификатор
Таблица базы данных [Cities], которую мы использовали для хранения источника данных, и так далее. Не обращайте на это внимания: все
примеры кода должны по-прежнему работать, независимо от разницы в идентификаторе.

Соглашения и значения по умолчанию JSON
Как мы видим, JSON — это, по сути, сериализация нашего объекта City с некоторыми встроенными соглашениями.
например следующее:
- CamelCase вместо PascalCase: у нас есть name вместо Name, CountryId вместо CountryId,
и так далее, а это означает, что все имена и свойства классов PascalCase .NET будут автоматически преобразованы в CamelCase при их сериализации в JSON.
- Никаких отступов и перевода строки/возврата каретки (LF/CR): все сложено в один
строка текста
Эти соглашения являются параметрами по умолчанию, установленными ASP.NET при работе с выходными данными JSON. Большинство
их можно изменить, добавив некоторые параметры настройки в промежуточное программное обеспечение MVC. Однако мы
не нужно этого делать, поскольку они прекрасно поддерживаются Angular, и это то, что мы собираемся использовать для
разобраться с этими строками; нам просто нужно убедиться, что интерфейсы Angular, которые мы создадим, будут отражать
имена и свойства классов сущностей имеют значение CamelCase.

Любой, кто хочет знать, почему они выбрали CamelCase вместо PascalCase по умолчанию.
опция сериализации должна проверить следующую ветку GitHub: https://github.com/aspnet/MVC/проблемы/4283.

Тем не менее, если мы хотим повысить читаемость вывода JSON, мы можем добавить отступы, чтобы
что мы сможем понять больше этих результатов.
Для этого откройте файл Program.cs и добавьте следующие параметры в builder.Services.
Метод AddControllers (выделены новые/обновленные строки):

```Csharp
builder.Services.AddControllers()
 .AddJsonOptions(options =>
 {
 options.JsonSerializerOptions.WriteIndented = true;
 });
```
Сохраните файл, нажмите F5 и еще раз введите предыдущий URL-адрес, чтобы увидеть следующие изменения:

![image](https://github.com/artemovsergey/Angular/assets/26972859/52c168c5-5481-4173-9048-f8f604f2fcc1)

Начнем: как мы видим, включив эту опцию, JSON становится намного более читабельным, с
Angular все еще может получить к нему правильный доступ. Однако такое изменение также окажет (незначительное) влияние
на производительность, поскольку все эти переводы строк и пробелы немного увеличивают общий размер
всех HTTP-ответов, возвращаемых серверным API.
Если бы мы хотели переключиться с CamelCase (по умолчанию) на PascalCase, мы могли бы также добавить следующую опцию:

```Csharp
options.JsonSerializerOptions.PropertyNamingPolicy = null;
```
Тем не менее, ради этих примеров проектов мы предпочитаем сохранить соглашения по умолчанию (без отступов и верблюжьего регистра): именно по этой причине мы закомментируем эти два варианта.

Те, кто хочет раскомментировать эти параметры, могут это сделать: просто имейте в виду, что если
Вместо CamelCase используется PascalCase, примеры кода Angular, показанные в этой главе.
– и в последующих главах – необходимо будет соответствующим образом изменить.

# (Очень) длинный список
Давайте теперь перейдем к нашему приложению Angular и создадим образец компонента для отображения списка городов. Мы уже создали компонент в главе 4 «Взаимодействие с внешним и внутренним интерфейсом», поэтому знаем, что делать:
1. Откройте командную строку.
2. Перейдите в папку /src/app/ проекта WorldCities Angular.
3. Введите nggenerateComponent Cities --module=app --skip-tests, чтобы создать следующее:
новые файлы с помощью Angular CLI:
• /src/app/cities/cities.comComponent.ts
• /src/app/cities/cities.comComponent.html
• /src/app/cities/cities.comComponent.scss
4. В обозревателе решений создайте дополнительный файл city.ts в папке /src/app/cities/.
проекта WorldCities Angular
После этого заполните новые файлы следующим содержимым.

# city.ts
Откройте файл /src/app/cities/city.ts и добавьте следующее:

```ts
export interface City {
 id: number;
 name: string;
 lat: number;
 lon: number;
}
```
Этот небольшой файл содержит интерфейс нашего города, который мы будем использовать в файле класса CitiesComponent. С
в конечном итоге мы собираемся использовать его и в других компонентах, лучше создать его в отдельном
файл и украсьте его оператором экспорта, чтобы мы могли использовать его и там, когда
приходит время.

# cities.component.ts
Откройте файл /src/app/cities/cities.component.ts и замените его содержимое следующим:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public cities!: City[];
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.http.get<City[]>(environment.baseUrl + 'api/Cities')
 .subscribe(result => {
 this.cities = result;
 }, error => console.error(error));
 }
}
```
Как мы видим, мы добавили ссылку на импорт в интерфейс City, который создали недавно. Мы также
использовал метод перехвата жизненного цикла ngOnInit() для выполнения HTTP-запроса, который получит города,
точно так же, как мы это делали в главе 4 «Взаимодействие с внешним и внутренним интерфейсом» для нашего предыдущего приложения HealthCheck.

cities.component.html
Откройте файл /src/app/cities/cities.comComponent.html и добавьте следующее:

```html
<h1>Cities</h1>
<p>Here's a list of cities: feel free to play with it.</p>
<p *ngIf="!cities"><em>Loading...</em></p>
<table class='table table-striped' aria-labelledby="tableLabel"
[hidden]="!cities">
 <thead>
 <tr>
 <th>ID</th>
 <th>Name</th>
 <th>Lat</th>
 <th>Lon</th>
 </tr>
 </thead>
 <tbody>
 <tr *ngFor="let city of cities">
 <td>{{ city.id }}</td>
 <td>{{ city.name }}</td>
 <td>{{ city.lat }}</td>
 <td>{{ city.lon }}</td>
 </tr>
 </tbody>
</table>
```
Как мы видим, предыдущая структура HTML не имеет ничего особенного: это просто заголовок, абзац и
таблица с некоторой стандартной логикой загрузки, чтобы пользователь знал, что мы будем асинхронно загружать данные
через (надеюсь) короткое время. Однако есть как минимум два качества, заслуживающие пары слов.

# Базовый стиль таблицы
Если мы посмотрим на HTML-элемент <table>, то легко заметим, что применили несколько CSS-элементов.
классы там: столовые и столовые-полосатые. Это два наиболее широко используемых класса интерфейсной платформы Bootstrap, когда дело доходит до стилизации таблиц. Короче говоря, первый будет применять некоторые
основные правила интервалов и типографики, в то время как последние изменят цвет фона таблицы
нечетные ряды, воспроизводящие таким образом эффект «полосатости»; и то и другое значительно повысит читабельность таблицы

Чтобы узнать больше о Bootstrap, его компонентах пользовательского интерфейса и функциях стилизации макета, проверьте
официальную документацию можно найти по следующему URL-адресу: https://getbootstrap.com.

Поскольку мы не используем Bootstrap для этого проекта, нам придется создать эти классы самостоятельно в
файл города.компонент.scss. Однако, прежде чем сделать это, стоит обратить внимание еще на одну вещь.

# The [hidden] attribute
Если мы продолжим смотреть на HTML-код файла city.comComponent.html, то увидим, что вскоре после
В определении класса таблицы элемент <table> имеет странный [скрытый] атрибут. Почему оно там,
и почему это в квадратных скобках?
На самом деле скрытый атрибут — это атрибут контента, действительный для HTML5, который можно законно
устанавливается для любого элемента HTML. Роль, которую он должен играть, очень похожа на отображение CSS: нет
Настройка: указывает браузеру, что элемент и все его потомки не должны быть видимы или
понятен любому пользователю. Другими словами, это просто еще один способ скрыть контент от пользователя.

Что касается квадратных скобок, то это всего лишь синтаксис Angular, используемый для определения привязки свойства, то есть
Свойство или атрибут HTML в шаблоне компонента (наш HTML-файл), который получает свое значение из
переменная, свойство или выражение, определенные в классе компонента (наш файл .ts). Стоит отметить
что такая привязка протекает в одном направлении: от класса компонента (источника) к элементу HTML.
внутри шаблона компонента (целевого).
Как прямое следствие того, что мы только что сказали, каждый раз, когда исходное значение оказывается истинным,
Свойству HTML (или атрибуту) между квадратными скобками также будет присвоено значение true (и наоборот); этот
это отличный способ справиться со многими атрибутами HTML, которые работают с логическими значениями, потому что мы можем
динамически устанавливать их на протяжении всего жизненного цикла компонента. Именно это мы и делаем с
Элемент <table> в предыдущем блоке кода: его скрытый атрибут будет иметь значение false до тех пор, пока города
переменная компонента заполняется фактическими городами, полученными с сервера, что произойдет только тогда, когда
модуль HttpClient завершает свою задачу запроса/ответа. Неплохо, правда?
Подождите: разве это не то же самое поведение, что и структурная директива *ngIf, которую мы уже знаем из
Глава 4. Взаимодействие с внешним и внутренним интерфейсом? Почему вместо этого мы используем этот [скрытый] атрибут?
Это очень хороший вопрос, который дает нам возможность прояснить разницу между этими двумя похожими, но не идентичными подходами:
- Структурная директива *ngIf добавляет или удаляет элемент из объектной модели документа.
(DOM) на основе соответствующего условия или выражения; это означает, что элемент будет
инициализироваться и/или удаляться (вместе со всеми дочерними элементами, событиями и т. д.) каждый раз
меняется его статус.
- Скрытый атрибут, очень похожий на настройку CSS display: none, будет только указывать браузеру
показать элемент или скрыть элемент от пользователя; это означает, что элемент будет
все еще быть там, будучи полностью доступным и достижимым (например, с помощью JavaScript или другого
действия по манипулированию DOM).

Как мы видим, взглянув на предыдущий HTML-код, мы используем их оба: структурный элемент *ngIf.
Директива добавляет или удаляет элемент загрузки <p>, а привязка атрибута [hidden] показывает или
скрывает основную <таблицу>. Мы решили сделать это не просто так: у элемента <p> не будет дочерних элементов.
или зависящие от него события, а атрибут <table> вскоре станет сложным объектом с множеством
функций для инициализации и сохранения в DOM. Использование атрибута [hidden] для этого также будет
обеспечивает лучшую производительность, чем *ngIf, когда нам нужно показать/скрыть множество элементов DOM.

# cities.component.scss
Пришло время добавить эти классы таблиц в наш файл SCSS, как мы и планировали сделать недавно.
Откройте файл /src/app/cities/cities.comComponent.scss и добавьте следующий код SASS:

```scss
table.table {
 width: 100%;
 margin-bottom: 1rem;
 color: #212529;
 vertical-align: top;
 border-color: #dee2e6;
 &.table-striped > tbody > tr:nth-of-type(even) {
 background-color: rgba(0, 0, 0, 0.05);
 color: #212529;
 }
 &.table-hover > tbody > tr:hover {
 background-color: rgba(0, 0, 0, 0.075);
 color: #212529;
 }
}
```
Вот и все, по крайней мере, на данный момент. Наш CitiesComponent достаточно хорош для отправки: нам просто нужно интегрировать его.
это в нашем приложении Angular.

# app-routing.module.ts
Как мы уже знаем, этот компонент может быть загружен – и доступен только с помощью маршрутизации на стороне клиента Angular – если мы добавим его в файл app-routing.module.ts следующим образом (новые строки
выделено):

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { HomeComponent } from './home/home.component';
import { CitiesComponent } from './cities/cities.component';
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'cities', component: CitiesComponent }
];
@NgModule({
 imports: [RouterModule.forRoot(routes)],
 exports: [RouterModule]
})
export class AppRoutingModule { }
```
Начнем: теперь нам нужно разобраться с пользовательским интерфейсом.

# nav-component.html

Точнее, нам нужно добавить ссылку на новый маршрут компонента в навигаторе приложения.
компонент; в противном случае пользователь не сможет увидеть (и, следовательно, получить доступ) к нему через пользовательский интерфейс.
Для этого откройте файл nav-menu-comComponent.html и добавьте следующие (выделенные) строки:

```html
<header>
 <mat-toolbar color="primary">
 <button mat-icon-button [routerLink]="['/']">
 <mat-icon>
 home
 </mat-icon>
 </button>
 <a mat-flat-button color="primary" [routerLink]="['/cities']">
 Cities
 </a>
 </mat-toolbar>
</header>
```
Вот и все. Теперь мы можем запустить наше приложение, щелкнуть ссылку «Города», которая появится в правом верхнем углу.
экрана и получите следующий результат:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5c7aec4a-2c7f-4fed-a080-5ba0ba507730)

Как мы видим, глядя на вертикальную полосу прокрутки справа, мы были бы ошеломлены огромным
HTML-таблица, состоящая из более чем 41 000 строк!
Это еще один огромный стресс для производительности как для ASP.NET, так и для Angular, который должен пройти с
с честью на любой средней машине разработки, поскольку обе среды могут хорошо справляться со своими задачами.
соответствующие задачи.
Однако такой результат пользовательского интерфейса определенно бесполезен с точки зрения пользовательского опыта: мы не можем разумно
ожидаем, что наши конечные пользователи будут счастливы, если мы заставим их перемещаться по HTML-таблице размером примерно в 41 тысячу строк с помощью
браузер. Они бы сошли с ума, пытаясь найти город, который ищут!
Чтобы решить эти основные проблемы с удобством использования, нам необходимо реализовать несколько важных функций, которые часто
используется для работы с толстыми HTML-таблицами: разбиение на страницы, сортировка и фильтрация.

# Обслуживание данных с помощью Angular Material
Чтобы реализовать таблицу с функциями разбиения по страницам, сортировки и фильтрации, мы собираемся использовать Angular Material,
библиотека компонентов пользовательского интерфейса, которую мы уже представили в главе 4 «Взаимодействия с внешним и внутренним интерфейсом».
Однако, прежде чем добавлять новые компоненты Angular Material, мы воспользуемся возможностью применить немного
рефакторинг в соответствии с тем, как мы реализовали существующие.

# Добавление AngularMaterialModule
В обозревателе решений перейдите в папку /src/app/ и создайте новый angular-material.module.
ts и заполните его следующим содержимым:

```ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';
@NgModule({
 imports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule
 ],
 exports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule
 ]
})
export class AngularMaterialModule { }
```
Это совершенно новый модуль, который мы собираемся использовать для всех модулей Angular Material, которые хотим использовать.
реализовать в нашем приложении. Как мы видим, взглянув на предыдущий код, мы уже включили
каждый компонент Angular Material, который мы научились использовать до сих пор. Размещаем их здесь вместо использования
файл app.module.ts будет уменьшать размер этого файла, что отлично подходит для управления проектом.
Излишне говорить, что для правильной работы этого модуля-контейнера нам необходимо добавить его в существующее приложение.
файл модуль.ts. Откройте этот файл, удалите все ссылки на модули Mat* в файлах import, imports[] и
разделы Exports[] и замените их следующими (выделенными) строками:

```ts
//.. existing code
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AngularMaterialModule } from './angular-material.module';
//.. existing code
 imports: [
 BrowserModule,
 HttpClientModule,
AppRoutingModule,
 BrowserAnimationsModule,
 AngularMaterialModule
 ],
//.. existing code
```
Начнем: теперь все, что мы собираемся поместить в файл angular-material.module.ts, также будет
упоминается в нашем приложении.

# Представляем MatTable
Модуль Angular Material, который мы собираемся использовать, — это MatTable, который предоставляет интерфейс в стиле Material Design.
Таблица HTML, которую можно использовать для отображения строк данных. Мы кратко представили его еще в главе 4 «Внешний интерфейс».
и внутренние взаимодействия, когда мы обновили пользовательский интерфейс FetchDataComponent и HealthCheckComponent.
в нашем приложении HealthCheck. Теперь мы научимся правильно использовать его, чтобы заменить наши простые HTML-таблицы, которые
позволит нам воспользоваться его уникальными и удобными функциями.

# Обновление AngularMaterialModule
Поскольку мы планируем представить новый модуль Angular Material, первое, что нам нужно сделать, это добавить
его ссылки на наш новый AngularMaterialModule.
Откройте файл /src/app/angular-material.module.ts и добавьте следующие выделенные строки:

```ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTableModule } from '@angular/material/table';
@NgModule({
 imports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule,
 MatTableModule
 ],
 exports: [
 MatButtonModule,
 MatIconModule,
 MatToolbarModule,
 MatTableModule
 ]
})
export class AngularMaterialModule { }
```
Теперь мы можем использовать преимущества MatTableModule во всех компонентах нашего приложения Angular.

# Обновление компонента Cities
Начнем с CitiesComponent.
Откройте файл /src/app/cities/cities.comComponent.ts и добавьте следующие (выделенные) строки:

```ts
// ...existing code...
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: City[];
 constructor(private http: HttpClient) {
 }
}
// ...existing code...

```

Сразу после этого откройте файл /src/app/cities/cities.comComponent.html и замените наш предыдущий
реализацию таблицы с новым MatTableModule следующим образом (обновленный код выделен):

```html
<h1>Cities</h1>
<p>Here's a list of cities: feel free to play with it.</p>
<p *ngIf="!cities"><em>Loading...</em></p>
<table mat-table [dataSource]="cities"
 class="mat-elevation-z8"
 [hidden]="!cities">
 <!-- Id Column -->
 <ng-container matColumnDef="id">
 <th mat-header-cell *matHeaderCellDef>ID</th>
 <td mat-cell *matCellDef="let city">{{city.id}}</td>
 </ng-container>
 <!-- Name Column -->
 <ng-container matColumnDef="name">
 <th mat-header-cell *matHeaderCellDef>Name</th>
 <td mat-cell *matCellDef="let city">{{city.name}}</td>
 </ng-container>
 <!-- Lat Column -->
 <ng-container matColumnDef="lat">
 <th mat-header-cell *matHeaderCellDef>Latitude</th>
 <td mat-cell *matCellDef="let city">{{city.lat}}</td>
 </ng-container>
 <!-- Lon Column -->
 <ng-container matColumnDef="lon">
 <th mat-header-cell *matHeaderCellDef>Longitude</th>
 <td mat-cell *matCellDef="let city">{{city.lon}}</td>
 </ng-container>
 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>
```
Как мы видим, MatTableModule в некотором роде имитирует поведение стандартной HTML-таблицы, но с подходом на основе шаблонов для каждого столбца; шаблон содержит ряд вспомогательных структурных директив
(применяется с использованием синтаксиса *<directiveName>), который можно использовать для обозначения определенных разделов шаблона и
определить фактическую роль раздела шаблона. Как мы видим, все эти директивы заканчиваются постфиксом Def.
Вот наиболее подходящие из тех, которые использовались в предыдущем коде:
- Привязка атрибута [скрытый] не является неожиданностью, поскольку она уже присутствовала в предыдущей таблице.
с той же целью: держать таблицу скрытой до тех пор, пока города не будут загружены.
- Директива matColumnDef идентифицирует данный столбец с помощью уникального ключа.
- Директива matHeaderCellDef определяет, как отображать заголовок для каждого столбца.
- Директива matCellDef определяет, как отображать ячейки данных для каждого столбца.
- Директива matHeaderRowDef, которую можно найти в конце предыдущего кода, определяет элемент конфигурации для строки заголовка таблицы и порядок отображения заголовка.
столбцы. Как мы видим, у нас было это выражение директивы, указывающее на переменную компонента.
называется displayColumns, который мы заранее определили в файле city.comComponent.ts; этот
переменная содержит массив, содержащий все ключи столбцов, которые мы хотим показать, которые должны быть
идентичны именам, указанным в различных директивах matColumnDef.
Прежде чем тестировать нашу новую реализацию на основе MatTable, нам необходимо обновить стиль нашего компонента.
правила.
Откройте файл /src/app/cities/cities.comComponent.scss и замените его содержимое следующим:

```scss
table.mat-table {
 width: 100%;
}
```

Как мы видим, большинство предыдущих правил CSS утеряны, поскольку нам больше не нужно стилизовать HTML.
table вручную: Angular Material выполнит за нас большую часть работы по стилизации.


Теперь мы можем нажать F5 и перейти к представлению «Города», чтобы увидеть, как выглядит наша новая таблица. Это может
можно увидеть на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/95741422-28ea-4e73-a7f4-c3580beb2397)

Хорошо, Material Design действительно существует, но у таблицы те же проблемы с UI/UX, что и раньше! Для одного,
это еще очень долго; давайте исправим это, реализовав функцию пейджинга.

# Добавление нумерации страниц с помощью MatPaginatorModule
Теперь, когда мы используем Angular Material, реализация нумерации страниц стала довольно простой задачей. Во-первых
нам нужно добавить ссылку на MatPaginatorModule в файл angular-material.module.ts, просто
как мы недавно сделали с MatTableModule.

Вот оператор импорта, который нужно добавить в конец уже существующих, сразу после MatTableModule:

```ts
import { MatPaginatorModule } from '@angular/material/paginator';
```
Не забудьте также добавить его в коллекции импорта и экспорта @NgModule.

# Пейджинг на стороне клиента
Теперь, когда мы сослались на новый модуль, мы можем открыть файл city.comComponent.ts и импортировать его.
сервисы MatPaginator, MatTableDataSource и ViewChild следующим образом (выделены новые и обновленные строки):

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: MatTableDataSource<City>;
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 this.http.get<City[]>(environment.baseUrl + 'api/Cities')
 .subscribe(result => {
 this.cities = new MatTableDataSource<City>(result);
 this.cities.paginator = this.paginator;
}, error => console.error(error));
 }
}
```

Как мы видим, мы использовали декоратор @ViewChild, чтобы задать запрос статического представления и сохранить его результат в
переменная пагинатора; уделим пару минут предназначению такого декоратора и зачем
нам это нужно.
Короче говоря, декоратор @ViewChild можно использовать для получения ссылки на элемент шаблона DOM.
изнутри компонента Angular, что делает его очень полезной функцией всякий раз, когда нам нужно манипулировать свойствами элемента. Как мы видим из предыдущего кода, декоратор определен
используя параметр селектора, который необходим для доступа к элементу DOM: этот селектор может быть классом
имя (если класс имеет декоратор @Component или @Directive), ссылочную переменную шаблона,
поставщик, определенный в дереве дочерних компонентов, и так далее.
В нашем конкретном сценарии мы использовали имя класса MatPaginator, поскольку у него есть @Component.
декоратор.

Пока мы этим занимаемся, может быть полезно знать, что декоратор @ViewChild также принимает
второй параметр, который был обязательным до Angular 8 и стал необязательным, начиная с Angular.
9: статический флаг, который может иметь значение true или false (начиная с Angular 9, по умолчанию он равен false).
Если для этого флага явно установлено значение true, @ViewChild извлекается из шаблона перед
выполняется фаза обнаружения изменений (то есть даже до жизненного цикла ngOnInit()); наоборот,
задача извлечения компонента/элемента решается либо после этапа обнаружения изменений
если элемент находится внутри вложенного представления (например, представления с условным отображением *ngIf)
директиву), или до обнаружения изменений, если это не так.
Поскольку мы использовали привязку атрибута [скрытый] в шаблоне вместо *ngIf
директиве, наш MatPaginator не столкнется с проблемами инициализации, даже без необходимости
установите этот флаг в значение true.
Для получения дополнительной информации о декораторе @ViewChild мы предлагаем вам посмотреть
в документации Angular: https://angular.io/api/core/ViewChild.

После этого откройте файл города.компонент.html и добавьте следующую директиву нумерации страниц (выделено) сразу после закрывающего тега </table>:

```html
<!-- ...existing code... -->
 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>
<!-- Pagination directive -->
<mat-paginator [hidden]="!cities"
 [pageSize]="10"
[pageSizeOptions]="[10, 20, 50]"
 showFirstLastButtons></mat-paginator>
```
Как мы видим, мы снова использовали привязку атрибута [hidden], чтобы скрыть пагинатор до тех пор, пока не будет
города были загружены. Другие свойства, которые мы видим в элементе <mat-paginator> configure
некоторые параметры пользовательского интерфейса MatPaginatorModule, такие как размер страницы по умолчанию и массив всех страниц.
параметры размера, которые мы хотим сделать доступными для пользователей.
Теперь мы можем нажать F5 и посмотреть на наши усилия:

![image](https://github.com/artemovsergey/Angular/assets/26972859/f4dcc38d-53e4-4165-88b7-25818e250882)

Теперь в нашей таблице показаны только первые 10 городов. У него также есть аккуратный пагинатор в правом нижнем углу.
который можно использовать для навигации по различным страницам с помощью стрелок. Наш конечный пользователь может даже выбрать
сколько элементов на странице отображать с помощью аккуратного раскрывающегося списка (10, 20 или 50 городов на странице, как указано в свойстве [pageSizeOptions]). Похоже, что мы это сделали!

Однако, если мы подумаем об этом, мы легко можем признать, что мы еще не совсем достигли цели. Конечно, теперь наш
пользователи могут удобно просматривать таблицу, не прокручивая ее вверх и вниз целую вечность, но это не требует
гениально понимать, что все эти строки по-прежнему передаются в клиентский браузер: мы никогда
сообщил серверу, что он должен поддерживать постраничный запрос, поэтому мы по-прежнему извлекаем все города из наших данных
провайдера (и через API-контроллер ASP.NET), как и раньше: по сути, они просто
не отображается во внешнем интерфейсе.
По сути, это означает, что мы по-прежнему имеем то же влияние на производительность, что и раньше на сервере.
сторона (огромный результат SQL-запроса, массивный JSON) и лишь частичное улучшение производительности на клиенте
сторона: даже если теперь в DOM добавляется меньше элементов HTML, все равно остается много строк HTML, которые нужно
показать/скрыть при каждом действии пагинатора, что приводит к смене страницы.
Чтобы смягчить вышеупомянутые проблемы, нам необходимо перейти от подкачки на стороне клиента к подкачке на стороне сервера.
пейджинг – именно этим мы и займемся в следующем разделе.

# Пейджинг на стороне сервера
Реализация пейджинга на стороне сервера немного сложнее, чем его аналог на стороне клиента. Вот что
нам нужно сделать (и где):
- WorldCitiesAPI (проект ASP.NET). Измените наш класс CitiesController, чтобы он поддерживал
страничные HTTP-запросы GET
- WorldCitiesAPI (проект ASP.NET). Создайте новый класс ApiResult, который мы можем использовать для улучшения.
ответ JSON наших контроллеров ASP.NET
- WorldCities (проект Angular). Измените наш Angular-компонент city.controller.ts – и
текущая конфигурация MatPaginatorModule – чтобы он мог выдать новый запрос GET
и разобраться с новым ответом JSON
Давай сделаем это!

# CitiesController
The GetCities method of our CitiesController returns a JSON array of all the ~41,000 cities in our
database by default; that’s definitely a no-go in terms of server-side performance, so we need to change
it. Ideally, we would like to only return a small number of Cities, which is something we can easily
pull off by adding some (required) variables to the method signature, such as pageIndex and pageSize.
Here’s how we could change that to enforce such behavior (updated lines highlighted):

```Csharp
[HttpGet]
public async Task<ActionResult<IEnumerable<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10)
{
return await _context.Cities
 .Skip(pageIndex * pageSize)
 .Take(pageSize)
 .ToListAsync();
}
```
Вот и все; мы также указали некоторые разумные значения по умолчанию для этих переменных, чтобы избежать огромных затрат.
Ответы JSON по умолчанию.
Давайте быстро проверим то, что мы только что сделали: нажмите F5 и введите следующий URL-адрес в адресную строку браузера:
https://localhost:40443/api/Cities/?pageIndex=0&pageSize=10.
Вот что у нас должно получиться:

![image](https://github.com/artemovsergey/Angular/assets/26972859/14fca0aa-6cc4-4aec-a73a-6a43f40a66be)

Определенно кажется, что наш план работает!
Однако есть серьезная проблема, с которой нам придется разобраться: если мы просто вернем массив JSON из 10 городов,
у нашего приложения Angular не будет возможности узнать, сколько городов присутствует в нашей базе данных.
Без этой информации маловероятно, что пагинатор будет работать так, как он есть.
сделал, когда мы реализовали нумерацию страниц на стороне клиента на раннем этапе.
Короче говоря, нам нужно найти способ сообщить нашему Angular-приложению некоторую дополнительную информацию, например:
следующее:
- Общее количество доступных страниц (и/или записей).
- Текущая страница
- Количество записей на каждой странице.
По правде говоря, единственная необходимая информация — это первая, поскольку тогда клиент Angular сможет
следить за двумя другими; однако, поскольку нам нужно реализовать это, мы могли бы также вернуть
их всех, что делает нашу интерфейсную жизнь намного проще.

Для этого лучшее, что мы можем сделать, — это создать специальный класс типа ответа.
теперь буду много использовать.

# ApiResult
В обозревателе решений щелкните правой кнопкой мыши папку Data и добавьте новый файл класса ApiResult.cs C#. Затем,
заполните его следующим содержимым:

```Csharp
using Microsoft.EntityFrameworkCore;
namespace WorldCitiesAPI.Data
{
 public class ApiResult<T>
 {
 /// <summary>
 /// Private constructor called by the CreateAsync method.
 /// </summary>
 private ApiResult(
 List<T> data,
 int count,
 int pageIndex,
 int pageSize)
 {
 Data = data;
 PageIndex = pageIndex;
 PageSize = pageSize;
 TotalCount = count;
 TotalPages = (int)Math.Ceiling(count / (double)pageSize);
 }
 #region Methods
 /// <summary>
 /// Pages a IQueryable source.
 /// </summary>
 /// <param name="source">An IQueryable source of generic
 /// type</param>
 /// <param name="pageIndex">Zero-based current page index
 /// (0 = first page)</param>
 /// <param name="pageSize">The actual size of each
 /// page</param>
 /// <returns>
 /// A object containing the paged result
/// and all the relevant paging navigation info.
 /// </returns>
 public static async Task<ApiResult<T>> CreateAsync(
 IQueryable<T> source,
 int pageIndex,
 int pageSize)
 {
 var count = await source.CountAsync();
 source = source
 .Skip(pageIndex * pageSize)
 .Take(pageSize);
 var data = await source.ToListAsync();
 return new ApiResult<T>(
 data,
 count,
 pageIndex,
 pageSize);
 }
 #endregion
 #region Properties
 /// <summary>
 /// The data result.
 /// </summary>
 public List<T> Data { get; private set; }
 /// <summary>
 /// Zero-based index of current page.
 /// </summary>
 public int PageIndex { get; private set; }
 /// <summary>
 /// Number of items contained in each page.
 /// </summary>
 public int PageSize { get; private set; }
 /// <summary>
 /// Total items count
 /// </summary>
public int TotalCount { get; private set; }
 /// <summary>
 /// Total pages count
 /// </summary>
 public int TotalPages { get; private set; }
 /// <summary>
 /// TRUE if the current page has a previous page,
 /// FALSE otherwise.
 /// </summary>
 public bool HasPreviousPage
 {
 get
 {
 return (PageIndex > 0);
 }
 }
 /// <summary>
 /// TRUE if the current page has a next page, FALSE otherwise.
 /// </summary>
 public bool HasNextPage
 {
 get
 {
 return ((PageIndex +1) < TotalPages);
 }
 }
 #endregion
 }
}
```

Этот класс ApiResult содержит некоторые действительно интересные вещи. Попробуем обобщить самое актуальное.
вещи:
- Данные: свойство типа List<T>, которое будет использоваться для хранения выгружаемых данных (оно будет
переведено в массив JSON)
- PageIndex: возвращает индекс текущей страницы, начинающийся с нуля (0 для первой страницы, 1 для
второй и так далее)
- PageSize: возвращает общий размер страницы (TotalCount/PageSize).
- TotalCount: возвращает общее количество элементов.
- TotalPages: возвращает общее количество страниц с учетом общего количества элементов.
(Общее количество/Размер страницы)
-  HasPreviousPage: возвращает True, если текущая страница имеет предыдущую страницу, в противном случае — False.
-  HasNextPage: возвращает True, если у текущей страницы есть следующая страница, в противном случае — False.
Эти свойства — именно то, что мы искали; основная логика для расчета их значений
должно быть довольно легко понять, посмотрев на предыдущий код.
Помимо этого, класс в основном вращается вокруг статического метода CreateAsync<T>(IQueryable<T>
source, int pageIndex, int pageSize), который можно использовать для разбиения на страницы Entity Framework.
Объект IQueryable.

Стоит отметить, что класс ApiResult не может быть создан извне, поскольку
его конструктор помечен как частный; единственный способ создать его — использовать статический
Фабричный метод CreateAsync. Для этого есть веские причины: поскольку это невозможно
чтобы определить асинхронный конструктор, мы прибегли к использованию статического асинхронного метода, который
возвращает экземпляр класса; конструктор был установлен в приватный режим, чтобы разработчики не могли
от его прямого использования вместо фабричного метода, поскольку это единственный разумный способ
создать экземпляр этого класса.

Вот как мы можем использовать наш новый класс ApiResult в методе GetCities нашего
Контроллер городов:

```Csharp
// GET: api/Cities
// GET: api/Cities/?pageIndex=0&pageSize=10
[HttpGet]
public async Task<ActionResult<ApiResult<City>>> GetCities(
 int pageIndex = 0,
 int pageSize = 10)
{
 return await ApiResult<City>.CreateAsync(
 _context.Cities.AsNoTracking(),
 pageIndex,
 pageSize
 );
}
```
Вот так! Теперь у нас должны быть 10 городов и вся информация, которую мы искали.

Ничего не стоит, поскольку мы выполняем задачу только для чтения, мы использовали
Метод расширения AsNoTracking(), который мы представили в главе 5 «Модель данных с
Entity Framework Core, чтобы предотвратить захват всех сущностей EF Core и тем самым избежать
нетривиальное влияние на производительность.

Давайте нажмем F5 и перейдем к тому же URL-адресу, что и раньше, чтобы увидеть, что изменилось: https://localhost:40443/
API/Cities/?pageIndex=0&pageSize=10.
Вот обновленный ответ в формате JSON:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5497e8c6-738c-469e-b556-65ee3117909a)

Если мы прокрутим результат вниз до нижней части, мы увидим, что конечная точка не возвращает JSON.
массив больше; новый результирующий контент представляет собой объект JSON, составляющий наш предыдущий массив (в данных
собственности), а также новые объекты недвижимости, необходимые нам для выполнения задач по разбиению страницы.
Давайте теперь перейдем ко всем Angular CitiesComponent и обновим его, чтобы использовать этот новый, безопасный способ.
получение наших городов с сервера.

# CitiesComponent
Единственные файлы Angular, которые нам нужно изменить, это следующие:
- Файл CitiesComponent TypeScript, в который мы помещаем всю логику извлечения данных,
теперь нам нужно обновить
- HTML-файл CitiesComponent для привязки определенного события к нашему элементу MatPaginator.
Давай сделаем это.
Откройте файл города.компонент.тс и внесите следующие изменения (новые/обновленные строки выделены):

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from './../../environments/environment';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, PageEvent } from '@angular/material/paginator';
import { City } from './city';
@Component({
 selector: 'app-cities',
 templateUrl: './cities.component.html',
 styleUrls: ['./cities.component.scss']
})
export class CitiesComponent implements OnInit {
 public displayedColumns: string[] = ['id', 'name', 'lat', 'lon'];
 public cities!: MatTableDataSource<City>;
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 constructor(private http: HttpClient) {
 }
 ngOnInit() {
 var pageEvent = new PageEvent();
 pageEvent.pageIndex = 0;
 pageEvent.pageSize = 10;
 this.getData(pageEvent);
 }
 getData(event: PageEvent) {
 var url = environment.baseUrl + 'api/Cities';
 var params = new HttpParams()
 .set("pageIndex", event.pageIndex.toString())
 .set("pageSize", event.pageSize.toString());
 this.http.get<any>(url, { params })
 .subscribe(result => {
 this.paginator.length = result.totalCount;
this.paginator.pageIndex = result.pageIndex;
 this.paginator.pageSize = result.pageSize;
 this.cities = new MatTableDataSource<City>(result.data);
 }, error => console.error(error));
 }
}
```

Попробуем подвести итог тому, что мы здесь сделали:
- Мы удалили HttpClient из метода перехвата жизненного цикла ngOnInit() и поместили весь
вход для получения данных в отдельном методе getData(). Для этого нам пришлось определить
пара внутренних переменных класса для размещения HttpClient и baseUrl для их сохранения.
что мы сможем использовать их несколько раз (то есть при нескольких вызовах getData()).
- Мы изменили логику получения данных, чтобы она соответствовала нашему новому объекту ответа JSON.
- Мы изменили нашу стратегию настройки пагинатора, чтобы вручную задавать значения, которые мы получаем из
серверная часть вместо того, чтобы автоматически их определять; это необходимо сделать, иначе
он просто принял бы во внимание (и разбил на страницы) небольшую часть городов, которые мы получаем при каждом
HTTP-запрос вместо полного пакета.
Что касается файла города.компонент.html, нам просто нужно добавить одну строку в <mat-paginator>.
директива для привязки события getData() к каждому событию подкачки. Вот как это сделать (новая строка
выделено):

```html
<mat-paginator [hidden]="!cities"
 (page)="getData($event)"
 [pageSize]="10"
 [pageSizeOptions]="[10, 20, 50]"
 showFirstLastButtons></mat-paginator>
```
Эта простая привязка играет очень важную роль: она гарантирует, что событие getData() будет вызываться каждый раз.
время, когда пользователь взаимодействует с элементом пагинатора для изменения страницы, запроса предыдущей/следующей страницы, первой/последней страницы, изменения количества отображаемых элементов и т. д. Как мы можем легко
понимаете, такой вызов необходим для разбиения на страницы на стороне сервера, поскольку нам нужно получить обновленные данные
с сервера каждый раз, когда нам приходится отображать разные строки.

Закончив, давайте попробуем новое волшебство, нажав F5, а затем перейдя к представлению «Города». Если мы все сделали правильно, мы должны получить тот же пользовательский интерфейс, который видели раньше:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1e1399ce-3236-4f7d-85dc-6fad7425910f)

Однако на этот раз мы должны увидеть лучшую общую производительность и более быстрое время отклика для
начальная загрузка страницы. Это потому, что мы не имеем дело с тысячами элементов JSON и таблицами HTML.
ряды под капотом; мы получаем только некоторые из них одновременно (то есть те, которые мы видим), используя
наша улучшенная серверная логика.
В то же время навигация между страницами может быть немного медленнее, чем раньше, поскольку мы выдаем
новый HTTP-запрос (и выборка данных) для каждой страницы вместо получения данных в памяти. Однако,
такой недостаток производительности часто предпочтительнее загрузки всего набора данных за один раз, что
это то, что происходит при использовании подкачки на стороне клиента, если только мы не работаем с довольно небольшим набором данных. Как
всегда при решении таких проблем с производительностью не существует «лучшего подхода»: все зависит от
требования приложения, объем затронутых данных и то, чего мы хотим достичь.

Раз с разбиением по страницам покончено, можно наконец заняться сортировкой.

# Добавление сортировки с помощью MatSortModule
Чтобы реализовать сортировку, мы собираемся использовать MatSortModule, который можно реализовать просто
как модуль пагинатора.
На этот раз мы не будем проводить эксперименты с сортировкой на стороне клиента, как это было с ранним разбиением на страницы; собирались
для серверного шаблона с самого начала.

В общих чертах, всякий раз, когда мы имеем дело с разбиением на страницы и сортировкой, нам всегда следует использовать
реализацию на стороне сервера, так как это, вероятно, улучшит общую производительность наших приложений, часто избавляя от необходимости обрабатывать такого рода вещи с помощью
дополнительный клиентский код.

# Расширение APIResult
Начнем с серверной части ASP.NET — другими словами, с проекта WorldCitiesAPI.
Помните класс ApiResult, который мы создали ранее? Пришло время улучшить исходный код, добавив
поддержка сортировки.
В обозревателе решений откройте файл /Data/ApiResult.cs и соответствующим образом обновите его содержимое (новый/
обновленные строки выделены):

```Csharp
using Microsoft.EntityFrameworkCore;
using System.Linq.Dynamic.Core;
using System.Reflection;
namespace WorldCitiesAPI.Data
{
 public class ApiResult<T>
 {
 /// <summary>
 /// Private constructor called by the CreateAsync method.
 /// </summary>
 private ApiResult(
 List<T> data,
 int count,
 int pageIndex,
 int pageSize,
 string? sortColumn,
 string? sortOrder)
 {
 Data = data;
PageIndex = pageIndex;
 PageSize = pageSize;
 TotalCount = count;
 TotalPages = (int)Math.Ceiling(count / (double)pageSize);
 SortColumn = sortColumn;
 SortOrder = sortOrder;
 }
 #region Methods
 /// <summary>
 /// Pages and/or sorts a IQueryable source.
 /// </summary>
 /// <param name="source">An IQueryable source of generic
 /// type</param>
 /// <param name="pageIndex">Zero-based current page index
 /// (0 = first page)</param>
 /// <param name="pageSize">The actual size of each
 /// page</param>
 /// <param name="sortColumn">The sorting column name</param>
 /// <param name="sortOrder">The sorting order ("ASC" or
 /// "DESC")</param>
 /// <returns>
 /// A object containing the IQueryable paged/sorted result
 /// and all the relevant paging/sorting navigation info.
 /// </returns>
 public static async Task<ApiResult<T>> CreateAsync(
 IQueryable<T> source,
 int pageIndex,
 int pageSize,
 string? sortColumn = null,
 string? sortOrder = null)
 {
 var count = await source.CountAsync();
 if (!string.IsNullOrEmpty(sortColumn)
 && IsValidProperty(sortColumn))
 {
 sortOrder = !string.IsNullOrEmpty(sortOrder)
 && sortOrder.ToUpper() == "ASC"
 ? "ASC"
 : "DESC";
source = source.OrderBy(
 string.Format(
 "{0} {1}",
 sortColumn,
 sortOrder)
 );
 }
 source = source
 .Skip(pageIndex * pageSize)
 .Take(pageSize);

 var data = await source.ToListAsync();

 return new ApiResult<T>(
 data,
 count,
 pageIndex,
 pageSize,
 sortColumn,
 sortOrder);
 }
 #endregion
 #region Methods
 /// <summary>
 /// Checks if the given property name exists
 /// to protect against SQL injection attacks
 /// </summary>
 public static bool IsValidProperty(
 string propertyName,
 bool throwExceptionIfNotFound = true)
 {
 var prop = typeof(T).GetProperty(
 propertyName,
 BindingFlags.IgnoreCase |
 BindingFlags.Public |
 BindingFlags.Instance);
 if (prop == null && throwExceptionIfNotFound)
 throw new NotSupportedException(
 string.Format(
$"ERROR: Property '{propertyName}' does not exist.")
 );
 return prop != null;
 }
 #endregion
 #region Properties
 /// <summary>
 /// The data result.
 /// </summary>
 public List<T> Data { get; private set; }
 /// <summary>
 /// Zero-based index of current page.
 /// </summary>
 public int PageIndex { get; private set; }
 /// <summary>
 /// Number of items contained in each page.
 /// </summary>
 public int PageSize { get; private set; }
 /// <summary>
 /// Total items count
 /// </summary>
 public int TotalCount { get; private set; }
 /// <summary>
 /// Total pages count
 /// </summary>
 public int TotalPages { get; private set; }
 /// <summary>
 /// TRUE if the current page has a previous page,
 /// FALSE otherwise.
 /// </summary>
 public bool HasPreviousPage
 {
 get
 {
 return (PageIndex > 0);
}
 }
 /// <summary>
 /// TRUE if the current page has a next page, FALSE otherwise.
 /// </summary>
 public bool HasNextPage
 {
 get
 {
 return ((PageIndex +1) < TotalPages);
 }
 }
 /// <summary>
 /// Sorting Column name (or null if none set)
 /// </summary>
 public string? SortColumn { get; set; }
 /// <summary>
 /// Sorting Order ("ASC", "DESC" or null if none set)
 /// </summary>
 public string? SortOrder { get; set; }
 #endregion
 }
}
```
Мы добавили два новых атрибута sortColumn и sortOrder в статический метод основного класса.
и реализовать их через код; пока мы были там, мы также воспользовались возможностью определить
два новых свойства с одинаковым именем (в верхнем регистре), чтобы сведения о сортировке были частью
Ответ JSON, как и пейджинговый.
Стоит отметить, что, поскольку сейчас мы собираем нашу систему языково-интегрированных запросов (LINQ)-to-SQL
запросы с литеральными данными, поступающими от клиента, мы также добавили новый метод IsValidProperty()
который проверит, что указанный sortColumn действительно существует как типизированное свойство универсального
<T> сущность, с которой мы имеем дело; как ясно сказано в комментарии к методу, на самом деле это мера безопасности против попыток внедрения SQL. Это очень важный вопрос безопасности, о котором мы поговорим.
примерно через некоторое время.

Если мы попытаемся собрать наш проект сразу после этих изменений, нас, скорее всего, встретит какой-нибудь компилятор.
ошибки, например следующие:

```
Error CS0246: The type or namespace name System.Linq.Dynamic could not be found
(are you missing a using directive or an assembly reference?).
```
Не волнуйтесь, это совершенно нормально: нам просто нужно добавить в наш проект новый пакет NuGet.

# Установка System.Linq.Dynamic.Core
Метод расширения IQueryable<T>.OrderBy(), который мы использовали в улучшенном исходном коде ApiResult.
для программного применения сортировки столбцов является частью пространства имен System.Linq.Dynamic.Core.
Благодаря этой библиотеке можно писать запросы Dynamic LINQ (на основе строк) в IQueryable.
это похоже на то, что мы сделали в предыдущем коде.
К сожалению, System.Linq.Dynamic.Core не является частью стандартных двоичных файлов ASP.NET; следовательно, в
чтобы использовать эти функции, нам нужно добавить их через NuGet.
Самый быстрый способ сделать это — открыть консоль диспетчера пакетов Visual Studio и выполнить следующую команду:
команда:

``` Install-Package System.Linq.Dynamic.Core```

ВАЖНО. Обязательно установите System.Linq.Dynamic.Core, а не System.Linq.Dynamic, который
его аналог .NET Framework 4.0; последний не будет работать с нашим проектом веб-приложения ASP.NET.
На момент написания последней версии пакета System.Linq.Dynamic.Core — 1.2.14.
который отлично работает для наших целей.
Для тех, кто хочет получить дополнительную информацию об этом замечательном пакете, мы предлагаем вам
обратите внимание на следующие ресурсы:
Веб-сайт NuGet: https://www.nuget.org/packages/System.Linq.Dynamic.Core/
Проект GitHub: https://github.com/StefH/System.Linq.Dynamic.Core

# Что такое ЛИНК?
Прежде чем двигаться дальше, давайте потратим пару минут на разговор о LINQ на тот маловероятный случай, когда вы
никогда ничего об этом не слышал.
LINQ, также известный как языково-интегрированный запрос, — это кодовое имя набора Microsoft .NET Framework.
технологий, которые добавляют возможности запроса данных в языки .NET, такие как C# и VB.NET. LINQ был
впервые выпущенный в 2007 году, он стал одной из основных новых функций .NET Framework 3.5.
Основная цель LINQ — дать разработчику возможность выражать структурированные запросы к данным.
использование первоклассной языковой конструкции без необходимости изучать разные языки запросов для каждого типа
источника данных (типы коллекций, SQL, XML, CSV и т. д.). Для каждого из этих основных типов источников данных
существует реализация LINQ, которая обеспечивает одинаковую обработку запросов к объектам (LINQ to Objects),
Сущности Entity Framework (LINQ to Entities), реляционные базы данных (LINQ to SQL), XML (LINQ to XML),
и так далее.

Структурированные запросы LINQ могут быть выражены с использованием двух альтернативных, но в то же время взаимодополняющих подходов:

- Lambda expressions, such as the following:

```Csharp
var city = _context.Cities.Where(c => c.Name == "New York").First();
```

- Query expressions, such as the following:
```Csharp
var city = (from c in _context.Cities where c.Name == "New York" select c).First();
```
Оба дают один и тот же результат с одинаковой производительностью, поскольку выражения запроса переводятся в
их эквиваленты лямбда-выражений перед компиляцией.











































































