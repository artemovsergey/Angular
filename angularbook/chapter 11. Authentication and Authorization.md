# Authentication and Authorization

Вообще говоря, термин аутентификация относится к любому процессу проверки, который определяет
является ли кто-то, будь то человек или автоматизированная система, тем, кем (или чем) он себя называет. Этот
это также верно в контексте Всемирной паутины (WWW), где чаще всего используется то же самое слово.
для обозначения любого метода, используемого веб-сайтом или службой для сбора набора данных для входа в систему от пользователя.
агент, обычно веб-браузер, и аутентифицировать их с помощью службы членства и/или идентификации.
Аутентификацию никогда не следует путать с авторизацией, поскольку это другой процесс, и он отвечает за него.
совсем другой задачи. Чтобы дать краткое определение, мы можем сказать, что цель авторизации состоит в том, чтобы
подтвердите, что запрашивающему пользователю разрешен доступ к действию, которое он хочет выполнить. В других
Другими словами, в то время как аутентификация касается того, кем они являются, авторизация — это то, что им разрешено делать.
Чтобы лучше понять разницу между этими двумя, казалось бы, схожими понятиями, можно подумать
двух реальных сценариев:
1. Бесплатная, но зарегистрированная учетная запись, пытающаяся получить доступ к платной или платной услуге или функции. Это распространенный пример аутентифицированного, но не авторизованного доступа; мы знаем кто
они есть, но им не разрешают туда ходить.
2. Анонимный пользователь пытается получить доступ к общедоступной странице или файлу; это пример
неаутентифицированного, но авторизованного доступа; мы не знаем, кто они, но они могут получить доступ
государственные ресурсы, как и все остальные.
Аутентификация и авторизация станут основными темами этой главы, которые мы постараемся рассмотреть.
как с теоретической, так и с практической точек зрения, а также демонстрирует некоторые возможные реализации.
подходы только для демонстрационных целей.
Точнее, мы поговорим о следующих темах:
- Авторизовать или не авторизовать? Здесь мы обсудим некоторые типичные сценарии, в которых аутентификация и
авторизация может либо потребоваться, либо нет, гарантируя, что мы правильно понимаем значение
таких терминов и того, как их можно реализовать в типичном контексте веб-приложения.
Собственная аутентификация с помощью .NET Core. Представляет ASP.NET Core Identity, современную систему членства, которая позволяет разработчикам добавлять в свои приложения функции входа в систему, а также
JwtBearerMiddleware — промежуточное программное обеспечение, предназначенное для добавления поддержки аутентификации JWT в любой ASP.
NET Core-приложение; кроме того, мы реализуем ASP.NET Core Identity и JwtBearerMiddleware, чтобы добавить функции входа в существующее приложение WorldCities.
- Обновление базы данных. Основное внимание уделяется обновлению нашей существующей базы данных WorldCities для создания
таблицы, связанные с аутентификацией, и добавьте пару тестовых пользователей для проверки входа в систему.
- Реализация аутентификации в Angular. Здесь мы проведем рефакторинг нашего приложения Angular, чтобы
сделать его способным взаимодействовать с системой идентификации ASP.NET Core, представив некоторые новые возможности Angular.
такие функции, как HTTP-перехватчики и Route Guards, которые будут выполнять всю аутентификацию.
и поток авторизации.
Давайте делать все возможное!

# Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, с
следующие дополнительные пакеты:
- Microsoft.AspNetCore.Identity.EntityFrameworkCore
- Microsoft.AspNetCore.Authentication.JwtBearer
Как всегда, желательно не устанавливать их сразу; мы собираемся привезти их во время
главу, чтобы лучше контекстуализировать их цели в рамках нашего проекта.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/master/Chapter_11/.

# Авторизовать или не авторизовать
На самом деле реализация логики аутентификации и/или авторизации не является обязательной для большинства
веб-приложения или услуги; существует ряд веб-сайтов, которые до сих пор этого не делают, главным образом потому, что они предоставляют контент, доступный любому в любое время. Раньше это было довольно распространено
среди большинства корпоративных, маркетинговых и информационных веб-сайтов еще несколько лет назад; это было раньше
их владельцы узнали, насколько важно построить сеть зарегистрированных пользователей и насколько важны эти
«Лояльные» контакты в наше время имеют ценность.
Нам не нужно быть опытными разработчиками, чтобы осознать, насколько сильно изменилась WWW.
Последние несколько лет; каждый веб-сайт, независимо от его цели, имеет все большее и более или менее
законный интерес в отслеживании своих пользователей в настоящее время, предоставляя им возможность настраивать свою навигацию, взаимодействовать со своими социальными сетями, собирать адреса электронной почты и так далее. Ни один из
предыдущее может быть выполнено без какого-либо механизма аутентификации.
Существуют миллиарды веб-сайтов и сервисов, для правильной работы которых требуется аутентификация, поскольку большинство из них
их содержание и/или намерения зависят от действий зарегистрированных пользователей: форумы, блоги, покупки
корзины, сервисы на основе подписки и даже инструменты для совместной работы, такие как вики.

Короче говоря, ответ — да; до тех пор, пока мы хотим, чтобы пользователи выполняли создание, чтение, обновление,
и удаления (CRUD) в нашем клиентском приложении, нет сомнений, что нам следует реализовать
какая-то процедура аутентификации и авторизации. Если мы стремимся к готовому к производству
Одностраничное приложение (SPA), предусматривающее любое взаимодействие с пользователем, мы определенно хотим
знать, кто наши пользователи по именам и адресам электронной почты. Это единственный способ определить, кто
сможет просматривать, добавлять, обновлять или удалять наши записи, не говоря уже о выполнении действий на административном уровне.
задачи, отслеживать наших пользователей и так далее.

# Аутентификация
С момента появления WWW подавляющее большинство методов аутентификации основано на HTTP/HTTPS.
стандарты реализации, и все они работают более или менее следующим образом:
1. Неаутентифицированный пользовательский агент запрашивает контент, доступ к которому невозможен без какого-либо
разрешения.
2. Веб-приложение возвращает запрос аутентификации, обычно в виде HTML-страницы.
содержащий пустую веб-форму для заполнения.
3. Пользовательский агент заполняет веб-форму своими учетными данными, обычно именем пользователя и паролем, а затем отправляет ее обратно с помощью команды POST, которая, скорее всего, выдается при нажатии
кнопка «Отправить».
4. Веб-приложение получает данные POST и вызывает вышеупомянутую реализацию на стороне сервера, которая пытается аутентифицировать пользователя с помощью заданных входных данных и возвращает соответствующий результат.
5. Если результат успешен, веб-приложение аутентифицирует пользователя и сохранит соответствующие данные.
данные где-то, в зависимости от выбранного метода аутентификации; это может включать сеансы/
файлы cookie, токены, подписи и т. д. (об этом мы поговорим позже). И наоборот, результат
будет представлен пользователю как читаемый результат на странице ошибок, возможно, спрашивая его
чтобы попробовать еще раз, обратитесь к администратору или еще что-нибудь.
В настоящее время это по-прежнему наиболее распространенный подход. Почти все веб-сайты, о которых мы только можем подумать, используют его,
хотя и с рядом больших или маленьких различий, касающихся уровней безопасности, управления состоянием, JSON
Веб-токены (JWT) или другие токены RESTful, базовый или дайджест-доступ, свойства единого входа и
более. Прежде чем двигаться дальше, давайте потратим немного времени на объяснение наиболее важных из них.

# Методы аутентификации
Как мы наверняка знаем, протокол HTTP не имеет состояния, а это означает, что все, что мы делаем во время цикла запрос/ответ, будет потеряно до следующего запроса, включая результат аутентификации.
Единственный способ преодолеть это — сохранить где-нибудь этот результат вместе со всеми его соответствующими значениями.
данные, такие как идентификатор пользователя, дата/время входа в систему и время последнего запроса. В следующих разделах мы кратко опишем
обсудить некоторые методы хранения этих данных.

# Сеансы/куки
Еще несколько лет назад наиболее распространенным и традиционным способом сделать это было хранение данных на
сервер с помощью диспетчера сеансов на основе памяти, диска или внешнего менеджера сеансов.

Каждый сеанс можно было получить с использованием уникального идентификатора, который клиент получил в ответе на аутентификацию, обычно внутри файла cookie сеанса, который передавался на сервер при каждом последующем запросе.
Вот краткая диаграмма, описывающая поток аутентификации на основе сеанса:

![image](https://github.com/artemovsergey/Angular/assets/26972859/aaca3535-4c79-4b09-bfbe-cb64d324ea6e)

Это по-прежнему очень распространенный метод, используемый большинством веб-приложений. Нет ничего плохого в
принять этот подход, если мы согласны с его широко признанными недостатками, такими как
следующий:
- Проблемы с памятью. Если имеется много аутентифицированных пользователей, веб-сервер будет потреблять
все больше и больше памяти. Даже если мы используем файловый или внешний поставщик сеансов,
тем не менее, это будет интенсивный ввод-вывод, TCP или сокеты.
- Проблемы масштабируемости: репликация поставщика сеансов в масштабируемой архитектуре (веб-ферма IIS,
кластер с балансировкой нагрузки и т.п.) может быть непростой задачей и часто приводит к узким местам.
или потраченные впустую ресурсы.
- Междоменные проблемы. Сеансовые файлы cookie ведут себя так же, как стандартные файлы cookie, поэтому их нельзя
легко распределяется между разными источниками/доменами. Подобные проблемы часто можно решить
с некоторыми обходными путями, но они часто приводят к небезопасным сценариям, позволяющим заставить все работать.
- Вопросы безопасности. Существует широкий спектр подробной литературы по вопросам безопасности, включающим
сеансы и сеансовые файлы cookie: например, атаки межсайтовой подделки запросов (CSRF) и
ряд других угроз, которые не будут здесь рассматриваться для простоты. Большинство из них
могут быть смягчены некоторыми контрмерами, однако с ними может быть трудно справиться юниорам или
начинающие разработчики.
Поскольку эти проблемы возникали на протяжении многих лет, нет сомнений в том, что большинство аналитиков и разработчиков сталкивались с ними.
приложить много усилий для выявления различных подходов, а также для их смягчения.
Ключевое улучшение в плане смягчения последствий было достигнуто в 2016 году с помощью проекта файлов cookie SameSite, который
предложил политику безопасности HTTP, которая затем была улучшена с помощью Cookies HTTP State Management.
«Механизм» (апрель 2019 г.) и проекты «Постепенно улучшенные файлы cookie» (май 2019 г.).

Теперь, когда большинство браузеров приняли спецификацию файлов cookie SameSite, аутентификация на основе файлов cookie
намного безопаснее, чем раньше.

# Токены
Аутентификация на основе токенов все чаще применяется в одностраничных приложениях (SPA) и
мобильных приложений в последние несколько лет по ряду, несомненно, веских причин, которые мы попытаемся кратко
подведем итоги здесь.
Наиболее важное различие между аутентификацией на основе сеанса и аутентификацией на основе токенов
заключается в том, что последний не имеет состояния, а это означает, что мы не будем хранить какую-либо пользовательскую информацию на
память сервера, база данных, поставщик сеансов или другие контейнеры данных любого типа.
Этот единственный аспект решает большинство недостатков, которые мы указывали ранее для аутентификации на основе сеанса. У нас не будет сеансов, поэтому не будет увеличения накладных расходов; нам не понадобится сеанс
провайдера, поэтому масштабирование будет намного проще. Кроме того, для браузеров, поддерживающих LocalStorage, мы даже не будем
использовать файлы cookie, чтобы нас не заблокировали политики ограничения перекрестного происхождения, и, будем надеяться, мы получим
вокруг большинства вопросов безопасности.

Вот типичный процесс аутентификации на основе токенов:

![image](https://github.com/artemovsergey/Angular/assets/26972859/30ebc1bd-fe76-42d8-b803-f6545a4f4950)

С точки зрения взаимодействия клиент-сервер эти шаги не сильно отличаются от диаграммы потока аутентификации на основе сеанса; видимо, с той лишь разницей, что мы будем выпускать и проверять токены
вместо создания и получения сеансов. Однако реальная ситуация происходит (или не происходит)
на стороне сервера. Мы сразу видим, что поток аутентификации на основе токенов не зависит от состояния.
сервер, служба или менеджер состояния сеанса. Это легко приведет к значительному увеличению с точки зрения
производительности и масштабируемости.

# Подписи
Этот метод используется большинством современных служб облачных вычислений и хранения данных на основе API, в том числе
Microsoft Azure и веб-службы Amazon (AWS).

В отличие от подходов на основе сеансов и токенов, которые полагаются на транспортный уровень, который может
теоретически может быть доступен или открыт для стороннего злоумышленника, аутентификация на основе подписи выполняет хеширование всего запроса с использованием ранее общего закрытого ключа. Это гарантирует, что ни один злоумышленник
или «человек посередине» может выступать в роли запрашивающего пользователя, поскольку он не сможет подписать запрос.

# Двухфакторный
Это стандартный метод аутентификации, используемый большинством банковских и финансовых счетов.
пожалуй, самый безопасный.
Реализация может отличаться, но она всегда опирается на следующий базовый рабочий процесс:
- Пользователь выполняет стандартный вход в систему с использованием имени пользователя и пароля.
- Сервер идентифицирует пользователя и отправляет ему дополнительный запрос, специфичный для пользователя, который
может быть удовлетворено только чем-то, полученным или достижимым через другой канал; например, OTP-пароль, отправленный по SMS, уникальная карта аутентификации с номером ответа
коды или динамический PIN-код, сгенерированный фирменным устройством или мобильным приложением.
- Если пользователь дает правильный ответ, он аутентифицируется с использованием стандартного сеансового или
метод на основе токенов
Двухфакторная аутентификация (2FA) поддерживается ASP.NET Core с момента ее выпуска 1.0.
реализовал его с помощью SMS-верификации (SMS 2FA). Однако, начиная с ASP.NET Core 2, SMS
Подход 2FA устарел в пользу алгоритма одноразового пароля на основе времени (TOTP), который
стал рекомендованным в отрасли подходом к реализации 2FA в веб-приложениях.

Рассмотрев все эти методы аутентификации, мы можем с уверенностью сказать, что подход аутентификации на основе токенов кажется жизнеспособным выбором для нашего конкретного сценария: именно по этой причине в
В следующих разделах мы собираемся пойти по этому пути.

# Сторонняя аутентификация
Независимо от метода аутентификации, который выбирает веб-приложение, ему приходится иметь
потенциально разные имя пользователя и пароль для каждого посещения веб-сайта могут расстраивать, а также могут
требовать от пользователей разработки собственных методов хранения паролей, которые могут привести к угрозам безопасности. Чтобы
Чтобы решить эту проблему, большое количество ИТ-разработчиков начали искать альтернативный способ.
для аутентификации пользователей, которая могла бы заменить стандартную технику аутентификации на основе имен пользователей
и пароли с протоколом аутентификации, основанным на доверенных сторонних поставщиках.

# Взлет и падение OpenID
Среди первых успешных попыток реализовать сторонний механизм аутентификации была
первый выпуск OpenID, открытого и децентрализованного протокола аутентификации, продвигаемого некоммерческой организацией
Фонд OpenID. Доступный с 2005 года, он был быстро и с энтузиазмом принят некоторыми крупными компаниями.
такие игроки, как Google и Stack Overflow, которые изначально основывали на нем своих поставщиков аутентификации.
Вот как это работает в нескольких словах:
- Всякий раз, когда наше приложение получает запрос на аутентификацию OpenID, оно открывает прозрачный интерфейс соединения через запрашивающего пользователя и доверенного стороннего поставщика аутентификации (например, поставщика удостоверений Google); интерфейс может быть всплывающим,
Модальное окно, заполненное AJAX, заполненные модальные окна или вызов API, в зависимости от
выполнение
- Пользователь отправляет свое имя пользователя и пароль вышеупомянутому стороннему поставщику, который
соответствующим образом выполняет аутентификацию и передает результат нашему приложению с помощью
перенаправление пользователя туда, откуда он пришел, вместе с токеном безопасности, который можно использовать для
получить результат аутентификации
- Наше приложение использует токен для проверки результата аутентификации, аутентифицируя пользователя.
в случае успеха или отправка ответа об ошибке в случае неудачи
Несмотря на большой энтузиазм по поводу OpenID в период с 2005 по 2009 год, при наличии большого количества соответствующих
компании, публично заявляющие о своей поддержке OpenID и даже присоединяющиеся к фонду, в том числе
PayPal и Facebook, первоначальный протокол не оправдал больших ожиданий. Юридические споры,
вопросы безопасности, а главное, массовый всплеск популярности социальных сетей с их
неправильные, но работающие, входы в социальные сети на основе OAuth в период 2009–2012 годов практически убили его.

# OpenID Connect
В отчаянной попытке сохранить свой флаг после захвата социальных сетей OAuth/OAuth 2,
Фонд OpenID Foundation выпустил третье поколение технологии OpenID в феврале 2014 года;
это называлось OpenID Connect (OIDC).
Несмотря на название, новая версия OIDC практически не имеет ничего общего со своим предшественником; это просто
уровень аутентификации, построенный на протоколе авторизации OAuth 2. Другими словами, это немного больше
чем стандартизированный интерфейс, помогающий разработчикам использовать OAuth 2 в качестве платформы аутентификации в
менее неправильный способ, что довольно забавно, учитывая, что OAuth 2 сыграл важную роль в удалении
OpenID 2.0 на первом месте.
Решение отказаться от OpenID в пользу OIDC подверглось резкой критике в 2014 году; однако, ведь
В эти годы мы можем с уверенностью сказать, что OIDC по-прежнему может предоставить полезный стандартизированный способ получения
идентификаторы пользователей.

Это позволяет разработчикам запрашивать и получать информацию об аутентифицированных пользователях и сеансах, используя
удобный интерфейс JSON на основе RESTful; он имеет расширяемую спецификацию, которая также поддерживает
некоторые многообещающие дополнительные функции, такие как шифрование идентификационных данных, автоматическое обнаружение провайдеров OpenID и даже управление сеансами. Короче говоря, он все еще достаточно полезен, чтобы его можно было использовать вместо того, чтобы полагаться на
на чистом OAuth 2.

# Авторизация
В большинстве стандартных реализаций, в том числе в ASP.NET, фаза авторизации
запускается сразу после аутентификации и в основном основан на разрешениях или ролях; любой аутентифицированный
пользователь может иметь собственный набор разрешений и/или принадлежать к одной или нескольким ролям и, таким образом, иметь доступ к определенному набору ресурсов. Эти ролевые проверки обычно устанавливаются разработчиком в
декларативный способ в исходном коде приложения и/или файлах конфигурации.
Авторизацию, как мы уже говорили, не следует путать с аутентификацией, несмотря на то, что ее можно
легко использовать для выполнения неявной аутентификации, особенно когда она делегируется
сторонний актер.

# Собственное разрешение
Большинство платформ разработки предоставляют встроенную модель авторизации, которую можно использовать для реализации политик на основе разрешений, ролей и/или утверждений. ASP.NET Core не является исключением.
поскольку он поставляется с простым декларативным API: в двух словах, авторизация выражается в требованиях,
предназначены в качестве требуемых требований для доступа к данному ресурсу или выполнения определенной задачи; эти требования
проверяются обработчиками, которые оценивают претензии пользователя к ним.
Использование собственной модели авторизации часто является хорошим выбором, при условии, что у разработчиков есть
необходимые навыки и ноу-хау для его правильной реализации и неизбежного преодоления уровня сложности.
склонен к такому подходу.

# Сторонняя авторизация
В настоящее время самым известным сторонним протоколом авторизации является версия OAuth 2.0, также известная как
как OAuth 2, который заменяет предыдущую версию (OAuth 1 или просто OAuth), первоначально разработанную
Блейн Кук и Крис Мессина в 2006 году.
Мы уже много об этом говорили и не зря: OAuth 2 быстро стал отраслевым стандартом.
протокол авторизации и в настоящее время используется огромным количеством веб-сайтов сообществ.
и социальные сети, включая Google, Facebook и Twitter.

В основном это работает следующим образом:
- Всякий раз, когда существующий пользователь запрашивает набор разрешений для нашего приложения через OAuth, мы открываем
прозрачный интерфейс соединения между ними и сторонним поставщиком авторизации
которому доверяет наше приложение (например, Facebook)
- Провайдер подтверждает пользователя и, если у него есть соответствующие права, отвечает, доверяя
им временный, конкретный ключ доступа
- Пользователь предоставляет ключ доступа к нашему приложению и получает доступ.
Мы можем ясно видеть, насколько легко использовать эту логику авторизации для целей аутентификации, поскольку
хорошо; в конце концов, если Facebook говорит, что я могу что-то сделать, разве это не должно подразумевать, что я тот, кем заявляю
быть? Разве этого недостаточно?
Короткий ответ - нет. Это может быть справедливо для Facebook, поскольку их реализация OAuth 2 подразумевает, что подписчики, получающие авторизацию, должны пройти аутентификацию в Facebook.
первый; однако об этом заверении нигде не написано. Учитывая, сколько веб-сайтов его используют
в целях аутентификации мы можем предположить, что Facebook вряд ли изменит свое фактическое поведение,
но у нас нет никаких гарантий этого.
Теоретически эти сайты могут отделить свою систему авторизации от аутентификации.
протоколе в любое время, что приводит логику аутентификации нашего приложения в невосстановимое состояние.
непоследовательность. В более общем плане мы можем сказать, что предполагать что-то из чего-то другого почти невозможно.
всегда плохая практика, если только это предположение не основано на очень прочных, хорошо документированных и (что наиболее важно) высокогарантированных основаниях.

# Собственный и сторонний
Теоретически можно полностью делегировать задачи аутентификации и/или авторизации.
существующим внешним сторонним поставщикам, таким как те, о которых мы упоминали ранее; есть много сети
и мобильные приложения, которые сегодня с гордостью следуют по этому пути. Существует ряд неоспоримых
Преимущества использования такого подхода, в том числе следующие:
- Никаких пользовательских таблиц/моделей данных базы данных, только некоторые идентификаторы на основе поставщика, которые можно использовать здесь.
и там как справочные ключи
- Немедленная регистрация, поскольку нет необходимости заполнять регистрационную форму и ждать письма с подтверждением — ни имени пользователя, ни пароля. Это оценят большинство пользователей и
возможно, это также увеличит наши коэффициенты конверсии
- Проблемы с конфиденциальностью незначительные или отсутствуют, поскольку на сервере приложений нет личных или конфиденциальных данных.
- Нет необходимости обрабатывать имена пользователей и пароли и внедрять процессы автоматического восстановления.
- Меньше проблем с безопасностью, таких как попытки взлома с использованием форм или попытки грубого входа в систему.
Конечно, есть и минусы:
- Реальной базы пользователей не будет, поэтому будет сложно получить обзор активных пользователей, получить
свои адреса электронной почты, анализировать статистику и т. д.

Фаза входа в систему может быть ресурсоемкой, поскольку для нее всегда потребуется внешнее двустороннее безопасное соединение со сторонним сервером.
- Всем пользователям необходимо будет иметь (или открыть) учетную запись у выбранного стороннего поставщика(ов) в
чтобы войти в систему
- Все пользователи должны будут доверять нашему приложению, поскольку сторонний поставщик попросит их сделать это.
разрешить ему доступ к своим данным
- Нам придется зарегистрировать наше приложение у провайдера, чтобы иметь возможность выполнить
количество обязательных или дополнительных задач, таких как получение наших открытых и секретных ключей, авторизация
один или несколько инициаторов URI и выбор информации, которую мы хотим собрать.
Принимая во внимание все эти плюсы и минусы, мы можем сказать, что полагаться на сторонних поставщиков может быть разумным.
отличный выбор для экономии времени для небольших приложений, включая наше; однако создаем собственный аккаунт
система управления, по-видимому, является единственным способом преодолеть вышеупомянутое управление и
недостатки, основанные на контроле, несомненно, вызваны этим подходом.
Поэтому в этой главе мы рассмотрим проприетарный вариант: точнее, создадим внутренний
поставщик членства, который будет обрабатывать аутентификацию и предоставлять свой собственный набор авторизации.
правила.

# Собственная аутентификация с помощью .NET Core
Шаблоны аутентификации, доступные в ASP.NET Core, в основном такие же, как и поддерживаемые.
предыдущими версиями ASP.NET:
- Никакой аутентификации, если нам не хочется что-либо реализовывать или если мы хотим использовать (или разрабатывать)
самодельный интерфейс аутентификации, не полагающийся на систему ASP.NET Core Identity
- Индивидуальные учетные записи пользователей, когда мы настраиваем внутреннюю базу данных для хранения пользовательских данных с помощью
стандартный интерфейс ASP.NET Core Identity
- Azure Active Directory (AD), что подразумевает использование набора вызовов API на основе токенов, обрабатываемых
Библиотека аутентификации Azure AD (ADAL)
- Аутентификация Windows, которая возможна только для локальных приложений в Windows.
домены или деревья AD
Однако шаблоны реализации, представленные командой ASP.NET Core за последние несколько лет,
постоянно развиваются, чтобы соответствовать новейшим доступным практикам безопасности.
Все вышеупомянутые подходы, за исключением первого, обрабатываются ASP.NET Core Identity.
система, система членства, которая позволяет нам добавлять функции аутентификации и авторизации.
в наше приложение.

Начиная с .NET Core 3.0, ASP.NET Core Identity интегрирован со сторонней авторизацией.
механизм аутентификации в SPA; эта новая функция основана на IdentityServer, части открытой
исходное промежуточное программное обеспечение OIDC и OAuth 2.0, которое было частью .NET Foundation начиная с .NET Core 3.0.

Однако 1 октября 2020 года команда IdentityServer сделала заявление о том, что лицензия
модель будет заменена взаимной публичной лицензией: в двух словах, это означает, что продукт
по-прежнему будет открытым исходным кодом для тестирования, обучения и некоммерческого использования, но если он будет использоваться в коммерческих целях
целях и организация зарабатывает более 1 млн долларов США в год, то необходимо приобрести платную лицензию.

После этого изменения в модели лицензирования IdentityServer команда разработчиков ASP.NET внесла
собственное объявление от 7 мая 2021 г., в котором говорится, что они продолжат поставлять IdentityServer в .NET 6.
шаблоны, но они будут искать альтернативу для .NET 7 и более поздних версий, поскольку хотят предоставить
встроенная система идентификации для любых целей.

Поэтому для целей этой книги мы не будем использовать IdentityServer: мы реализуем вход в систему
механизм, который позволит нашим пользователям создать учетную запись и войти в систему с именем пользователя и паролем
использование служб и промежуточного программного обеспечения, изначально предоставляемых ASP.NET Core.
Более конкретно, мы реализуем механизм аутентификации на основе веб-токенов JSON (JWT).
открытый стандарт на основе JSON, специально разработанный для собственных веб-приложений, доступный на нескольких языках, таких как .NET, Python, Java, PHP, Ruby, JavaScript/Node.js и Perl. Мы выбрали его, потому что это
становится фактическим стандартом аутентификации по токену, поскольку он изначально поддерживается большинством технологий.

В этом разделе мы собираемся сделать следующее:
- Представление модели ASP.NET Core Identity — платформы, предоставляемой ASP.NET Core для
управлять и хранить учетные записи пользователей
- Настройте реализацию ASP.NET Core Identity, установив необходимые пакеты NuGet.
в нашем существующем приложении WorldCities
Для настройки ASP.NET Core Identity потребуется выполнить следующие шаги:
- Добавьте необходимые пакеты NuGet для сервисов и промежуточного программного обеспечения, которые мы собираемся использовать.
- Создайте объект ApplicationUser для обработки зарегистрированных пользователей.
- Расширьте ApplicationDbContext, используя тип аутентификации индивидуальных учетных записей пользователей.
- Настройте службу идентификации ASP.NET Core в классе программы нашего приложения на основе
классы ApplicationUser и ApplicationDbContext.
- Внедрите новый AccountController с методом действия входа в систему для проверки попыток входа в систему.
от клиента Angular и в случае успеха вернуть действительный токен JWT.
- Настройте JwtBearerMiddleware в классе Program нашего приложения для проверки JWT.
токены, которые будут отправляться клиентом Angular в HTTP-запросах (когда мы реализуем
эта особенность)
- Обновите существующий SeedController, добавив метод для создания пользователей по умолчанию с помощью
Поставщики API идентификации .NET
- Защитите методы действий атрибутом [Authorize] всякий раз, когда мы хотим ограничить их
использование только авторизованным пользователям
Сразу после этого мы воспользуемся возможностью и скажем пару слов о модели ASP.NET Core Task Asynchronous Programming (TAP), а затем переключимся на Angular для реализации клиентской части.
часть работы.

# Модель ASP.NET Core Identity
ASP.NET Core предоставляет унифицированную платформу для управления и хранения учетных записей пользователей, которую можно легко
используется в любом .NET-приложении (даже не веб-приложении); эта платформа называется ASP.NET Core Identity.
и предоставляет набор API, которые позволяют разработчикам решать следующие задачи:
- Проектирование, настройка и реализация функций регистрации пользователей и входа в систему.
- Управляйте пользователями, паролями, данными профиля, ролями, заявками, токенами, подтверждениями по электронной почте и т. д.
- Поддержка внешних (сторонних) поставщиков услуг входа, таких как Facebook, Google, учетная запись Microsoft,
Твиттер и многое другое
Исходный код ASP.NET Core Identity имеет открытый исходный код и доступен на GitHub по адресу https://github.
com/aspnet/AspNetCore/tree/master/src/Identity.
Само собой разумеется, что ASP.NET Core Identity требует постоянного источника данных для хранения (и извлечения) идентификационных данных (имен пользователей, паролей и данных профиля), например базы данных SQL Server; для
именно по этой причине он имеет встроенные механизмы интеграции с Entity Framework Core.

Это означает, что для реализации нашей собственной системы идентификации мы, по сути, расширим то, что мы
сделал это в главе 5 «Модель данных с Entity Framework Core»; точнее, мы обновим существующие
ApplicationDbContext для поддержки дополнительных классов сущностей, необходимых для обработки пользователей, ролей и
скоро.

# Типы сущностей
Платформа ASP.NET Core Identity в значительной степени опирается на следующие типы сущностей, каждый из которых
представляющий определенный набор записей:
- Пользователь: пользователи нашего приложения.
- Роль: роли, которые мы можем назначить каждому пользователю.
- UserClaim: утверждения, которыми обладает пользователь.
- UserToken: токен аутентификации, который пользователь может использовать для выполнения задач, основанных на аутентификации (например,
как войти)
- UserLogin: учетная запись для входа, связанная с каждым пользователем.
- RoleClaim: утверждения, которые предоставляются всем пользователям в рамках данной роли.
- UserRole: таблица поиска для хранения связей между пользователями и назначенными им ролями.
Эти типы сущностей связаны друг с другом следующим образом:
- Каждый пользователь может иметь множество объектов UserClaim, UserLogin и UserToken (один ко многим).
- Каждая роль может иметь множество связанных объектов RoleClaim (один ко многим).
- Каждый Пользователь может иметь множество связанных объектов Роли, и каждая Роль может быть связана со многими
Пользовательские сущности (многие ко многим)
Отношения «многие-ко-многим» требуют наличия в базе данных таблицы соединения, которая представлена
Сущность UserRole.
К счастью, нам не придется вручную реализовывать все эти сущности с нуля, поскольку ASP.NET
Core Identity предоставляет некоторые типы Common Language Runtime (CLR) по умолчанию для каждого из них:
- IdentityUser
- IdentityRole
- IdentityUserClaim
- IdentityUserToken
- IdentityUserLogin
- IdentityRoleClaim
- IdentityUserRole
Эти типы можно использовать в качестве базовых классов для нашей собственной реализации всякий раз, когда нам нужно явно указать
определить модель сущности, связанную с идентификацией. Более того, большинство из них не обязательно должны быть реализованы в
наиболее распространенные сценарии аутентификации, поскольку их функциональные возможности могут обрабатываться на более высоком уровне
благодаря наборам API ASP.NET Core Identity, доступ к которым можно получить из следующих классов:
- RoleManager<TRole>: предоставляет API для управления ролями.
- SignInManager<TUser>: предоставляет API для входа и выхода пользователей (вход и выход).
- UserManager<TUser>: предоставляет API для управления пользователями.
После того как служба идентификации ASP.NET Core будет правильно настроена и настроена, эти поставщики смогут
быть внедрены в наши контроллеры ASP.NET Core с помощью внедрения зависимостей (DI), как мы это делали с
ПриложениеДбКонтекст; в следующем разделе мы увидим, как это можно сделать.
Настройка удостоверения ядра ASP.NET
В главе 2 «Подготовка» и главе 5 «Модель данных с Entity Framework Core», когда мы создали
наших проектах HealthCheckAPI и WorldCitiesAPI .NET Core мы всегда предпочитали использовать пустое
проект без аутентификации. Это произошло потому, что мы не хотели, чтобы Visual Studio устанавливала ASP.NET.
Основная идентичность в стартовых файлах нашего приложения с самого начала. Однако теперь, когда мы используем
это, нам нужно вручную выполнить необходимые шаги настройки.

# Добавление пакетов NuGet
Хватит теории, давайте воплотим план в жизнь.
В обозревателе решений щелкните правой кнопкой мыши узел дерева WorldCitiesAPI и выберите «Управление пакетами NuGet». Найдите следующие два пакета и установите их:
- Microsoft.AspNetCore.Identity.EntityFrameworkCore
- Microsoft.AspNetCore.Authentication.JwtBearer
Альтернативно откройте консоль диспетчера пакетов и установите их с помощью следующих команд:

```
> Install-Package Microsoft.AspNetCore.Identity.EntityFrameworkCore
> Install-Package Microsoft.AspNetCore.Authentication.JwtBearer
```
На момент написания последняя версия для них обоих — 6.0.1; как всегда, мы можем установить более новую версию
версию, если мы знаем, как соответствующим образом адаптировать наш код для устранения потенциальных проблем совместимости.

# Создание пользователя приложения
Теперь, когда мы установили необходимые библиотеки удостоверений, нам нужно создать нового пользователя ApplicationUser.
класс сущности со всеми функциями, необходимыми службе идентификации ASP.NET Core для его использования в целях аутентификации. К счастью, пакет поставляется со встроенным базовым классом IdentityUser, который можно использовать.
расширить нашу собственную реализацию, предоставив ей все, что нам нужно.
В обозревателе решений перейдите в папку /Data/Models/ и создайте нового пользователя ApplicationUser.
cs и заполните его содержимое следующим кодом:

















































































































