# Real-Time Updates with SignalR

В этой главе мы расскажем об ASP.NET Core SignalR, библиотеке с открытым исходным кодом, которая позволяет нам добавить
функциональность в реальном времени в веб-приложения, позволяя коду на стороне сервера мгновенно отправлять содержимое клиентам
мгновенно.
Подобные требования могут быть малопригодны или вообще не нужны в большинстве приложений общего назначения, включая приложение WorldCities
над которым мы работаем с главы 5, "Модель данных с Entity Framework Core"; однако оно может быть
очень полезной для некоторых специфических сценариев, таких как:
- онлайновые игры, особенно если они должны поддерживать несколько игроков, действующих одновременно в
общей или разделяемой среде
- Социальные сети, если они нуждаются в какой-либо системе уведомлений
- приложения для совместной работы, такие как блоги, CMS, доски, командные совещания, сервисы обмена файлами,
и т. п.
- Приложения для мониторинга и приборной панели, включая наше приложение HealthCheck.
Как нетрудно догадаться, приложение HealthCheck станет идеальным кандидатом для изучения этой темы. Учитывая
В связи с этим в следующих разделах мы расскажем о том, что нам предстоит сделать:
- Рассмотрим различные техники и обходные пути для реализации возможностей реального времени в веб-приложениях, использующих технологии серверного push
приложениях с помощью технологий server push с момента появления HTTP/1.0.
- Представим SignalR, библиотеку с открытым исходным кодом, которая позволяет добавлять веб-функции реального времени
в приложения, использующие вышеупомянутые техники
- Реализуем SignalR на уровне сервера в нашем приложении HealthCheckAPI ASP.NET Core
- Добавьте возможности SignalR на уровне клиента в наше приложение Angular.
Мы готовы? Поехали!

# Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, а также
следующими дополнительными пакетами:
- Microsoft.AspNetCore.SignalR
- @microsoft/signalr
Пакет Microsoft.AspNetCore.SignalR поставляется вместе с фреймворком Microsoft.AspNetCore.App,
а это значит, что в наших приложениях ASP.NET Core он уже есть.
Как всегда, рекомендуется избегать их установки сразу; мы будем вводить их в течение
в этой главе, чтобы лучше понять их назначение в нашем проекте.
Файлы кода для этой главы можно найти по адресу https://github.com/PacktPublishing/ASP.NET-Core6-and-Angular/tree/master/Chapter_14/.

# HTTP и серверный толчок в реальном времени
Обеспечение функциональности веб-приложений в режиме реального времени было очень сложной задачей в первые два десятилетия существования
Интернета, в основном из-за того, что протокол HTTP никогда не был предназначен для этого. Как мы узнали
в главе 13 "За пределами REST - Web API и GraphQL", когда мы вкратце рассмотрели принципы REST и
ограничения, взятые из спецификаций HTTP/1.0 и 1.1, в них не было ссылок на обмен данными в реальном времени
коммуникации, потоковые протоколы, вызовы, инициируемые сервером, или любые другие техники, которые могли бы привести
к чему-то отличному от цикла "запрос/ответ", основанного на "вытягивании", который инициируется клиентским запросом и
обрабатывается сервером с соответствующим (и завершающим) ответом.
Именно по этой причине на протяжении большей части 90-х годов наиболее эффективными способами реализации поведения в реальном времени
в веб-приложениях были:
- Использование Java, Flash/ActionScript или другого "встраиваемого" контента, который мог (A) поддерживать подходящую технологию для достижения такого поведения (сокет, потоковая передача, push/pub) и (B) взаимодействовать с
DOM через JavaScript, плагин для браузера, VM, компонент времени выполнения или любую другую жизнеспособную технику.
технику
- "Эмуляция" поведения в реальном времени, выполнение частых обновлений контента через полностраничное обновление,
обновление на основе iframe, опросы на основе Ajax (XMLHttpRequest) или другие обходные пути, которые могут быть использованы для
которые можно использовать для поддержания данных в актуальном состоянии.
Вышеперечисленные техники были довольно распространены на биржевых и чат-сайтах: однако они
Однако они не получили широкого распространения, поскольку их было сложно поддерживать и часто возникали проблемы с совместимостью между
различных браузеров - в конце концов, это был период "ада кросс-браузерной совместимости".
Однако RFC 2616 (HTTP/1.1, 1999) ввел существенное отличие постоянных соединений от поведения по умолчанию любого HTTP-соединения; в основном это означало, что, если не указано иное
клиент ДОЛЖЕН считать, что сервер будет поддерживать постоянное соединение, даже после
ответов сервера об ошибках.

Такое утверждение, хотя и не имеет строгого отношения к потоковой передаче данных или общению в реальном времени, заставило многих
разработчиков искать альтернативный способ установления соединения между клиентом и сервером, который
который позволил бы осуществлять двусторонний обмен информацией в реальном времени. Такие эксперименты, продолжавшиеся в течение
почти 20 лет, привели к появлению pushlets, длинных опросов, Server-Sent Events (SSE) и, в конечном счете, альтернатив на базе HTTP/2-
альтернативам, таким как Web Push, gRPC и WebRTC: однако только после появления
и принятия протокола WebSocket (RFC 6455, декабрь 2011 г.) наличие возможностей реального времени в веб-приложениях стало широко распространяться.
возможностей в веб-приложениях стало широко распространяться.

# Представляем SignalR
Какое отношение все это имеет к SignalR? На самом деле, подход ASP.NET Core к обработке
ASP.NET Core к обработке требований реального времени для веб-приложений является абстракцией большинства техник, о которых мы только что
упомянутых нами.
Если говорить более конкретно, SignalR использует преимущества следующих транспортных методов (в порядке убывания):
- WebSockets
- SSE
- HTTP длинный опрос
Лучшая технология, поддерживаемая клиентом и сервером, используется SignalR для инициирования соединения
и выполнения своих задач, которые в основном решаются с помощью хабов и протоколов обмена данными.

# Хабы
Хабы являются ключевым понятием в SignalR, поскольку они используются для связи между клиентами и серверами:
тип Hub определен в пространстве имен Microsoft.AspNetCore.SignalR и является частью типа
Microsoft.AspNetCore.SignalR NuGet.
Концентраторы можно рассматривать как высокоуровневые диспетчеры, которые позволяют клиенту и серверу вызывать методы друг у друга, используя стандартизированный API - SignalR.
друг друга, используя стандартизированный API - SignalR Hubs API.

# Протоколы
Данные между клиентом и сервером передаются с помощью методов сериализации и десериализации, основанных на двух протоколах обмена данными: текстовом протоколе на основе JSON и бинарном протоколе
основанный на MessagePack, менее известном формате обмена данными.

На самом деле существует третий протокол под названием BlazorPack, который используется исключительно с
Blazor Server, поскольку он требует модели хостинга Blazor Server. Для получения дополнительной
информацию можно найти в официальной документации по следующему адресу:

Hub открывается сервером через специальный маршрут, который может использоваться клиентами для подключения и
получать события в виде сообщений, которые рассылаются подписанным пользователям и группам.

# Соединения, пользователи и группы
Соединения, пользователи и группы - это три фундаментальные концепции, используемые сервером для передачи
сообщений в реальном времени клиентам с помощью SignalR. Каждое из них имеет свои особенности и служит
конкретной цели:
- Соединения. В SignalR каждый клиент имеет уникальное соединение с сервером: когда клиент
подключается к хабу, SignalR генерирует уникальный идентификатор, который известен только заинтересованным сторонам.
Это означает, что каждое клиентское соединение имеет свой собственный идентификатор.
- Пользователи. Пользователь рассматривается SignalR как подписанный человек, который обрабатывается как часть группы.
Пользователей не следует путать с соединениями или клиентами, поскольку один пользователь может подключаться из
нескольких клиентских приложений: например, один и тот же пользователь может подключаться через веб-браузер
и мобильного телефона одновременно, получая сообщения на них обоих.
- Группы. Группы представляют собой совокупность одного или нескольких соединений и являются основным механизмом, используемым
SignalR для передачи данных клиентам в режиме реального времени. Любая группа имеет имя, которое служит ее
Это имя будет использоваться SignalR для отправки сообщений в реальном времени. Когда эти
сообщения отправляются в группу, все члены группы (соединения, входящие в состав
этой группы) получают уведомления.
Хватит теории: лучший способ понять эти концепции - увидеть SignalR в действии, что мы и сделаем.
чем мы и займемся в следующих разделах.

# Реализация SignalR
Давайте вкратце вспомним, как сейчас работают наши проекты HealthCheck и HealthCheckAPI:
- В Angular-приложении HealthCheck есть компонент - HealthCheckComponent, который сразу после загрузки
после загрузки выполняет вызов конечной точки /health на стороне сервера.
- Вышеупомянутая конечная точка обрабатывается HealthCheckMiddleware: при вызове HealthCheckAPI
ASP.NET Core Web API настроен на запуск различных ICMP проверок здоровья, каждая из которых настроена
пинговать имя хоста или IP-адрес и возвращать его статус (здоровый или нездоровый).
- Статусы проверок здоровья оборачиваются вместе с помощью HealthCheckMiddleware и отправляются в
единый ответ в формате JSON.
- Приложение HealthCheck Angular получает ответ JSON и использует его для создания HTML-таблицы,
отображая результат в удобочитаемом формате.
Как мы видим, единственным взаимодействием между двумя проектами является один HTTP-вызов, отправленный к конечной точке /health
сразу после получения первого результата проверки здоровья, результат на экране не изменится, пока мы вручную не обновим страницу браузера, тем самым "перезагрузив" HealthCheckComponent и заставив его выполнить
новый HTTP-вызов. Пока мы этого не сделаем, данные, отображаемые в HTML-таблице, будут не более чем статичным,
возможно, устаревший снимок из прошлого.

Будьте уверены, мы можем легко реализовать таймер (используя JS-функцию интервала или что-то подобное)
для автоматического принудительного обновления страницы каждые несколько минут или секунд, гарантируя тем самым, что HTML-данные
всегда будут свежими: это стратегия "эмуляции в реальном времени", о которой мы говорили в начале
в которой используется техника частого опроса, чтобы обойти тот факт, что задача обновления данных
всегда инициируется клиентом (pull) и никогда - сервером (push).
Однако такой обходной путь имеет множество недостатков:
- Влияние на производительность. Множество потенциально ненужных (и некэшируемых) HTTP-запросов, не говоря уже о
не говоря уже о ICMP-вызовах, которые выдает сервер каждый раз, когда его просят показать обновленный результат.
- Избыточная выборка. Частые опросы о состоянии здоровья неизбежно приведут к большому количеству бесполезных вызовов:
Точнее, любой HTTP-запрос, получающий JSON-ответ с тем же результатом, что и предыдущий, можно считать "потраченным впустую".
- Неэффективно. Как бы часто мы ни настраивали опрос, всегда будет существовать определенная
определенный "лаг" между изменением проверки здоровья и соответствующим обновлением пользовательского интерфейса: если мы планируем
использовать эту HTML-таблицу в качестве монитора, чтобы оперативно реагировать на сбой проверки, наше время реакции
время реакции будет затруднено из-за этой задержки.
- Самоограничение. Если задача обновления данных может быть инициирована только на уровне клиента, каждый
клиент всегда будет работать как отдельный, независимый пир. Это означает, что не будет возможности
обновить эти данные из другого источника, например с сервера, стороннего сервиса, другого
клиента и так далее.

SignalR может помочь нам улучшить текущее поведение приложения HealthCheck, не сталкиваясь с вышеупомянутыми
недостатков: точнее, мы можем использовать его для реализации стратегии обновления данных, инициируемой сервером
с помощью широковещательного сообщения, одновременно отправляемого всем подключенным клиентам, что вызовет обновление.
Вот разбивка необходимых задач для достижения такого результата:
- Установить и настроить SignalR в ASP.NET Core, используя необходимые сервисы и промежуточное ПО, а также
а также необходимые параметры конфигурации CORS для разрешения соединений из внешних источников
- Обновите проект HealthCheckAPI, чтобы реализовать SignalR на уровне сервера
- Установите и настройте SignalR в Angular с помощью пакета npm @microsoft/signalr
- Обновите проект HealthCheck, чтобы реализовать SignalR в нашем приложении Angular.
- Протестируйте все, чтобы убедиться, что наша реализация работает так, как ожидалось.
Как обычно, давайте начнем с задач на стороне сервера.

# Настройка SignalR в ASP.NET Core
Чтобы включить сервисы SignalR в проекте HealthCheckAPI, первым делом нам нужно создать
хаб: затем мы настроим необходимые сервисы и промежуточное ПО, и, наконец, реализуем
широковещательное сообщение для отправки обновлений клиенту.

# Создание HealthCheckHub
Создайте новый файл HealthCheckHub.cs в корневой папке проекта HealthCheckAPI и заполните его следующим содержимым
следующим содержимым:

```Csharp
using Microsoft.AspNetCore.SignalR;
namespace HealthCheckAPI
{
 public class HealthCheckHub : Hub
 {
 }
}
```
Класс намеренно пустой, поскольку нам не нужно добавлять никаких методов (пока): однако важно, чтобы он был производным от базового класса Hub, что является обязательным условием для любого концентратора SignalR.
важно, чтобы он был производным от базового класса Hub, что является обязательным условием для любого хаба SignalR.

# Настройка сервисов и промежуточного ПО
Теперь, когда у нас есть хаб, мы можем добавить сервисы SignalR и промежуточное ПО в конфигурацию нашего приложения
класс. Откройте файл Program.cs и добавьте следующую строку прямо под настройками CORS:

```Csharp
builder.Services.AddCors(options =>
 options.AddPolicy(name: "AngularPolicy",
 cfg => {
 cfg.AllowAnyHeader();
 cfg.AllowAnyMethod();
 cfg.WithOrigins(builder.Configuration["AllowedCORS"]);
 }));
builder.Services.AddSignalR();
```

После этого прокрутите файл вниз до конца и добавьте следующую строку прямо под Minimal API
который обрабатывает сердцебиение, добавленное нами в главе 12 "Прогрессивные веб-приложения":

```Csharp
app.MapMethods("/api/heartbeat", new[] { "HEAD" },
 () => Results.Ok());
app.MapHub<HealthCheckHub>("/api/health-hub");
```
Конечная точка /api/health-hub позволит нашему клиенту подключиться к концентратору и получить широковещательное
сообщение: теперь нам нужно найти способ отправить его.

# Добавление широковещательного сообщения
Лучшее, что мы можем сделать для реализации широковещательного сообщения SignalR таким образом, чтобы мы могли отправлять его
по требованию, - это добавить специальный маршрут, который как раз этим и занимается: это позволит нам отправлять сообщение, выполняя
выполнив заданный URL, что очень удобно для тестирования, поскольку позволяет эмулировать не только серверную
задачу, но и что-то, инициированное третьей стороной.

# Использование контроллера
Если мы хотим обрабатывать такой маршрут с помощью контроллера, мы можем сделать это, добавив новый BroadcastController.
cs в папку /Controllers/ и заполнив его следующим кодом:

```Csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR;
namespace HealthCheckAPI.Controllers
{
 [ApiController]
 [Route("api/[controller]/[action]")]
 public class BroadcastController : ControllerBase
 {
 private IHubContext<HealthCheckHub> _hub;
 public BroadcastController(
 IHubContext<HealthCheckHub> hub
 )
 {
 _hub = hub;
 }
 [HttpGet]
 public async Task<IActionResult> Update()
 {
 await _hub.Clients.All.SendAsync("Update", "test");
 return Ok("Update message sent.");
 }
 }
}
```

Приведенный выше код должен быть довольно прост для понимания: мы просто инжектировали наш концентратор в конструктор контроллера
конструктора с помощью DI, а затем использовали его в методе действия Update для трансляции сообщения "Update"
всем подключенным клиентам.
По сути, это означает, что широковещательное сообщение будет отправлено при выполнении конечной точки /api/broadcast/
конечной точки update.

# Использование минимального API
Однако использование контроллера - не единственный способ выполнить нашу задачу: начиная с .NET 6, мы также можем выбрать
Minimal API, чтобы достичь того же результата со значительно меньшим объемом исходного кода.
Давайте воспользуемся возможностью реализовать и эту альтернативу. Откройте файл Program.cs и добавьте
следующие выделенные строки прямо под промежуточным ПО SignalR:

```Csharp
using Microsoft.AspNetCore.SignalR;
// ...
app.MapHub<HealthCheckHub>("/api/health-hub");
app.MapGet("/api/broadcast/update2", async (IHubContext<HealthCheckHub> hub) =>
{
 await hub.Clients.All.SendAsync("Update", "test");
 return Results.Text("Update message sent.");
});
```

Как мы видим, мы использовали разные маршруты, чтобы разделить два подхода, поскольку мы хотим поддерживать
оба: теперь широковещательное сообщение будет отправляться при выполнении либо конечной точки /api/broadcast/
update endpoint (обрабатывается BroadcastController) или /api/broadcast/update2 endpoint
(обрабатывается методом Minimal API, описанным выше).

Стоит отметить, что контроллер и метод Minimal API выполняют одну и ту же задачу.
в реальных приложениях следует избегать: здесь мы делаем это только для примера. Важно понять, как эти два подхода
могут быть использованы вместе в одном веб-приложении, в идеале - для решения разных задач.

Теперь мы наконец-то можем перейти на Angular.

# Установка SignalR в Angular
Для установки SignalR в Angular мы воспользуемся @microsoft/signalr, пакетом npm, выпущенным
Microsoft, содержащий необходимые клиенты JavaScript и TypeScript. После этого мы создадим
HealthCheckService для выполнения необходимых задач и заменим текущую реализацию HttpClient в компоненте HealthCheckComponent.

# Добавление пакета npm
Давайте начнем с пакета npm @microsoft/signalr. Откройте консоль командной строки, перейдите в корневую папку
корневую папку приложения HealthCheck и введите следующую команду:
```
> npm install @microsoft/signalr@6.0.1
```
Или, если хотите, просто добавьте ссылку на пакет в файл package.json проекта, а затем выполните
npm install.

Теперь мы можем создать нашу новую службу.

# Реализация сервиса HealthCheckService
Приложение HealthCheck пока не имеет никаких сервисов: по сути, мы никогда не испытывали желания
создавать его, поскольку оно выполняет минимальное количество HTTP-вызовов. Однако теперь, когда нам нужно добавить
некоторые задачи, связанные с SignalR, лучше рефакторить всю логику HTTP-соединений и получения данных в
выделенном классе.
В проводнике решений Visual Studio перейдите в папку /src/app/health-check/, создайте новый файл
health-check.service.ts и заполните его следующим кодом:

```ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import * as signalR from "@microsoft/signalr";
import { environment } from './../../environments/environment';
import { Observable, Subject, tap } from 'rxjs';
@Injectable({
 providedIn: 'root'
})
export class HealthCheckService {
 private hubConnection!: signalR.HubConnection;
 private _result: Subject<Result> = new Subject<Result>();
 public result = this._result.asObservable();
 constructor(private http: HttpClient) {
 }
public startConnection() {
 this.hubConnection = new signalR.HubConnectionBuilder()
 .configureLogging(signalR.LogLevel.Information)
 .withUrl(environment.baseUrl + 'api/health-hub', { withCredentials:
false })
 .build();
 console.log("Starting connection...");
 this.hubConnection
 .start()
 .then(() => console.log("Connection started."))
 .catch((err : any) => console.log(err));
 this.updateData();
 }
 public addDataListeners() {
 this.hubConnection.on('Update', (msg) => {
 console.log("Update issued by server for the following reason: " + msg);
 this.updateData();
 });
 public updateData() {
 console.log("Fetching data...");
 this.http.get<Result>(environment.baseUrl + 'api/health')
 .subscribe(result => {
 this._result.next(result);
 console.log(result);
 });
 }
export interface Result {
 checks: Check[];
 totalStatus: string;
 totalResponseTime: number;
}
interface Check {
 name: string;
 responseTime: number;
status: string;
 description: string;
}
```
Приведенный выше код, возможно, не так прост для понимания с первого взгляда, однако в нем есть несколько полезных
вызовы console.log, которые можно использовать для понимания происходящего.
Как мы видим, важные задачи выполняются тремя методами:
- startConnection. Этот метод инстанцирует hubConnection, постоянное соединение с конечной точкой
SignalR, которое мы настроили в нашем приложении ASP.NET Core, чтобы наш клиент мог
слушать события хаба и действовать соответствующим образом. Он также один раз выполняет метод updateData
чтобы получить исходные данные для отображения.
- addDataListeners. Этот метод должен выполняться сразу после вышеупомянутого метода, поскольку он
требует уже существующего hubConnection и регистрирует обработчик события "Update":
такой обработчик, по сути, регистрирует полученное сообщение и выполняет метод updateData, чтобы
"обновить" данные, отображаемые в пользовательском интерфейсе.
- updateData. Этот метод, как следует из названия, выполняет стандартный HTTP-вызов к
HealthCheckMiddleware API endpoint для получения данных проверки здоровья и выдачи нового значения
в приватную тему _result, тем самым уведомляя всех подписчиков публичной таблицы результатов
который его инкапсулирует.
Как мы видим, мы используем ту же логику, основанную на наблюдениях, которую мы применили для службы AuthService приложения WorldCities в главе 11.
AuthService в главе 11, Аутентификация и авторизация: наблюдаемый результат будет уведомлять все
о любом обновленном результате SignalR, чтобы они могли действовать соответствующим образом.
Более того, поскольку вся работа с HTTP выполняется здесь, мы воспользовались возможностью перенести интерфейсы Result и
Check в этот файл (сейчас они находятся в файле health-check.component.ts): мы также добавили ключевое слово export в интерфейс Result, поскольку мы собираемся использовать его в HealthCheckComponent-.
как мы увидим в ближайшее время.

# Рефакторинг компонента HealthCheckComponent
Теперь, когда у нас есть сервис HealthCheckService, выполняющий тяжелую работу, нам нужно рефакторить компонент
HealthCheckComponent, заменив текущую реализацию HttpClient на методы сервиса.
Начнем с файла TypeScript.

# health-check.component.ts
Откройте файл /src/app/health-check/health-check.component.ts и замените существующее содержимое
следующим кодом (соответствующие новые строки выделены):

```ts
import { Component, Inject, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { HealthCheckService, Result } from './health-check.service';
@Component({
selector: 'app-health-check',
 templateUrl: './health-check.component.html',
 styleUrls: ['./health-check.component.scss']
})
export class HealthCheckComponent implements OnInit {
 public result: Observable<Result | null>;
 constructor(
 public service: HealthCheckService) {
 this.result = this.service.result;
 }
 ngOnInit() {
 this.service.startConnection();
 this.service.addDataListeners();
 }
}
```

Если мы сравним новый код со старым, то увидим, что новая реализация
гораздо быстрее и легче читается, поскольку вся логика извлечения данных убрана: именно для этого и предназначены
для этого и предназначены сервисы.

Стоит отметить, что подход, использованный для рефакторинга компонента HealthCheckComponent, весьма
похож на тот, что мы использовали в компоненте NavMenuComponent нашего приложения WorldCities, поскольку нам необходимо
выполнить ту же задачу: обновлять пользовательский интерфейс при получении новых/свежих данных от сервиса зависимостей. Единственное различие заключается в том, что вместо Subject мы использовали async pipe,
как мы это делали в главе 9 "Отладка на заднем и переднем фронтах".

Теперь мы можем перейти к файлу шаблона.

# health-check.component.html
Файл шаблона компонента требует лишь минимальных изменений, в основном благодаря тому, что мы используем
HealthCheckService член result вместо предыдущей локальной переменной.
Откройте файл /src/app/health-check/health-check.component.html и выполните следующие изменения
изменения (обновленный код выделен):

```html
<h1>Health Check</h1>
<p>Here are the results of our health check:</p>
<p *ngIf="!(result | async)"><em>Loading...</em></p>
<table *ngIf="result | async as res">
 <thead>
 <tr>
 <th>Name</th>
 <th>Response Time</th>
 <th>Status</th>
 <th>Description</th>
 </tr>
 </thead>
 <tbody>
 <tr *ngFor="let check of res.checks">
 <td>{{ check.name }}</td>
 <td>{{ check.responseTime }}</td>
 <td class="status {{ check.status }}">{{ check.status }}</td>
 <td>{{ check.description }}</td>
 </tr>
 </tbody>
</table>
```
Вот и все: файл таблицы стилей не требует изменений, а значит, все готово.

# Тестируем
Наконец-то пришло время проверить все, что мы сделали до сих пор.
Запустите оба проекта в режиме отладки и в приложении Angular перейдите к компоненту HealthCheckComponent.
До этого момента мы не должны видеть никаких различий в пользовательском интерфейсе, поскольку мы все еще выполняем начальный HTTP-вызов для
для получения данных о проверке здоровья: однако, если мы посмотрим на консоль браузера, то уже увидим
записи в журнале console.log, показывающие, что соединение с концентратором успешно установлено,
как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1cedecd2-928e-428a-821a-2bf04e71e745)

Теперь мы можем проверить, работает ли инициированное сервером обновление так, как ожидалось. Для этого откройте другой браузер
(или вкладку) и перейдите по следующим URL-адресам:
https://localhost:40443/api/broadcast/update
https://localhost:40443/api/broadcast/update2

Как мы уже знаем, первая конечная точка обрабатывается контроллером BroadcastController, а вторая - с помощью
Minimal API. Однако обе они должны приводить к одному и тому же результату: при каждом запросе компонент
HealthCheckComponent должен обновлять данные о проверках здоровья.
Обновление можно проверить, посмотрев на значение Response Time в миллисекундах, которое, скорее всего, будет
при каждом обновлении будет иметь другое значение, а также в консоли браузера, где мы должны видеть
сообщения запроса обновления сервера и новые данные, полученные при последующем HTTP-вызове:

![image](https://github.com/artemovsergey/Angular/assets/26972859/51a32e99-ceae-4612-a687-d805df0323ae)

Наша базовая реализация, похоже, работает.

# События, инициируемые клиентом
Однако мы работали только с трансляцией от сервера к клиенту: что, если мы хотим отправить что-то от
нашего клиента на сервер? Это правда, что у нас есть конечная точка URL для проверки нашего сообщения об обновлении, но можем ли мы
отправить его из hubConnection?
На самом деле, можно: и это довольно просто реализовать, поскольку мы уже сделали большую часть
необходимой работы.
Если говорить точнее, то вот что нам нужно сделать:
- Обновить HealthCheckHub на уровне сервера, чтобы дать клиентам возможность вызывать
метод обновления
- Обновить HealthCheckComponent на уровне клиента, чтобы он действительно вызывал метод.
- Протестируйте его, чтобы убедиться, что все работает так, как ожидалось.
Давайте сделаем это.

# Обновление концентратора HealthCheckHub
Как мы уже знаем, концентратор SignalR позволяет осуществлять двунаправленный обмен данными, то есть клиенты могут
отправлять данные через него: однако, если мы хотим разрешить такое поведение, нам нужно реализовать необходимые
методы в самом концентраторе.
Для этого откройте файл HealthCheckHub.cs и добавьте следующий метод Update:

```Csharp
using Microsoft.AspNetCore.SignalR;
namespace HealthCheckAPI
{
 public class HealthCheckHub : Hub
 {
 public async Task ClientUpdate(string message) =>
 await Clients.All.SendAsync("ClientUpdate", message);
 }
}
```

Приведенный выше код очень похож на тот, что мы использовали в BroadcastController и Minimal API:
однако на этот раз мы использовали другое событие трансляции, чтобы мы могли отличить его от
инициированного сервером. Кроме того, мы воспользовались возможностью разрешить отправку пользовательского сообщения, которое клиенты могут
которое клиенты могут отправить, и которое будет передано вместе с событием.

# Обновление службы HealthCheckService
Теперь, когда у нашего хаба есть метод Update, нам нужно просто вызвать его у клиента.
Вернитесь в наше приложение Angular, откройте файл /src/app/health-check/health-check.service.ts и
добавьте следующий метод чуть ниже существующего метода updateData, прямо перед концом класса:

```ts
public sendClientUpdate() {
 this.hubConnection.invoke('ClientUpdate', 'client test')
 .catch(err => console.error(err));
 }
```

Поскольку мы используем новое событие, нам также нужно добавить новый обработчик события для его получения. Прокрутите
вверх по тому же файлу и добавьте следующий код к существующему методу addDataListeners:

```ts
this.hubConnection.on('ClientUpdate', (msg) => {
 console.log("Update issued by client for the following reason: " + msg);
 this.updateData();
 });
}
```

Теперь нам нужно просто выполнить метод sendClientUpdate на клиенте. Лучшее место для этого
это компонент HealthCheckComponent.

# Обновление компонента HealthCheckComponent
Поскольку нам нужно просто выполнить публичный метод, достаточно простой HTML-кнопки в файле шаблона компонента HealthCheckComponent
в файле шаблона, как показано ниже, будет достаточно:

```html
<button (click)="service.sendClientUpdate()">
 Refresh
</button>
```
Однако, поскольку мы не хотим напрямую вызывать метод этого сервиса через HTML-шаблон компонента
шаблон, давайте создадим для этого локальный метод.
Откройте файл /src/app/health-check/health-check.component.ts и добавьте следующий метод
в конец файла, прямо под существующим методом ngOnDestroy():

```ts
onRefresh() {
 this.service.sendClientUpdate();
}
```
После этого откройте файл /src/app/health-check/health-check.component.html и добавьте следующие строки к существующему коду, чтобы вызвать метод, который мы только что добавили.
следующие строки в существующий код, чтобы вызвать метод, который мы только что добавили:

```html
<hr />
<button (click)="onRefresh()">
 Refresh
</button>
```
Вот и все: теперь мы можем проверить, что у нас получилось.

# Тестирование новой функции
Чтобы протестировать новую функцию, запустите оба проекта в режиме отладки, затем используйте приложение Angular для перехода
к компоненту HealthCheckComponent. Нажав на кнопку обновления, вы увидите, как происходит волшебство: если мы
мы все сделали правильно, мы сможем увидеть, как значения времени отклика в миллисекундах меняются при
при каждом обновлении, а также увидеть сообщения об обновлении клиента в консоли браузера, как показано на
следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/8b691e86-a346-4799-9e3e-75640d03ac32)

На этом наш обзор ASP.NET Core SignalR завершен.
Будьте уверены, мы лишь пощупали поверхность многочисленных встроенных функций библиотеки и примеров ее использования, но теперь, когда мы научились устанавливать соединение с хабом и отправлять данные с сервера на клиенты и обратно
клиентам и наоборот, мы определенно сможем использовать ее, чтобы привнести в наши проекты возможность обновления в реальном времени.

# Резюме
Эта глава была полностью посвящена SignalR, библиотеке с открытым исходным кодом, разработанной Microsoft и поставляемой вместе с ASP.NET Core.
поставляемой с ASP.NET Core, которая позволяет нам добавлять функциональность реального времени в веб-приложения.
В первой части главы мы разобрались с концепциями Real-Time HTTP и Server-side
Push, рассмотрели различные техники и обходные пути, использовавшиеся с момента появления Интернета, чтобы
достижения или эмуляции таких возможностей; затем мы быстро рассмотрели основные возможности SignalR, который
который использует большинство из этих методов для создания уровня абстракции, доступного через собственный
API и построенный вокруг таких понятий, как хабы, протоколы, соединения, пользователи и группы.
Сразу после этого мы приступили к работе над кодом и реализовали SignalR в ASP.NET Core и Angular, а также
а также установили и настроили необходимые пакеты Microsoft NuGet и npm. Более конкретно,
мы начали с реализации инициируемого сервером широковещательного события, которое может быть выпущено путем выполнения
выделенного маршрута: в процессе работы мы воспользовались возможностью реализовать такой маршрут, используя либо выделенный контроллер, либо альтернативу Minimal API.
выделенный контроллер, либо альтернативный подход Minimal API, представленный в .NET 6. После этого мы
добавили событие, инициируемое клиентом, чтобы посмотреть, как можно использовать соединение Hub, которое мы реализовали в самом начале.
использовать наоборот.
Теперь мы готовы перейти к следующей - и последней - теме этой книги: развертыванию приложений.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: SignalR, HTTP/1.0, HTTP/1.1, RFC 2616,
Server Push, HTTP Long Polling, gRPC, WebRTC, WebSocket, WebSocketAPI, RFC 6455, Server-Sent
Events (SSE), MessagePack, BlazorPack.











