# ASP.NET Core and Angular Unit Testing

Модульное тестирование — это название метода тестирования программного обеспечения, который помогает определить,
изолированные модули программы (юниты) работают корректно. После проверки различных блоков
их можно объединить и протестировать как единое целое (интеграционное тестирование и системное тестирование) и/или
выпущен в производство.
Учитывая это определение, довольно легко понять важность правильного определения и изоляции
различные подразделения. Это самые маленькие тестируемые части нашего программного обеспечения, включающие несколько входов и
один выход. В объектно-ориентированном программировании (ООП), где исходный код программы разделен.
на классы, модуль часто является методом супер, абстрактного или производного класса, однако он также может быть статическим.
функция вспомогательного класса.
Хотя модульные тесты стали де-факто стандартом для высококачественных проектов, их часто недооценивают большинство разработчиков и менеджеров проектов, которые стремятся ускорить всю разработку.
процесса и, следовательно, снизить его общую стоимость. Фактически, создание нескольких модульных тестов одновременно
развитие может стать помехой для небольших проектов с низкой рентабельностью, поскольку такие
этот подход, несомненно, требует некоторой дополнительной работы. Однако очень важно понимать
их огромные преимущества для средних и крупных проектов и корпоративных решений, особенно если они требуют
скоординированные усилия большого количества разработчиков.
Эта глава полностью посвящена модульным тестам. Точнее, мы научимся определять, реализовывать,
и выполните следующее:
• Внутренние модульные тесты в ASP.NET Core с использованием инструмента тестирования xUnit.net.
• Модульные тесты внешнего интерфейса в Angular с использованием среды тестирования Jasmine и теста Karma.
бегун, которого мы кратко видели в главе 3 «Оглядываясь вокруг».
У нас также будет возможность кратко представить некоторые широко используемые методы тестирования, которые могут помочь.
нам, чтобы получить максимальную отдачу от наших тестов, таких как разработка через тестирование (TDD) и управление поведением.
Разработка (БДД).


# Технические требования
К концу этой главы мы научимся правильно проектировать и реализовывать серверную часть и
интерфейсные модульные тесты в соответствии с этими практиками.
Для простоты мы собираемся выполнить модульный тест в существующем Angular WorldCities.
приложение. Однако для этого мы добавим в наш проект несколько новых пакетов.
Технические требования
В этой главе нам понадобятся все технические требования, перечисленные в предыдущих главах, с
следующие дополнительные пакеты:
- Microsoft.NET.Test.Sdk
- xunit
- xunit.runner.visualstudio
- Moq
- Microsoft.EntityFrameworkCore.InMemory
Как всегда, желательно не устанавливать их сразу. Мы собираемся привезти их во время
эту главу, чтобы лучше понять их цель в рамках нашего проекта.
Файлы кода для этой главы можно найти здесь: https://github.com/PacktPublishing/ASP.NETCore-6-and-Angular/tree/main/Chapter_10/.

# Модульные тесты ASP.NET Core
В этом разделе мы узнаем, как создать проект модульного тестирования ASP.NET Core с помощью xUnit.net, бесплатного инструмента модульного тестирования с открытым исходным кодом, ориентированного на сообщество для .NET, созданного Брэдом Уилсоном, который также разработал
NUnit v2. Мы выбрали этот инструмент, потому что он, возможно, один из самых мощных и простых в использовании.
инструменты тестирования, доступные сегодня. Он является частью .NET Foundation и, следовательно, действует в соответствии с его кодексом
поведения и распространяется по лицензии Apache версии 2.
Прежде чем двигаться дальше, мы также воспользуемся возможностью поговорить о TDD и BDD в следующих разделах.
Это два широко используемых подхода к тестированию, которые имеют ряд сходств и различий.
стоит изучить.

# Создание проекта WorldCitiesAPI.Tests
Первое, что нужно сделать, — это добавить третий проект в наше решение WorldCities, в котором в настоящее время размещается
Приложение WorldCities Angular и базовый веб-API WorldCitiesAPI ASP.NET.
Если вы создали решение в отдельной папке, как мы предлагали в главе 2 «Подготовка — оставляем
флаг «Поместить решение и проект в один каталог» установлен в положение «OFF» — задача довольно проста: просто откройте
в командной строке перейдите к папке решения, например C:/Projects/WorldCities/, и
введите следующую команду:

```
> dotnet new xunit -o WorldCitiesAPI.Tests
```
.NET CLI должен создать для нас новый проект и выполнить некоторые действия после его создания. Когда-то сделали,
сообщение сообщит нам, что задача восстановления завершена (Restore успешна). Если мы имеем
все сделали правильно, в этой же папке должен присутствовать новый проект WorldCitiesAPI.Tests
уровне, как существующие проекты WorldCities и WorldCitiesAPI.
Сразу после этого мы можем добавить наш новый проект WorldCitiesAPI.Tests в наше основное решение в
следующим образом:
1. В обозревателе решений щелкните правой кнопкой мыши корневой узел решения и выберите «Добавить существующий проект».
2. Перейдите в папку /WorldCitiesAPI.Tests/ и выберите файл WorldCitiesAPI.Tests.proj.
файл
Новый проект WorldCitiesAPI.Tests будет загружен в существующее решение, прямо под существующим.
Проект WorlCitiesAPI, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/474339cf-9a79-4c0f-bbec-35bc102eb4d3)

В качестве альтернативы мы могли бы добавить новый проект в файл решения непосредственно из CLI с помощью
следующую команду: dotnet sln add WorldCitiesAPI.Tests.

Удалим существующий файл UnitTest1.cs, так как он нам не понадобится. Создадим собственное модульное тестирование
занятия в короткие сроки.
Новый проект WorldCitiesAPI.Tests уже должен иметь следующие ссылки на пакеты NuGet:

- Microsoft.NET.Test.Sdk (version 16.11 or later)
- xunit (version 2.4.1 or later)
- xunit.runner.visualstudio (version 2.4.3 or later)

Номера версий предыдущих пакетов являются последними на момент написания, а
те, которые мы собираемся использовать в этой книге.

Первое, что необходимо сделать, это обновить пакет Microsoft.NET.Test.Sdk до версии 17.0.0 (последняя версия).
на момент написания). Кроме того, нам необходимо установить два дополнительных пакета NuGet: Moq и
Microsoft.EntityFrameworkCore.InMemory. Давайте посмотрим, для чего они предназначены и как их добавить.
в следующих разделах.

# Moq
Moq, пожалуй, самый популярный и удобный фреймворк для макетирования для .NET. Чтобы лучше понять
зачем нам это нужно, нам нужно ввести понятие издевательства.
Mocking — это удобная функция, которую мы можем использовать при модульном тестировании всякий раз, когда модуль, который мы хотим протестировать,
имеет внешние зависимости, которые нелегко создать в рамках проекта тестирования. Главная цель
Суть макета фреймворка заключается в создании замещающих объектов, имитирующих поведение реальных объектов. Мокк
— это минималистичный фреймворк, который сделает именно это.
Чтобы установить его, сделайте следующее:
1. В обозревателе решений щелкните правой кнопкой мыши проект WorldCitiesAPI.Tests и выберите «Управление».
NuGet-пакеты
2. Найдите ключевое слово Moq.
3. Найдите и установите пакет Moq NuGet.
Альтернативно, просто введите следующую команду в консоли диспетчера пакетов Visual Studio (настройка
WorldCitiesAPI.Tests в качестве проекта по умолчанию):

```
> Install-Package Moq
```
# Microsoft.EntityFrameworkCore.InMemory
Microsoft.EntityFrameworkCore.InMemory — поставщик базы данных в памяти для Entity Framework.
Ядро, которое можно использовать в целях тестирования. По сути, это та же концепция, что и веб-API Angular в памяти, о котором мы говорили в главе 5 «Модель данных с Entity Framework Core». В двух словах,
мы можем думать об этом как об удобном макете базы данных.
Чтобы установить его, сделайте следующее:
1. В обозревателе решений щелкните правой кнопкой мыши проект WorldCitiesAPI.Tests и выберите «Управление».
NuGet-пакеты
2. Найдите ключевое слово Microsoft.EntityFrameworkCore.InMemory.
3. Найдите и установите пакет NuGet Microsoft.EntityFrameworkCore.InMemory.
Альтернативно, просто введите следующую команду в консоли диспетчера пакетов Visual Studio:

```
> Install-Package Microsoft.EntityFrameworkCore.InMemory
```

# Добавление ссылки на зависимости WorldCities
Следующее, что нам нужно сделать, это добавить ссылку на проект API в наш новый WorldCitiesAPI.Tests.
зависимости проекта, чтобы мы могли импортировать необходимые классы и типы.
Для этого щелкните правой кнопкой мыши узел «Зависимости» нового проекта, чтобы добавить новую ссылку на проект.
в проект WorldCitiesAPI, как показано на следующем снимке экрана, и нажмите ОК:

![image](https://github.com/artemovsergey/Angular/assets/26972859/ec0e205b-3a01-435a-8b7e-7aa0ee48d6ad)

Сделав это, наш тестовый проект сможет получить доступ (и, следовательно, протестировать) весь код WorldCitiesAPI.
Теперь мы готовы узнать, как на самом деле работает xUnit. Как всегда, лучший способ сделать это — создать наш
первый модульный тест.

# Наш первый тест
В практике разработки стандартного тестирования, которую мы с этого момента будем называть STD, модульные тесты
часто используются для обеспечения правильной работы существующего кода. Как только они будут готовы, эти подразделения будут
защищен от регрессионных ошибок и критических изменений.
Поскольку наш внутренний код представляет собой веб-API, первое, что мы рассматриваем в наших модульных тестах, — это методы отдельных контроллеров. Однако создание экземпляров наших контроллеров за пределами нашего веб-приложения
жизненный цикл не так прост, поскольку у них есть как минимум две важные зависимости: HttpContext и
ПриложениеDbContext. Есть ли способ создать их экземпляры в нашем проекте WorldCitiesAPI.Tests?
Благодаря Microsoft.EntityFrameworkCore.InMemory это может оказаться довольно простой задачей... как только мы
понять, как его использовать.
В обозревателе решений откройте проект WorldCitiesAPI.Tests. Создайте новый CitiesController_
Test.cs в корне проекта и заполните его следующим содержимым:

```Csharp
using Microsoft.EntityFrameworkCore;
using System.Threading.Tasks;
using WorldCitiesAPI.Controllers;
using WorldCitiesAPI.Data;
using WorldCitiesAPI.Data.Models;
using Xunit;
namespace WorldCitiesAPI.Tests
{
 public class CitiesController_Tests
 {
 /// <summary>
 /// Test the GetCity() method
 /// </summary>
 [Fact]
 public async Task GetCity()
 {
 // Arrange
 // todo: define the required assets
 // Act
 // todo: invoke the test
 // Assert
 // todo: verify that conditions are met.
 }
 }
}
```

Как мы видим, глядя на выделенные комментарии, мы разделили модульный тест на три кода.
блоки или фазы:
- Упорядочить: определяет ресурсы, необходимые для запуска теста.
- Действие: вызывает поведение испытуемого.
- Assert: проверяет выполнение ожидаемых условий путем оценки возвращаемого значения поведения.
или измерять его по некоторым пользовательским правилам
Такой подход известен как шаблон «Упорядочить, действовать, утверждать». Это типичный способ описания
различные этапы тестирования программного обеспечения в TDD. Однако существуют и альтернативные названия, используемые для описания
эти же этапы испытаний; например, в рамках BDD они обычно называются «Дано», «Когда» и «Тогда».
TDD и BDD — это две практики разработки, которые по сравнению с другими применяют другой подход к кодированию.
к СТД. Вскоре мы поговорим об этом подробнее.
Независимо от названий, здесь важно понимать следующие ключевые понятия:
- Разделение трех фаз повышает читаемость теста.
- Выполнение трех этапов в правильном порядке облегчает понимание теста.
Давайте теперь посмотрим, как мы реализовали эти три этапа.

# Arrange
Этап организации — это место, где мы определяем ресурсы, необходимые для запуска теста. В нашем сценарии
поскольку мы собираемся протестировать функциональность метода GetCity() CitiesController, нам нужно
предоставьте нашему контроллеру подходящий ApplicationDbContext.
Однако, поскольку мы не тестируем сам ApplicationDbContext, создание реального экземпляра не будет
желательно, по крайней мере, на данный момент. Мы не хотим, чтобы наш тест провалился только потому, что база данных недоступна.
или подключение к базе данных неверное, т. к. это разные единицы и поэтому их следует
проверено различными модульными тестами. Более того, мы определенно не можем позволить нашим модульным тестам работать против
наш реальный источник данных: что, если мы хотим протестировать задачу обновления или удаления?
Лучшее, что мы можем сделать для тестирования наших контроллеров веб-API, — это найти способ предоставить им замещающий объект, который может вести себя так же, как наш настоящий ApplicationDbContext; другими словами, издевательство.
Здесь находится пакет NuGet Microsoft.EntityFrameworkCore.InMemory, который мы установили ранее.
on может пригодиться.
Вот как мы можем использовать его для правильной реализации этапа аранжировки:

```Csharp
// Arrange
var options = new DbContextOptionsBuilder<ApplicationDbContext>()
 .UseInMemoryDatabase(databaseName: "WorldCities")
 .Options;
using var context = new ApplicationDbContext(options);
context.Add(new City()
{
 Id = 1,
 CountryId = 1,
 Lat = 1,
 Lon = 1,
 Name = "TestCity1"
});
context.SaveChanges();
var controller = new CitiesController(context);
City? city_existing = null;
City? city_notExisting = null;
```

Как мы видим, мы использовали метод расширения UseInMemoryDatabase, предоставленный Microsoft.
EntityFrameworkCore.InMemory для создания подходящего DbContextOptionsBuilder. Как только мы
если он есть, мы можем использовать его для создания экземпляра сеанса ApplicationDbContext с базой данных в памяти,
вместо SQL-сервера, используемого проектом WorldCities: стоит отметить, что мы создали его экземпляр
используя оператор using, чтобы ApplicationDbContext автоматически удалялся в
конец метода испытаний.

Начиная с C# 8, оператор using можно использовать без указания явной области действия, таким образом
что позволяет использовать более удобный синтаксис, как мы это сделали в приведенном выше коде. Для дополнительной информации
О такой удобной функции читайте в официальной документации по следующему URL:

После создания этот контекст можно заполнить путем создания новых городов, что мы и сделали в предыдущем коде, создав TestCity1 с некоторыми случайными данными. Это позволит нашему методу GetCity()
CitiesController для фактического получения чего-либо при условии, что мы передаем идентификатор города.
Помимо этого, мы создали экземпляр CitiesController, используя контекст в памяти, и определили два объекта City, которые будут содержать два образца для этого теста.

# Act
Фаза действия — это этап тестирования. Часто он состоит из одной инструкции, соответствующей
к поведению устройства, которое мы хотим проверить.
Вот реализация этапа действия:

```Csharp
// Act
city_existing = (await controller.GetCity(1)).Value;
city_notExisting = (await controller.GetCity(2)).Value;
```
Приведенный выше код вполне понятен. Мы используем ранее созданный экземпляр контроллера для
выполните метод GetCity() два раза:
- Первый случай — получить существующий город (используя тот же идентификатор, который мы использовали для заполнения
наша база данных в памяти)
- Второй случай — получить несуществующий город (с использованием другого идентификатора).
Два возвращаемых значения затем сохраняются в переменных city_existing и city_notExisting. В идеале первый должен содержать TestCity1, который мы создали на этапе Arrange, а второй
должно быть нулевым.


# Assert
Целью этапа подтверждения является проверка того, что ожидаемые условия должным образом выполняются
значения, полученные на этапе действия. Для этого мы воспользуемся классом Assert, предоставляемым xUnit.
который содержит различные статические методы, которые можно использовать для проверки выполнения этих условий.
Вот реализация фазы Assert:

```Csharp
Assert.NotNull(city_existing);
Assert.Null(city_notExisting);
```
Как мы видим, мы просто проверяем значения двух переменных, которые содержат возвращаемые значения
два вызова метода GetCity() CitiesController, выполненные на этапе действия. Мы разумно ожидаем
city_existing не должен быть нулевым, а city_notExisting обязательно должен быть нулевым.
Наш тест готов, давайте посмотрим, как его выполнить.

# Выполнение теста
Каждый модульный тест может быть выполнен двумя способами:
- Из командной строки с помощью .NET CLI.
- Из графического пользовательского интерфейса Visual Studio с помощью встроенного средства запуска тестов Visual Studio (Test Explorer).
Давайте быстро попробуем оба этих подхода.

# Использование интерфейса командной строки
Чтобы выполнить наши тестовые модули с помощью .NET CLI, выполните следующие шаги:
1. Откройте командную строку.
2. Перейдите в корневую папку проекта WorldCitiesAPI.Tests.
3. Выполните следующую команду:

```
> dotnet test
```

Если мы все сделали правильно, то должны увидеть что-то вроде этого:

![image](https://github.com/artemovsergey/Angular/assets/26972859/5fc081ce-062e-4087-8498-aa63ed90e1ba)

Вот и все. Наш тест работает и проходит успешно. Это означает, что метод GetCity() класса CitiesController
ведет себя так, как ожидалось.

# Использование обозревателя тестов Visual Studio
Возможность запускать наши тесты из командной строки может быть отличной функцией, если мы хотим их автоматизировать.
виды задач. Однако в большинстве случаев вместо этого мы хотим иметь возможность запускать эти тесты непосредственно из
в графическом интерфейсе Visual Studio.
К счастью, это определенно возможно благодаря окну Test Explorer, которое можно активировать.
нажав Ctrl + E, T или из Меню | Вид, как показано на следующем скриншоте:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c7d67a79-9362-4965-b564-ab8f66e69cdd)

После активации должно появиться окно обозревателя тестов, либо открепленное в середине экрана.
или в самой правой части графического интерфейса Visual Studio, чуть ниже окна обозревателя решений. Оттуда,
мы можем запустить все тесты или только текущий тест, нажав первые два зеленых значка воспроизведения, расположенных в
верхняя левая часть панели, называемая «Выполнить все» и «Выполнить» соответственно (см. следующий снимок экрана):

![image](https://github.com/artemovsergey/Angular/assets/26972859/8193f293-8fd0-42e2-94b4-495e3660bc5e)

Поскольку у нас есть только один тест, на данный момент любая команда будет делать одно и то же: запускать модульный тест.
и покажите результаты, используя либо зеленую галочку (успех), либо красный крест (неудача).

Как мы видим на предыдущем снимке экрана, эти зеленые и/или красные значки будут использоваться для определения объединенных результатов тестирования класса, пространства имен и всей сборки.

Прежде чем двигаться дальше, нам следует потратить еще пару минут на изучение того, как отлаживать этот модуль.
тесты.

# Отладка тестов
Если мы щелкнем стрелку рядом со вторым значком «Выполнить» в верхней левой части обозревателя тестов,
В окне мы видим, что существует ряд других возможных команд, которые мы можем дать нашим тестам,
включая «Отладку», «Отладку всех тестов в представлении» и «Отладку последнего запуска» (см. следующий снимок экрана):

![image](https://github.com/artemovsergey/Angular/assets/26972859/214cfccb-552e-429b-8588-2cf91415b41a)

В качестве альтернативы мы можем использовать команду «Отладка тестов», которая отображается, когда мы щелкаем правой кнопкой мыши по
Узел проекта WorldCitiesAPI.Tests из окна Solution Explorer:

![image](https://github.com/artemovsergey/Angular/assets/26972859/57cd043d-d8f7-49bb-b487-38f49c5a795e)

Обе команды выполнят наш тест в режиме отладки, а это означает, что мы можем установить точки останова (или условные точки останова) и оценить результаты.
Чтобы быстро протестировать его, установите точку останова в первой строке региона Assert, затем выполните предыдущую команду.
Команда Debug Tests и дождитесь попадания:

![image](https://github.com/artemovsergey/Angular/assets/26972859/d7ebd7c7-9048-4655-89c4-e0138a062001)

Вот и все. Теперь мы знаем, как отлаживать наши модульные тесты. Это может быть очень полезно во время принятия
этапе, когда мы еще не знаем, как их правильно использовать, и/или мы все еще изучаем различные xUnit.
сетевые команды.

Прежде чем переходить на фронтенд, стоит потратить пару минут на ознакомление.
с концепциями TDD и BDD, поскольку это может очень помочь нам в создании полезных
и соответствующие тесты.

# Разработка через тестирование
TDD — это скорее практика программирования, чем подход к тестированию, и это может быть очень хорошей практикой.
по крайней мере, для определенных сценариев.
Короче говоря, разработчик программного обеспечения, который применяет методологию TDD, преобразует все программное обеспечение
требования в конкретные тестовые примеры, а затем написать новый код или улучшить существующий код, чтобы
что тесты пройдут.
Давайте попробуем визуализировать реальный жизненный цикл этих практик программирования с помощью небольшого
диаграмма:

![image](https://github.com/artemovsergey/Angular/assets/26972859/47bce9cf-cd98-4383-b2f7-0950555e8d24)

Как мы видим, TDD — это в основном способ разработки кода, который требует от разработчиков начать писать тесты.
случаи, которые выражают то, что они собираются делать с помощью кода, прежде чем писать какой-либо реальный код (RED). Когда-то сделали,
он просит их написать только код, необходимый для прохождения тестовых случаев (ЗЕЛЕНЫЙ).

В конце концов, когда все тестовые примеры пройдены, существующий код можно улучшить (REFACTOR), пока не появится больше
появляются тестовые случаи. Этот короткий цикл разработки условно называется RED-GREEN-REFACTOR и представляет собой
основа практики TDD. Стоит отметить, что RED всегда является начальным шагом любого цикла, поскольку
тесты всегда будут провалены в начале, потому что код, который мог бы позволить им пройти, еще не написан.
Такая практика сильно отличается от практики STD, где мы сначала генерируем код, а затем
(возможно) тесты. Другими словами, наш исходный код может быть (и поэтому обычно так и бывает) написан до (или
даже без) тестовых случаев. Основное различие между этими двумя подходами заключается в том, что в TDD тесты
условия требований, которые нам необходимо выполнить, находясь в STD, как мы уже недавно говорили
назад они в основном являются доказательством того, что наш существующий код работает.
В следующей главе, когда мы будем иметь дело с аутентификацией и авторизацией, мы попробуем создать пару
серверных модульных тестов с использованием подхода TDD; в конце концов, поскольку практика TDD требует создания
тестовых случаев только тогда, когда нам нужно реализовать дополнительные требования, лучший способ использовать это, когда
у нас есть некоторые новые функции, которые можно добавить.

# Развитие, основанное на поведении
BDD — это гибкий процесс разработки программного обеспечения, который использует тот же подход «сначала тестирование», что и TDD, но
подчеркивает результаты с точки зрения конечного пользователя, а не сосредотачивается на реализации.
Чтобы лучше понять ключевые различия между TDD и BDD, мы можем задать себе следующие вопросы.
вопрос:
Что мы тестируем?
Это отличный вопрос, который стоит задать, когда мы собираемся писать модульные тесты.
Если мы хотим протестировать фактическую реализацию наших методов/модулей, TDD может быть подходящим способом.
идти. Однако, если мы стремимся выяснить поведение конечного пользователя нашего приложения при определенных обстоятельствах, TDD может дать нам ложные срабатывания, особенно если система развивается (по мере развития Agile-ориентированных проектов).
часто так делаю). Точнее, мы можем столкнуться со сценарием, когда один или несколько юнитов передают свои
тесты, несмотря на то, что они не смогли обеспечить ожидаемый результат для конечного пользователя.
В более общих чертах можно сказать следующее:
- TDD предназначен для обеспечения контроля разработчиков над исходным кодом, который они пишут.
- BDD стремится удовлетворить как разработчика, так и конечного пользователя (или заказчика).
Таким образом, мы можем легко увидеть, как BDD заменяет TDD, а не заменяет его.

Попробуем обобщить эти понятия в виде схемы:

![image](https://github.com/artemovsergey/Angular/assets/26972859/37a959c3-8539-44f0-8c63-d227ac59f1a4)

Как мы видим, BDD действует как расширение TDD. Вместо написания тестовых примеров мы начнем с
написание поведения. Как только мы это сделаем, мы разработаем необходимый код для нашего приложения.
способен выполнить это (возможно, используя TDD), а затем перейти к определению дополнительного поведения или рефакторингу.
существующие.
Поскольку эти поведения ориентированы на конечного пользователя, их также необходимо писать с использованием понятных
условия. Именно по этой причине BDD-тесты обычно определяются с использованием полуформального формата, заимствованного
из пользовательских историй Agile, с сильным повествованием и явной контекстуализацией. Эти пользовательские истории
обычно подразумевается соответствие следующей структуре:
- Название: явное название, например «Редактирование существующего города».
- Повествование: описательный раздел, в котором используется шаблон «Роль/Функция/Преимущество» от Agile-пользователя.
истории, например «Как пользователь, я хочу редактировать существующий город, чтобы иметь возможность изменить его значения».
- Критерии приемки: описание трех этапов тестирования с использованием модели «Дано/Когда/Тогда»,
что по сути является более понятной версией цикла Arrange/Act/Assert, используемого в TDD,
например, Учитывая базу данных городов мира, содержащую один или несколько городов; Когда пользователь выбирает город;
Затем приложение должно получить его из БД и отобразить во внешнем интерфейсе.
Как мы видим, мы только что попытались описать модульный тест, который создали некоторое время назад, используя типичный подход BDD. Хотя в основном это работает, очевидно, что для одного поведения может потребоваться несколько серверных программ.
и фронтенд-юнит-тесты. Это позволяет нам понять еще одну особенность практики BDD. Подчеркивание первостепенной важности этапа внешнего тестирования — лучший способ протестировать поведение пользователей.
а не спецификация реализации.

В целом, BDD может стать отличным способом расширить стандартный подход TDD для разработки наших тестов таким образом, чтобы
означает, что их результаты могут быть адресованы более широкой аудитории — при условии, что мы сможем правильно спроектировать не только
необходимый внутренний тест (с использованием ASP.NET Core), а также внешние тесты (с использованием Angular).
В этом разделе мы узнали, как работать с внутренней частью истории; в следующем разделе мы
собираемся расширить наши знания до фронтенда.

# Angular модульные тесты
К счастью, на этот раз нам не нужно ничего устанавливать, поскольку ASP.NET Core и Angular
Шаблон Visual Studio, который мы использовали для создания проекта WorldCities, уже содержит все
нам нужно написать тесты для нашего приложения Angular.
Более конкретно, мы уже можем рассчитывать на следующие пакеты, которые мы кратко представили в
Глава 3, Оглядываясь вокруг:
- Jasmine: среда тестирования JavaScript, полностью поддерживающая подход BDD, о котором мы говорили ранее
- Karma: инструмент, который позволяет нам запускать браузеры и запускать в них наши тесты Jasmine (и показывать
их результаты) из командной строки
- Protractor: комплексная среда тестирования, которая запускает тесты приложений Angular из
в реальном браузере, взаимодействуя с ним, как если бы это был настоящий пользователь

В следующих разделах мы собираемся сделать следующее:
- Просмотрите файлы конфигурации тестирования, которые все еще присутствуют в нашем приложении WorldCities Angular.
- Представление интерфейса TestBed, одной из наиболее важных концепций тестирования Angular.
- Изучите Жасмин и Карму, чтобы понять, как они на самом деле работают.
- Создайте несколько файлов .spec.ts для тестирования существующих компонентов.
- Установите и настройте несколько тестов для нашего приложения Angular.
Давайте начнем!

# Общие понятия
В отличие от того, что мы делали в ASP.NET Core, где мы создавали модульные тесты в отдельном WorldCitiesAPI.
Проекты тестов, все наши интерфейсные тесты будут написаны в том же проекте, в котором размещено наше приложение Angular.

На самом деле, мы уже видели один из таких тестов в главе 3 «Осмотр вокруг», когда изучали
папка /src/app/ Angular нашего приложения HealthCheck впервые. Тест был написан на
app.comComponent.spec.ts, и мы поигрались с ним непосредственно перед рефакторингом этого компонента.
Теперь мы перешли на приложение WorldCities, однако у нас все еще должны быть следующие тестовые данные:
файлы в нашем проекте Angular:
- /karma.conf.js: файл конфигурации Karma для конкретного приложения, содержащий информацию о репортерах, используемом браузере, TCP-порте и т. д.
- /src/test.ts: точка входа Angular для модульного теста проекта; здесь Angular инициализирует среду тестирования, настраивает расширения .spec.ts для идентификации тестовых файлов,
и загружает необходимые модули из пакетов @angular/core/testing и @angular/platformbrowser-dynamic/testing.
Поскольку мы создали все наши компоненты с помощью команды nggenerate Angular CLI с
--skip-tests, в нашем проекте Angular должен быть только один файл .spec.ts: файл app.
файл компонент.spec.ts. Это означает, что если мы хотим создать тесты для наших компонентов, нам нужно
чтобы создать их вручную.
Однако, прежде чем сделать это, было бы разумно потратить немного больше времени на объяснение того, как тестирование Angular
на самом деле работает.

# Знакомство с интерфейсом TestBed
Интерфейс TestBed — одна из наиболее важных концепций подхода тестирования Angular. В
Короче говоря, TestBed — это динамически создаваемый тестовый модуль Angular, который имитирует поведение
Угловой @NgModule.
Концепция TestBed была впервые представлена в Angular 2 как удобный способ тестирования компонента с помощью
за этим стоит настоящий ДОМ. Интерфейс TestBed существенно помогает в этом отношении благодаря своей поддержке.
для внедрения сервисов (реальных или фиктивных) в наши компоненты, а также автоматического связывания
компоненты и шаблоны.
Чтобы лучше понять, как на самом деле работает TestBed и как мы можем его использовать, давайте взглянем на TestBed.
реализация файла app.comComponent.spec.ts, который мы модифицировали еще в главе 3 «Обзор»:

```ts
await TestBed.configureTestingModule({
 imports: [
 HttpClientTestingModule
 ],
 declarations: [
 AppComponent
 ],
}).compileComponents();
```

В предыдущем коде мы видим, как TestBed воспроизводит поведение минималистичного AppModule.
файл — загрузочный файл @NgModule приложения Angular — с единственной целью — скомпилировать компоненты.
что нам нужно протестировать: точнее, он использует систему модулей Angular для объявления и компиляции
AppComponent, чтобы мы могли использовать его исходный код в наших тестах.

# Тестирование с Жасмин
Тесты Jasmine обычно создаются с использованием следующих трех основных API:
- describe():: контекст-оболочка, используемый для создания группы тестов (также называемой набором тестов).
- it(): объявление одного теста
- expect():: ожидаемый результат теста.
Эти API уже доступны в файлах *.spec.ts, созданных Angular CLI, спасибо.
к встроенной интеграции Angular с платформой тестирования Jasmine: если мы быстро проверим наше приложение.
компонент.spec.ts, мы можем легко это подтвердить.
Имея это в виду, давайте создадим наш первый файл класса тестирования для нашего приложения Angular.

# Наш первый набор тестов Angular
Давайте теперь создадим наш собственный набор тестов и соответствующий TestBed для одного из наших существующих Angular.
компоненты. Мы будем использовать CitiesComponent, так как мы его очень хорошо знаем.

К сожалению, Angular CLI (пока) не предоставляет возможности автоматического создания
файлы spec.ts для существующих классов компонентов. Однако существует ряд сторонних
библиотеки, которые генерируют спецификации на основе предустановок спецификаций Angular CLI.
Самый популярный (и широко используемый) пакет, который делает это, называется ngx-spec и называется
доступен на GitHub по следующему URL-адресу: https://github.com/smnbbrv/ngx-spec.
Однако мы не собираемся использовать его в нашем конкретном сценарии: создадим и реализуем свой
spec.ts вручную, чтобы мы могли лучше понять, как они работают.

В обозревателе решений создайте новый файл /src/app/cities/cities.comComponent.spec.ts и откройте его.
Поскольку мы собираемся написать достаточно много исходного кода, было бы разумно разделить его на несколько
блоки.

Раздел импорта
Начнем с определения необходимых операторов импорта:

```ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AngularMaterialModule } from '../angular-material.module';
import { RouterTestingModule } from '@angular/router/testing';
import { of } from 'rxjs';
import { CitiesComponent } from './cities.component';
import { City } from './city';
import { CityService } from './city.service';
import { ApiResult } from '../base.service';
```
Как мы видим, мы добавили несколько модулей, которые уже использовали в наших AppModule и CitiesComponent.
занятия. Это, безусловно, ожидаемо, поскольку нашему TestBed необходимо будет воспроизвести подходящий @NgModule.
для запуска наших тестов.

# Разделы describe и beforeEach
Теперь, когда у нас есть все необходимые ссылки, давайте посмотрим, как мы можем использовать API  describe() для
выложим наш набор тестов:

```ts
describe('CitiesComponent', () => {
 let component: CitiesComponent;
 let fixture: ComponentFixture<CitiesComponent>;
 beforeEach(async () => {
 // TODO: declare & initialize required providers
 await TestBed.configureTestingModule({
 declarations: [CitiesComponent],
 imports: [
 BrowserAnimationsModule,
 AngularMaterialModule,
 RouterTestingModule
 ],
 providers: [
 // TODO: reference required providers
 ]
 })
 .compileComponents();
 });
beforeEach(() => {
 fixture = TestBed.createComponent(CitiesComponent);
 component = fixture.componentInstance;
 // TODO: configure fixture/component/children/etc.
 fixture.detectChanges();
 });
 it('should create', () => {
 expect(component).toBeTruthy();
 });
 // TODO: implement some other tests
});
```

Как мы видим, взглянув на предыдущий код, все происходит в пределах одного метода описания().
контекст упаковки, который представляет наш набор тестов CitiesComponent. Все тесты, связанные с нашим
Класс CitiesComponent будет реализован внутри этого пакета.

Стоит отметить, что приведенный выше исходный код города.компонент.спец.тс практически идентичен коду, сгенерированному Angular CLI при запуске компонента nggenerate.
без использования опции --skip-tests: такой шаблон — отличный способ
начать писать тесты, так как они уже содержат TestBed, ссылки на компоненты и
базовый образец теста.

Первое, что мы сделали в наборе тестов, — это определили две важные переменные, которые будут играть решающую роль.
роль во всех тестах:
- fixment: это свойство содержит фиксированное состояние CitiesComponent для запуска тестов; мы можем использовать
это приспособление для взаимодействия с экземпляром компонента и его дочерними элементами
- компонент: это свойство содержит экземпляр CitiesComponent, созданный на основе предыдущего
приспособление
Сразу после этого у нас есть два последовательных вызова метода beforeEach():
- Асинхронный вызов beforeEach(), в котором создается и инициализируется TestBed.
- Синхронный метод beforeEach(), в котором создаются и настраиваются приспособления и компоненты.

Внутри первого (асинхронного) метода beforeEach() мы определили TestBed для нашего компонента CitiesComponent.
который импортирует необходимые модули для тестов, которые мы хотим добавить: BrowserAnimationModule,
AngularMaterialModule и RouterTestingModule. Как мы видим из двух комментариев к задаче
мы разместили здесь, это также место, где мы собираемся объявить, инициализировать и ссылаться на наши
провайдеры (такие как CityService), иначе CitiesComponent не сможет их внедрить; хорошо делать
это через короткое время.
Внутри второго (синхронного) метода beforeEach() мы создали экземпляр нашего прибора и компонента.
переменные. Поскольку нам, скорее всего, придется их правильно настроить и/или настроить некоторые из наших компонентов.
дочерних элементов, мы также оставили там третий комментарий к задаче.
В конце файла мы можем найти наш первый тест, который, по сути, проверяет, что компонент был
создан без ошибок: такой тест имитирует тест «по умолчанию», созданный Angular CLI при использовании
команда nggenerateComponent без опции --skip-tests.
За первым тестом следует четвертый комментарий к задаче: здесь мы сможем реализовать наши дополнительные
тесты с использованием API-интерфейсов it() и ожидаемого(), предоставляемых платформой Jasmine.

# Добавление макета CityService
Теперь мы заменим наши первую и вторую задачи, реализовав макет CityService, чтобы
мы можем сослаться на него в нашем TestBed.

Как мы уже знаем из серверного тестирования с использованием .NET и xUnit, mock — это замена
объект, имитирующий поведение реального.

Как и ASP.NET Core и xUnit, Jasmine предоставляет несколько способов настройки фиктивных объектов. В следующих разделах мы кратко рассмотрим некоторые из наиболее часто используемых подходов.

# Поддельный класс обслуживания
Мы можем создать поддельный CityService, который просто возвращает для нашего теста все, что мы хотим. Закончив, мы
может импортировать его в класс .spec.ts и добавить в список поставщиков TestBed, чтобы он вызывался
наш компонент такой же, как настоящий.

# Расширение и переопределение
Вместо создания целого двойного класса мы можем просто расширить реальный сервис, а затем переопределить
методы, необходимые нам для выполнения наших тестов. После этого мы можем настроить экземпляр расширенного
в нашем TestBed, используя функцию useValue @NgModule.

# Экземпляр интерфейса
Вместо создания нового двойного или расширенного класса мы можем просто создать экземпляр интерфейса нашего сервиса:
реализуя только тот метод, который нам нужен для наших тестов. После этого мы можем настроить этот экземпляр в
наш TestBed с использованием функции useValue @NgModule.

# Spy
Этот подход основан на специфической для Jasmine функции, называемой шпионом, которая позволяет нам использовать существующий класс,
функцию или объект и имитировать ее, чтобы мы могли контролировать ее возвращаемые значения. Поскольку настоящий метод не будет
будет выполнен, шпионский метод будет работать так же, как переопределение, без необходимости создания расширенного класса.
Мы можем использовать такую функцию для создания реального экземпляра нашего сервиса и отслеживания метода, который мы хотим
переопределить, а затем настроить этот конкретный экземпляр в нашем TestBed с помощью функции useValue @NgModule.
В качестве альтернативы мы можем использовать статическую функцию jasmine.createSpyObj() для создания фиктивного объекта с помощью
несколько шпионских методов, которые мы затем можем настроить различными способами.

# Реализация макета CityService
Какой маршрут нам следует выбрать? К сожалению, не существует одного лучшего ответа для всех сценариев, поскольку
лучший подход часто зависит от сложности функций, которые мы хотим протестировать, и/или от того, как мы хотим.
структурировать наш набор тестов.
Теоретически создание целого фальшивого класса обслуживания, возможно, является самым безопасным и универсальным способом.
выбор, поскольку мы можем полностью настроить возвращаемые значения нашего ложного сервиса. Однако это также может занять много времени и зачастую ненужно, когда мы имеем дело с простыми сервисами и/или мелкомасштабными тестами. И наоборот, подходы расширения и переопределения, интерфейса и шпионажа часто являются отличным способом решения проблемы.
базовые требования большинства тестов, однако они могут давать неожиданные результаты в сложных сценариях тестирования,
если мы не уделяем пристальное внимание переопределению/отслеживанию всех необходимых методов.
Все учтено, поскольку наш CityService довольно мал и имеет простую реализацию.
с небольшим количеством методов мы собираемся использовать шпионский подход, который кажется наиболее подходящим
для нашего данного сценария.
Вернемся к файлу /src/cities/cities.comComponents.spec.ts. Оказавшись там, следующая строка
код необходимо заменить:

```ts
// TODO: declare & initialize required providers
```
Предыдущую строку кода необходимо заменить следующим кодом:

```ts
// Create a mock cityService object with a mock 'getData' method
let cityService = jasmine.createSpyObj<CityService>('CityService',
['getData']);
// Configure the 'getData' spy method
cityService.getData.and.returnValue(
 // return an Observable with some test data
 of<ApiResult<City>>(<ApiResult<City>>{
 data: [
 <City>{
 name: 'TestCity1',
 id: 1, lat: 1, lon: 1,
countryId: 1, countryName: 'TestCountry1'
 },
 <City>{
 name: 'TestCity2',
 id: 2, lat: 1, lon: 1,
 countryId: 1, countryName: 'TestCountry1'
 },
 <City>{
 name: 'TestCity3',
 id: 3, lat: 1, lon: 1,
 countryId: 1, countryName: 'TestCountry1'
 }
 ],
 totalCount: 3,
 pageIndex: 0,
 pageSize: 10
 }));
```
Вот и все. Теперь мы можем добавить наш новый макет CityService в конфигурацию TestBed, заменив
вторая задача:

```ts
// TODO: reference required providers
```
Это заменяется выделенными строками следующего кода:

```ts
await TestBed.configureTestingModule({
 declarations: [CitiesComponent],
 imports: [
 BrowserAnimationsModule,
 AngularMaterialModule,
 RouterTestingModule
 ],
 providers: [
 {
 provide: CityService,
 useValue: cityService
 }
 ]
})
 .compileComponents();
```
Этот макет CityService теперь будет внедрен в CitiesComponent, что позволит нам контролировать
данные, возвращаемые для каждого теста.

# Альтернативная реализация с использованием интерфейсного подхода
Вот как мы могли бы реализовать макет CityService, используя интерфейсный подход:

```ts
// Create a mock cityService object with a mock 'getData' method
 let cityService = <CityService>{
 put: (): Observable<City> => { /* todo */ },
 post: (): Observable<City> => { /* todo */ },
 // todo
 };
```
Как мы видим, реализация интерфейса потребует большого количества дополнительного кода, если мы хотим поддерживать
утверждение типа <CityService>. Вот почему вместо этого мы использовали шпионский подход.

# Настройка fixture и компонента
Пришло время удалить третью задачу из нашего класса /src/cities/cities.comComponents.spec.ts:

```ts
beforeEach(() => {
 fixture = TestBed.createComponent(CitiesComponent);
 component = fixture.componentInstance;
 component.paginator = jasmine.createSpyObj(
 "MatPaginator", ["length", "pageIndex", "pageSize"]
 );
 fixture.detectChanges();
 });
```
Приведенный выше код будет выполнять следующие шаги непосредственно перед каждым тестом:
- Создайте макет объекта MatPaginator.
- Запустить запуск обнаружения изменений в нашем компоненте.

Как мы могли легко догадаться, обнаружение изменений здесь не происходит автоматически: оно должно быть
вызывается вызовом метода обнаружения изменений в нашем приборе. Такой звонок заставит нас
Метод ngOnInit() активируется и заполняет таблицу городами. Поскольку мы тестируем
поведение компонента, это определенно нужно сделать перед запуском наших тестов.

Теперь мы наконец готовы создать наш первый тест.

# Создание теста заголовка
Необходимо заменить последнюю оставшуюся строку задачи в нашем классе /src/cities/cities.comComponents.spec.ts:

```ts
it('should display a "Cities" title', () => {
 let title = fixture.nativeElement
 .querySelector('h1');
 expect(title.textContent).toEqual('Cities');
});
```
Как мы видим, мы наконец-то используем методы Jasmine it() и ожидаемый(). Первый заявляет,
смысл нашего теста, а последний оценивает поведение компонента относительно ожидаемого
и определяет результат теста.
В этом первом тесте мы хотим проверить, что компонент отображает пользователю название города. С тех пор, как мы
зная, что шаблон нашего компонента содержит заголовок внутри HTML-элемента <H1>, мы можем проверить это с помощью
выполнение запроса DOM к fixment.nativeElement, корневому элементу компонента, который содержит
весь отображаемый HTML-контент.
Получив элемент заголовка, мы проверяем его свойство textContent, чтобы убедиться, что это то, что мы ожидаем.
(Города). Именно от этого зависит, пройдет ли тест или нет.

# Создание тестов городов
Прежде чем запускать наш набор тестов, давайте добавим еще один тест.
Снова откройте файл /src/cities/cities.comComponents.spec.ts и добавьте следующие строки прямо под ним.
предыдущий тест:

```ts
it('should contain a table with a list of one or more cities', () => {
 let table = fixture.nativeElement
 .querySelector('table.mat-table');
 let tableRows = table
 .querySelectorAll('tr.mat-row');
expect(tableRows.length).toBeGreaterThan(0);
});
```

На этот раз мы проверяем таблицу, содержащую список городов. Точнее, мы считаем
строк тела таблицы, чтобы гарантировать, что полученное число больше нуля, что означает, что таблица имеет
был заполнен по крайней мере один город. Чтобы выполнить такой подсчет, мы используем классы CSS, которые Angular
По умолчанию материал назначается его компоненту MatTable.
Чтобы лучше это понять, взгляните на следующий скриншот:

![image](https://github.com/artemovsergey/Angular/assets/26972859/f8c19934-72bc-4394-852f-9bfc3aee16e3)

Как мы видим, CSS-класс mat-row применяется только к строкам тела таблицы, а к строкам заголовка таблицы.
есть класс mat-header-row. Поэтому, если тест пройден, это определенно означает, что компонент
создал хотя бы одну строку в таблице.
Само собой разумеется, что использование классов CSS, применяемых сторонним пакетом для определения нашего
тесты не являются хорошей практикой. Мы делаем это только для того, чтобы продемонстрировать, что мы можем сделать с нашим текущим
выполнение. Более безопасный подход к таким тестам на основе DOM, возможно, потребует определения пользовательских
Вместо этого классы CSS и проверка их присутствия.

# Запуск набора тестов
Пришло время запустить наш набор тестов и посмотреть, что у нас получилось.
Для этого выполните следующие действия:
1. Откройте командную строку.
2. Перейдите в корневую папку проекта WorldCities Angular.
3. Выполните следующую команду:

```
ng test
```

Это запустит программу запуска тестов Karma, которая откроет специальный браузер для запуска тестов.
если все сделали правильно, мы должны увидеть следующие результаты:

![image](https://github.com/artemovsergey/Angular/assets/26972859/a39e9d29-1e8b-4512-ad27-f8fec61efe85)

Вот и все; все три теста, разработанные для CitiesComponent, прошли успешно. Чтобы быть на 100% уверенным, что мы это сделали
все правильно, давайте теперь попробуем заставить их потерпеть неудачу.
Снова откройте файл /src/cities/cities.comComponents.spec.ts и измените исходный код теста в
следующим образом (обновленные строки выделены):

```ts
it('should display a "Cities" title', () => {
 let title = fixture.nativeElement
 .querySelector('h1');
 expect(title.textContent).toEqual('Cities!!!');
});
it('should contain a table with a list of one or more cities', () => {
 let table = fixture.nativeElement
 .querySelector('table.mat-table');
let tableRows = table
 .querySelectorAll('tr.mat-row');
 expect(tableRows.length).toBeGreaterThan(3);
});
```
Теперь наш первый тест будет ожидать неправильного значения заголовка, а второй ищет более трех
строк, чего не будет, поскольку наш макет CityService настроен на обслуживание трех из них.
Как только мы сохраним файл, средство запуска тестов Karma должно автоматически перезагрузить страницу тестирования и
покажите обновленные результаты (см. следующий снимок экрана):

![image](https://github.com/artemovsergey/Angular/assets/26972859/e84f1cb3-c666-4876-a5ec-e002e95b118e)

Вот и все. Теперь, как и ожидалось, мы наблюдаем два сбоя. Фреймворк Jasmine также
сообщая нам, что не так, чтобы мы могли оперативно решить проблемы.
Давай сделаем это. Откройте файл /src/cities/cities.comComponents.spec.ts и верните исходный код теста.
вернуть код к тому, как это было раньше:

```ts
it('should display a "Cities" title', () => {
 let title = fixture.nativeElement
 .querySelector('h1');
 expect(title.textContent).toEqual('Cities');
});
it('should contain a table with a list of one or more cities', () => {
 let table = fixture.nativeElement
 .querySelector('table.mat-table');
 let tableRows = table
.querySelectorAll('tr.mat-row');
 expect(tableRows.length).toBeGreaterThan(0);
});
```
Вот и все. Теперь, когда мы протестировали наш набор тестов, мы можем закрыть программу запуска тестов, нажав Ctrl + C на панели задач.
ng в окне тестового терминала, а затем выберите Y (и нажмите Enter), чтобы завершить пакетное задание.
На этом мы завершили наш путь обучения через фронтенд-тестирование.

# Краткое содержание
Эта глава была полностью посвящена концепциям тестирования и модульного тестирования. После краткого введения, в котором мы объяснили значение этих концепций и различные доступные методы тестирования,
мы потратили некоторое драгоценное время на то, чтобы научиться правильно их реализовывать.
Мы начали сосредоточиваться на внутреннем тестировании с помощью инструмента тестирования xUnit.net. Такой подход
потребовало от нас создания нового тестового проекта, в котором мы реализовали наши первые серверные модульные тесты. Пока
работая над этим, мы поняли важность некоторых концепций, связанных с тестированием, таких как макетирование, которые мы
используется для эмуляции поведения нашего класса ApplicationDbContext для предоставления некоторых данных в памяти.
вместо использования нашего источника данных SQL Server.
Подход к бэкэнд-тестированию очень помог нам понять значение TDD и его сходства.
и различия по сравнению с подходом BDD, который представляет собой особую практику внешнего тестирования.
Такое сравнение привело нас к Angular, где мы использовали среду тестирования Jasmine и Karma.
Test Runner для разработки интерфейсных тестов. Здесь у нас появилась возможность научиться хорошему тестированию.
практики, а также другие важные концепции, строго связанные с инфраструктурой Jasmine, такие как TestBed, наборы тестов и шпионы. В конце концов мы успешно увидели наши тесты в действии в нашем приложении WorldCities.
В следующей главе мы попытаемся разработать еще несколько тестов, касающихся тем авторизации и аутентификации. Концепции, которые мы здесь изучили, определенно будут очень полезны, когда вам придется
реализовать рабочие процессы регистрации и входа в систему.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: Модульное тестирование, xUnit, Moq, TDD, BDD,
Mock, Stub, Fixture, Jasmine, Karma, Protractor, Spy, набор тестов, TestBed.


























































