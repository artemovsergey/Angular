# Настройка

Теперь, когда наш проект создан, пришло время быстро осмотреться и попытаться понять часть тяжелой работы, которую проделали шаблоны .NET и Angular SPA, чтобы заставить его работать.
Эй, подожди минутку! Не следует ли нам пропустить все эти тонкости настройки и сразу перейти к кодированию? На самом деле, да, через некоторое время мы обязательно приступим к кодированию.
Однако прежде при этом разумно выделить пару аспектов кода, которые уже были введены в действие что мы заранее будем знать, как эффективно двигаться внутри нашего проекта: где найти серверную часть
и клиентский код, куда поместить новый контент, как изменить параметры инициализации и т. д. Это также будет хорошей возможностью проверить наши базовые знания о среде Visual Studio и
пакеты, которые нам понадобятся.

Именно этим мы и собираемся заняться в этой главе. В частности, основными являются следующие
темы, которые мы собираемся затронуть:

- Обзор решения: общее описание того, с чем нам придется иметь дело.-
- Серверная часть ASP.NET: обзор проекта веб-API ASP.NET Core (HealthCheckAPI):
контроллеры, файлы конфигурации и т. д.
- Интерфейс Angular: обзор проекта Angular (HealthCheck): рабочая область, папка /src/, цикл инициализации Angular и т. д.
- Создание нового внешнего приложения с помощью Angular CLI: установка, создание и тестирование.
- Приступаем к работе: изменение конечных точек веб-API, добавление новых компонентов Angular, реализация базовой системы навигации и маршрутизации и т. д.

# Технические требования

В этой главе будут применяться все предыдущие технические требования, перечисленные в главе 2 «Подготовка» без каких-либо дополнительных ресурсов, библиотек или пакетов.
Файлы кода для этой главы можно найти здесь: https://github.com/PacktPublishing/ASP.NETCore-6-and-Angular/tree/master/Chapter_03/.


# Серверная часть ASP.NET

Внутренний стек ASP.NET содержится в следующих папках:
- Виртуальная папка «Зависимости», которая по сути заменяет старую папку «Ссылки» и содержит все внутренние, внешние и сторонние ссылки, необходимые для сборки и запуска нашего проекта.
Туда же будут помещены все ссылки на пакеты NuGet, которые мы добавим в наш проект.
- Папка /Controllers/, поставляемая с любым приложением ASP.NET на основе MVC, начиная с предыдущего выпуска платформы MVC: такая папка содержит один контроллер —
WeatherForecastController.cs – отвечает за предоставление примера прогноза погоды.
- Файлы корневого уровня — Program.cs и appsettings.json — которые будут определять конфигурацию нашего веб-приложения, включая модули и промежуточное ПО, настройки компиляции и
правила публикации; мы рассмотрим их все через некоторое время.

# Конфигурационные файлы

Начнем с рассмотрения файлов конфигурации корневого уровня и их назначения: Program.cs и appsettings.json. Эти файлы содержат конфигурацию нашего веб-приложения, включая модули
и промежуточное программное обеспечение, а также настройки и правила, специфичные для среды.

Файл WeatherForecast.cs содержит строго типизированный класс, предназначенный для возврата из метода Get.
метод WeatherForecastController: эту модель можно рассматривать как модель представления, поскольку она будет сериализована в JSON с помощью ASP.NET Core Framework. По нашему скромному мнению, авторы шаблонов должны поместил его в папку /ViewModel/ (или что-то в этом роде), а не оставлял на корневом уровне.
В любом случае, давайте пока просто проигнорируем его, поскольку это не файл конфигурации, и сосредоточимся на остальном.

# Program.cs

Файл Program.cs, скорее всего, заинтригует большинство опытных программистов ASP.NET, поскольку мы обычно не видим его в проекте веб-приложения. Впервые представленный в ASP.NET Core 1.0, файл Program.

Основная цель файла cs — создать построитель: фабричный объект, используемый средой выполнения .NET Core для настройки
и создайте интерфейс, в котором будет размещаться наше веб-приложение.
В первых версиях ASP.NET Core (до 2.2) сборщик назывался WebHostBuilder, а хостинг интерфейс был известен как IWebHost; в .NET 3.0 они стали HostBuilder и IHost соответственно,
благодаря введению универсального хоста, более универсального хоста, который может поддерживать другие рабочие нагрузки, такие как
рабочие службы, службы gRPC и службы Windows.

Замечание: Приятно это знать, но что такое хост? В нескольких словах это контекст выполнения
любое приложение ASP.NET Core. В веб-приложении хост должен реализовать IHost.
интерфейс, который предоставляет набор веб-функций и сервисов, которые будут
используется для обработки HTTP-запросов.
Предыдущее утверждение может привести к предположению, что веб-хост и веб-сервер
это одно и то же. Однако очень важно понимать, что это не так, поскольку они
служат совершенно разным целям. Проще говоря, за запуск приложения отвечает хост.
и управление временем жизни, в то время как сервер отвечает за прием HTTP-запросов.
Часть ответственности хоста включает обеспечение того, чтобы службы приложения и
сервер доступен и правильно настроен.
Мы можем думать о хосте как о обертке вокруг сервера: хост настроен на
использовать конкретный сервер, в то время как сервер не знает своего хоста.

В .NET 6 по-прежнему можно использовать подход общего хоста, но рекомендуемым способом настройки веб-приложения является новая модель хостинга, представленная в этой версии, о которой мы кратко упомянули только что.
Новый подход основан на новом классе WebApplicationBuilder со встроенной реализацией
IHostBuilder и IHost: это небольшое, но эффективное улучшение делает общую логику Program.cs
гораздо проще для новых разработчиков понять, не меняя базовый подход на основе хоста.
Если мы откроем файл Program.cs и посмотрим на код, мы увидим, что представляет собой новый минимальный шаблон.
выглядит как:

```Csharp
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/
swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
 app.UseSwagger();
 app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();
```
Как мы легко видим, новый код в основном предназначен для выполнения следующих задач:
• Создайте экземпляр WebApplicationBuilder (строка 1).
• Добавьте некоторые услуги (строки 5–8).
• Используйте конструктор для создания объекта WebApplication (строка 10).
• Настройте приложение с необходимым промежуточным программным обеспечением (строки 13–23).
• Запустите приложение (строка 25).
Интерфейс IHost, о котором мы только что говорили, реализуется объектом WebApplication и
Доступ к нему можно получить через общедоступное свойство Host (app.Host).

Как мы видим, старый подход выглядит намного сложнее новой версии: нам пришлось иметь дело с
с целой кучей вложенных лямбда-выражений, обратите внимание на множество перегрузок, учитывающих конфигурацию, и
самое главное, было огромное количество исходного кода; возможно, слишком много для начальной загрузки
класс, особенно для новичка. Неудивительно, что команда ASP.NET Core приложила все усилия, чтобы упростить
Все это.
Давайте вернемся к этому новому подходу и более подробно рассмотрим, что делает улучшенный файл Program.cs.
после создания экземпляра WebApplication в локальной переменной приложения:

```Csharp
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
 app.UseSwagger();
 app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();
```
Код очень читабелен, поэтому мы легко можем понять, что здесь происходит: первая строка комментария
ясно объясняет это: мы настраиваем конвейер HTTP-запросов, загружая необходимое промежуточное программное обеспечение.
и сервисы, которые будут использоваться нашим веб-приложением.

Оператор if, который регистрирует пару промежуточных программ только в том случае, если приложение запускается в среде разработки: оба этих промежуточных программного обеспечения «разработки» связаны с Swagger, который
это то, о чем мы поговорим через некоторое время.
- Еще один блок промежуточного программного обеспечения, который будет использоваться в любой среде: HttpsRedirection,
который будет обрабатывать перенаправления HTTP-to-HTTPS; Авторизация, которая позволяет получить доступ к некоторым API
запросы должны быть доступны только авторизованным пользователям. Обратите внимание, как эти методы вызываются без
параметры: это всего лишь означает, что их настроек по умолчанию нам более чем достаточно, так что есть
здесь нечего настраивать или переопределять.
- После специфичного для среды и постоянно включенного промежуточного программного обеспечения следует вызов MapControllers.
метод, который добавляет конечные точки, необходимые методам действий контроллера для обработки
входящие HTTP-запросы. Мы подробно поговорим об этом в следующих главах, когда будем
иметь дело с аспектами маршрутизации на стороне сервера. А пока отметим, что метод вызывается без
любые параметры, что означает, что мы не указываем здесь какой-либо собственный маршрут: это означает, что
мы просто используем правила маршрутизации по умолчанию, предусмотренные соглашениями об именах платформы,
по крайней мере на данный момент.
- И последнее, но не менее важное: вызов метода Run, который запускает приложение и блокирует
вызывающий поток до завершения работы IHost.

Замечание. Стоит отметить, что промежуточное ПО и сервисы, добавленные в HTTP-конвейер, будут
обрабатывать входящие запросы в порядке регистрации сверху вниз. Это означает
что HttpsRedirection будет иметь приоритет над авторизацией, которая займет
поместите перед методом MapControllers и т. д. Такое поведение очень важно и может привести к неожиданным результатам, если к нему относиться несерьезно, как показано ниже.
Поток переполнения стека: https://stackoverflow.com/questions/52768852/

Стоит отметить, что файл Program.cs не содержит никаких ссылок на промежуточное программное обеспечение StaticFiles, а это означает, что наш веб-API не сможет обслуживать статические файлы, такие как TXT, CSS, JS, изображения и т. д.
и видео. Это неудивительно, поскольку мы планируем предоставлять все эти файлы из приложения Angular (или через
третья сторона, например сеть доставки контента). Это еще одно большое отличие от однопроектного
подход, при котором нам пришлось бы добавить поддержку статических файлов для обслуживания всех файлов Angular,
пакеты и ресурсы – по крайней мере, на этапе разработки.

# appsettings.json

Файл appsettings.json — это просто замена старого доброго файла Web.config; синтаксис XML
был заменен более читаемым и значительно менее подробным форматом JSON. Более того,
новая модель конфигурации основана на настройках «ключ-значение», которые можно получить из широкого спектра
источников, включая, помимо прочего, файлы JSON, используя централизованный интерфейс.
После получения к ним можно легко получить доступ в нашем коде, используя внедрение зависимостей через литерал.
строки (с использованием интерфейса IConfiguration).

Это можно продемонстрировать, открыв файл WeatherForecastController.cs и изменив
конструктор следующим образом (новые/обновленные строки выделены):

```Csharp
public WeatherForecastController(
 ILogger<WeatherForecastController> logger,
 IConfiguration configuration
 )
{
 _logger = logger;
 var defaultLogLevel = configuration["Logging:LogLevel:Default"];
}
```
Если мы поместим точку останова в конце конструктора и запустим наш проект в режиме отладки, мы сможем
проверьте, что переменная defaultLogLevel будет содержать строку «Информация», что именно
значение, указанное в файле appsettings.json.

Замечание: Те, кто не любит иметь дело со строковыми литералами для доступа к файлам конфигурации, могут воспользоваться
возможность определить собственный класс POCO, который будет внутренне читать значения IConfiguration
и вернуть их как именованные свойства: однако, поскольку нам не понадобится доступ к этим значениям
часто, ради простоты, мы будем избегать реализации таких строго типизированных
логику и просто используйте буквальный подход, показанный выше.

# appsettings.Development.json

Стоит отметить, что существует также файл appsettings.Development.json, вложенный ниже основного.
Такой файл служит той же цели, что и старый файл Web.Debug.config, который широко использовался во времена
период ASP.NET 4.x. Короче говоря, эти дополнительные файлы можно использовать для указания дополнительных пар конфигураций ключ/значение (и/или переопределения существующих) для конкретных сред.
Чтобы лучше понять концепцию, давайте немного изменим поведение ведения журнала по умолчанию.
среды разработки.
Откройте файл appsettings.Development.json и обновите следующие строки:

```json
{
 "Logging": {
 "LogLevel": {
 "Default": "Debug",
 "Microsoft.AspNetCore": "Warning"
 }
 }
}
```
После внесения этого изменения каждый раз, когда наш проект веб-API запускается в среде разработки, для уровня журнала по умолчанию будет установлено значение «Отладка», а не «Информация», которое по-прежнему будет значением по умолчанию.
уровень журнала для других сред – пока мы не создадим другие настройки приложения.<EnvironmentName>.json
файлы, чтобы переопределить его.

Предполагая, что здесь мы все поняли, перейдем к основным игрокам любого ядра ASP.NET.
проект: Контроллеры.

# Контроллеры

Контроллеры являются основой большинства приложений ASP.NET Core, поскольку они имеют право обрабатывать
входящие HTTP-запросы. Более конкретно, контроллер используется для определения набора действий (или действий).
методы), которые по сути представляют собой методы, вызываемые промежуточным программным обеспечением маршрутизации для обработки
запросы, сопоставленные с ними посредством правил маршрутизации.
Контроллеры логически группируют схожие действия: такие механизмы агрегирования позволяют разработчикам
удобно определять общие наборы правил не только для маршрутизации, но и для кэширования, авторизации,
и другие настройки, коллективное применение которых может принести пользу.

В типичном проекте ASP.NET MVC контроллеры в основном используются для предоставления представлений клиенту, который
содержит статический или динамический HTML-контент. Это не относится к проектам веб-API, где их основной
Целью является предоставление вывода JSON (REST API), ответов на основе XML (веб-службы SOAP), статических или
динамически создаваемый ресурс (файлы JPG, JS и CSS) или даже простой HTTP-ответ (например,
перенаправление HTTP 301) без тела содержимого.
В типичном проекте ASP.NET MVC все контроллеры наследуются от класса Controller, что добавляет
поддержка просмотров; в проектах веб-API, поскольку им не нужно обслуживать представления, лучше их иметь
вместо этого расширите класс ControllerBase, который является более легким.

Замечание: Этому подходу также соответствует шаблон проекта ASP.NET Core Web API, который мы используем:
если мы посмотрим на исходный код WeatherForecastController, мы увидим, что он является производным
из класса ControllerBase.

Единственным исключением из этой хорошей практики является случай, когда мы планируем использовать один и тот же контроллер для обслуживания обоих
представления и веб-API: в этом случае получение их от контроллера является наиболее логичным и удобным выбором.

# Контроллер прогноза погоды

Признавая все это, мы уже можем сделать вывод, что единственный образец WeatherForecastController
Содержащийся в папке /Controllers/ предназначен для предоставления набора веб-API, которые будут использоваться
Угловой фронтенд. Чтобы быстро это проверить, нажмите F5, чтобы запустить наши проекты в режиме отладки и выполнить
маршрут по умолчанию, введя следующий URL-адрес: https://localhost:40443/weatherforecast.
Если мы помним, что делали в предыдущих главах, мы уже знаем, что это конечная точка URL.
для локального веб-сервера Kestrel (или IISExpress), на котором размещаются проекты веб-API.

Замечание: Фактический номер порта может отличаться в зависимости от URL-адреса прокси-сервера SPA, назначенного
Visual Studio и хранится в файлах конфигурации проекта. Если вы хотите использовать разные
Порты HTTP и/или HTTPS следуйте инструкциям, которые мы предоставили в Главе 2, Получение
Готовый.

При этом будет выполнен метод Get(), определенный в файле WeatherForecastController.cs. Как мы можем видеть
посмотрев исходный код, такой метод имеет возвращаемое значение IEnumerable<WeatherForecast>,
это означает, что он вернет несколько объектов типа WeatherForecast.
Если мы скопируем предыдущий URL-адрес в браузер и выполним его, мы должны увидеть массив JSON случайных чисел.
сгенерированные данные, как показано на следующем снимке экрана:

# Представляем OpenAPI (Swagger)

Прежде чем перейти к проекту внешнего интерфейса Angular, нам следует ознакомиться с еще одной внутренней функцией: OpenAPI, ранее известный как Swagger.
Те, кто имеет некоторый опыт работы с веб-сервисами, наверняка уже слышали такое имя: в очень
Короче говоря, спецификация OpenAPI (OAS) — это независимая от языка спецификация для документирования и
описать REST API. Его основная роль — позволить компьютерам, как и людям, однозначно понимать
возможности REST API без прямого доступа к исходному коду.

Добавление поддержки OpenAPI в проект веб-службы RESTful предоставит некоторые важные преимущества, такие как:
- Минимизация объема работы, необходимой для подключения развязанных услуг.
- Сокращение времени, необходимого для точного документирования услуги.
Если мы примем во внимание, насколько важными стали эти аспекты за последние несколько лет, мы легко сможем понять, насколько важными стали эти аспекты за последние несколько лет.
почему OpenAPI может быть включен по умолчанию в большинство шаблонов API Visual Studio: тот, который мы использовали
Создание нашего проекта HealthCheckAPI не является исключением, как мы видели в главе 2 «Подготовка», и
в начале этой главы, когда мы рассматривали промежуточное программное обеспечение, включенное в файл Program.cs.
Точнее, реализация OpenAPI по умолчанию, добавленная нашим шаблоном, называется Swashbuckle.
и доступен в пакете NuGet Swashbuckle.AspNetCore. Однако, поскольку мы проверили
Включите поддержку OpenAPI, когда мы создавали наш проект еще в главе 2 «Подготовка», нам не нужно
чтобы добавить его явно: он уже включен в наш проект.
Чтобы проверить, установлен ли пакет NuGet Swashbuckle.AspNetCore, щелкните правой кнопкой мыши
Узел проекта HealthCheckAPI в обозревателе решений и выберите «Управление пакетами NuGet». Пакет
должно быть четко видно на вкладке «Установлено», как показано на следующем снимке экрана:

Добавление Swashbuckle в наш проект позволяет нам использовать три разных компонента:
- Swashbuckle.AspNetCore.Swagger: промежуточное программное обеспечение, которое можно использовать для предоставления объектов SwaggerDocument в качестве конечных точек JSON.
- Swashbuckle.AspNetCore.SwaggerGen: генератор, создающий объекты SwaggerDocument.
непосредственно из маршрутов, контроллеров и моделей приложения.
- Swashbuckle.AspNetCore.SwaggerUI: пользовательский интерфейс, который использует Swagger JSON для создания
богатый и настраиваемый пользовательский интерфейс для визуального документирования веб-API
Если мы снова посмотрим на существующий исходный код Program.cs, мы увидим, что эти компоненты уже
присутствует в конвейере инициализации нашего приложения: однако SwaggerUI в настоящее время доступен только в нашем
Среда разработки – какой смысл имеет смысл, поскольку мы не знаем, хотим ли мы ее публиковать
(еще). Публичное документирование службы веб-API может быть полезным, если нам нужны сторонние службы.
использовать его, но это может стать серьезным недостатком безопасности, конфиденциальности и/или производительности, если мы хотим сохранить наши
конечные точки (и данные) только для наших глаз.
На самом деле, сохранение SwaggerUI доступным только во время разработки кажется хорошей идеей.
по крайней мере сейчас: давайте воспользуемся этой возможностью, чтобы хорошенько на это взглянуть.
Для этого нажмите F5, чтобы запустить наши проекты в режиме отладки и выполнить конечную точку Swagger UI по умолчанию:
https://localhost:40443/сваггер


Как мы видим, SwaggerEndpoint, который мы настроили в файле Program.cs, упоминается внутри
гиперссылка прямо под основным заголовком. Если мы нажмем на эту гиперссылку, мы сможем увидеть автоматически сгенерированный файл swagger.json, который содержит подробное описание нашего сингла (на данный момент)
Метод действия /WeatherForecast: принятые методы HTTP, входные параметры, типы возвращаемых данных.
различные значения JSON и т. д.
Мы можем легко понять, почему такая функция автоматического документирования может быть бесценным ресурсом.
для других разработчиков серверной части, у которых нет большого опыта работы с базой кода проекта – не
упомянуть любую третью сторону, которая хочет (или нуждается) интегрироваться с нашим веб-API, не имея доступа
к исходному коду.
На данный момент достаточно: мы вернемся к Swagger/OpenAPI в следующих главах, когда добавим
больше контроллеров и методов действий в нашем проекте веб-API.
Теперь, когда мы закончили проверку серверной части ASP.NET Core, мы можем, наконец, перейти к Angular.
фронтенд-проект.

