# Forms and Data Validation

В этой главе мы в основном будем иметь дело с формами, вводом данных и методами проверки. Как мы уже
Знайте, HTML-формы — один из наиболее важных и деликатных аспектов любого бизнес-приложения.
В настоящее время формы используются для выполнения практически любой задачи, связанной с данными, отправленными пользователем, например, для регистрации
или авторизация на сайте, оплата, бронирование номера в отеле, заказ товара, выполнение
получение результатов поиска и многое другое.
Если бы нас попросили определить форму с точки зрения разработчика, мы бы ответили следующим образом:
что форма — это интерфейс на основе пользовательского интерфейса, который позволяет авторизованным пользователям вводить данные, которые будут отправлены на сервер для
обработка. В тот момент, когда мы принимаем это определение, на ум должны прийти два дополнительных соображения:
1. Каждая форма должна обеспечивать удобство ввода данных, позволяющее эффективно направлять наших пользователей.
через ожидаемый рабочий процесс; в противном случае они не смогут использовать его должным образом.
2. Каждая форма, если она передает на сервер потенциально небезопасные данные, может оказать серьезное влияние на безопасность с точки зрения целостности данных, безопасности данных и безопасности системы, если только разработчик не
обладает необходимыми ноу-хау для принятия и реализации соответствующих контрмер.
Эти два соображения дают хорошее представление о том, что мы будем делать в этой главе: мы сделаем все, что в наших силах.
чтобы помочь нашим пользователям отправлять данные наиболее подходящим способом, а также мы научимся проверять
эти входные значения должным образом предотвращать, избегать и/или минимизировать широкий спектр угроз целостности и безопасности. Также важно понимать, что эти два соображения часто переплетаются.
друг с другом; следовательно, мы часто будем иметь дело с ними одновременно.
В этой главе мы рассмотрим следующие темы:
- Изучение форм Angular, где мы будем иметь дело с формами, управляемыми шаблонами, а также с реактивными формами.
Forms, при этом понимая плюсы и минусы обоих подходов и выбирая, какой из них лучше.
наиболее подходит для использования в различных распространенных сценариях
- Создание нашей первой реактивной формы, в которой мы будем использовать полученные знания для создания реактивной формы.
Форма для редактирования существующих городов, а также добавления новых
- Добавление нового города с помощью нашей новой реактивной формы.
- Понимание проверки данных: мы научимся перепроверять входные данные наших пользователей.
как во фронтенде, так и в бэкэнде, а также различные техники визуального
обратная связь, когда они отправляют неправильные или недействительные значения
- Представляем FormBuilder, где мы реализуем еще одну реактивную форму для наших стран.
использование некоторых фабричных методов вместо создания экземпляров различных элементов модели формы вручную.
- Улучшение поведения фильтра: мы представим некоторые методы регулирования и устранения дребезга.
для улучшения общей производительности и снижения нагрузки на сервер
В конце каждой задачи нам также понадобится некоторое время, чтобы проверить результат нашей работы с помощью нашего веб-браузера.

# Изучение форм Angular
Если мы посмотрим на наши текущие проекты .NET Core с Angular, мы увидим, что ни один из них не позволяет
наши пользователи для взаимодействия с данными:
- Для приложения HealthCheck это ожидаемо, поскольку данных для обработки просто нет: это
приложение-монитор, которое ничего не хранит и не требует ввода данных от пользователя
- Однако приложение WorldCities рассказывает совсем другую историю: у нас есть база данных, которую мы используем.
возвращать результаты нашим пользователям, которым — по крайней мере теоретически — может быть разрешено вносить изменения
Само собой разумеется, что приложение WorldCities станет нашим лучшим кандидатом для реализации наших
формы. В следующих разделах мы сделаем именно это, начиная с проекта Angular (интерфейсная часть).
а затем перейдем к проекту веб-API ASP.NET Core (серверная часть).

# Формы в Angular
Давайте на минутку кратко рассмотрим наше приложение WorldCities в том состоянии, в котором мы его оставили в конце главы.
6. Получение и отображение данных. Если мы посмотрим на CitiesComponent и CountriesComponent
шаблонов, мы увидим, что на самом деле у нас уже есть какой-то элемент ввода данных: мы явно
речь идет о <mat-form-field>, который является селектором MatInputModule Angular Material, который
мы добавили в цикл в главе 6 «Извлечение и отображение данных», чтобы наши пользователи могли фильтровать города.
и страны по их названиям.
Вот соответствующий фрагмент кода:

```html
<mat-form-field [hidden]="!cities">
 <input matInput #filter (keyup)="loadData(filter.value)"
 placeholder="Filter by name (or part of it)...">
</mat-form-field>
```
Это означает, что мы уже принимаем какое-то действие пользователя, состоящее из одной входной строки.
– и соответственно реагируя на это: такая цепочка действие + реакция лежит в основе взаимодействия между
пользователь и приложение, а это, по сути, и есть подавляющее большинство форм.
Однако, если мы посмотрим на сгенерированный HTML-код, мы ясно увидим, что у нас нет никакого фактического кода.
Элемент <форма>. Мы можем проверить это, щелкнув правой кнопкой мыши элемент ввода этого представления в окне браузера.
и выберите элемент «Проверить», как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/45653c02-edea-439a-a57f-e65fefa45aeb)

Как мы видим, здесь нет основной формы, есть только одно поле ввода, которое прекрасно справляется с поставленной нами задачей.
назначено ему. Отсутствие формы не пропускается, потому что мы ничего не отправляем, используя
FormData мы выполняем выборку данных с помощью модуля Angular HttpClient, который технически
делает это с помощью асинхронного XMLHttpRequest (XHR) через JavaScript – одним словом, AJAX.
Такой подход не требует элемента контейнера <form> и способен обрабатывать данные.
задачи кодирования и передачи с использованием следующих поддерживаемых методов:
- приложение/x-www-form-urlencoded
- multipart/form-data
- текстовый/обычный
Ему нужны только фактические элементы ввода, чтобы получить необходимые значения от пользователя.

Хотя это и не обязательно, элемент формы или любой HTML-контейнер для наших элементов ввода может быть
очень полезен для ряда важных задач, не относящихся к кодированию и передаче данных
предметы. Давайте разберемся, что они собой представляют и зачем они нам могут понадобиться.

# Причины использовать формы
Попробуем обобщить наиболее явные недостатки нашего нынешнего бесформенного подхода:
- Мы не можем отслеживать глобальное состояние формы, поскольку не можем определить,
введенный текст действителен или нет
- У нас нет простого способа показать пользователям сообщение об ошибке, чтобы они знали, что у них произошло.
сделать, чтобы форма стала действительной
- Мы никак не проверяем входные данные; мы просто собираем и кидаем на сервер без
дважды подумав
В нашем конкретном сценарии это абсолютно нормально, поскольку мы имеем дело только с одной текстовой строкой и
нас не слишком заботит его длина, входной текст и т. д. Однако если нам придется иметь дело с
несколько входных элементов и несколько типов значений, такие ограничения могут серьезно затруднить нашу работу – в
с точки зрения управления потоком данных, проверки данных или пользовательского опыта.
Конечно, мы могли бы легко обойти большинство вышеупомянутых проблем, реализовав некоторые собственные методы в наших компонентах на основе форм; мы могли бы выдать некоторые ошибки, такие как isValid(),
isNumber() и так далее здесь и там, а затем подключите их к синтаксису нашего шаблона и покажите/скройте
сообщения проверки с помощью структурных директив, таких как *ngIf, *ngFor и т.п.
Однако это определенно был бы ужасный способ решения нашей проблемы; мы не выбрали многофункциональный
клиентская среда, такая как Angular, работает таким образом.
К счастью, у нас нет причин это делать, поскольку Angular предоставляет нам несколько альтернатив.
стратегии для решения этих распространенных сценариев, связанных с формами:
- Формы на основе шаблонов
- Формы, управляемые моделью, также известные как реактивные формы.

Оба они тесно связаны с фреймворком и, следовательно, чрезвычайно жизнеспособны; они оба принадлежат
библиотеку @angular/forms, а также имеют общий набор классов управления формой. Однако они также
имеют свои собственные специфические наборы функций, а также свои плюсы и минусы, которые в конечном итоге могут привести
нам, выбирая один из них.
Попробуем кратко обобщить эти различия.
Формы, управляемые шаблонами
Если вы пришли из AngularJS, велика вероятность, что подход, основанный на шаблонах, вызовет у вас сомнения.
звонок или два. Как следует из названия, формы, управляемые шаблонами, содержат большую часть логики кода шаблона;
Работа с формой, управляемой шаблоном, означает:
- Создание формы в файле шаблона .html.
- Привязка данных к различным полям ввода с помощью экземпляра ngModel.
- Использование выделенного объекта ngForm, связанного со всей формой и содержащего все входные данные, с
каждый доступен через свое имя
Эти действия необходимо выполнить для выполнения необходимых проверок достоверности.
Чтобы понять это, вот как выглядит форма, управляемая шаблоном:

```html
<form novalidate autocomplete="off" #form="ngForm"
 (ngSubmit)="onSubmit(form)">

 <input type="text" name="name" value="" required
 placeholder="Insert the city name..."
 [(ngModel)]="city.Name" #title="ngModel"
 />
 <button type="submit" name="btnSubmit"
 [disabled]="form.invalid">
 Submit
 </button>
</form>
```
Как мы видим, мы можем получить доступ к любому элементу, включая саму форму, используя какой-нибудь удобный шаблон.
ссылочные переменные – атрибуты со знаком #, которые мы уже видели в главе 6 «Извлечение и
Отображение данных — и проверка их текущего состояния для создания собственного рабочего процесса проверки. Мы поговорим
подробнее об этих состояниях позже, когда мы углубимся в методы проверки формы.
В двух словах это формы, управляемые шаблонами; теперь, когда мы рассмотрели их в целом, давайте попробуем
обобщить плюсы и минусы этого подхода.

# Плюсы
Вот основные преимущества форм на основе шаблонов:
• Формы на основе шаблонов очень легко писать. Мы можем повторно использовать большую часть наших знаний HTML.
(при условии, что они у нас есть). Кроме того, если мы пришли из AngularJS, мы уже знаем, как
что ж, мы сможем заставить их работать, как только освоим эту технику.
- Их довольно легко читать и понимать, по крайней мере, с точки зрения HTML; у нас есть
простая, понятная структура HTML, содержащая все поля ввода и валидаторы, одно за другим
другой. Каждый элемент будет иметь имя, двустороннюю привязку к базовой модели ngModel и
(возможно) Логика, управляемая шаблонами, построенная на псевдонимах, которые были привязаны к другим элементам.
что мы также можем видеть, или к самой форме.

# Минусы
Вот их слабые стороны:
- Формы на основе шаблонов требуют большого количества HTML-кода, который может быть довольно сложно поддерживать.
и, как правило, более подвержен ошибкам, чем чистый TypeScript.
- По той же причине эти формы не подлежат модульному тестированию. У нас нет возможности протестировать их валидаторы
или чтобы убедиться, что реализованная нами логика будет работать, кроме запуска сквозного теста.
с помощью нашего браузера, который вряд ли идеален для сложных форм.
- Их читаемость быстро упадет по мере того, как мы будем добавлять все больше и больше валидаторов и входных тегов. Хранение
вся их логика внутри шаблона может подойти для небольших форм, но она плохо масштабируется при
работа со сложными элементами данных.
В конечном счете, мы можем сказать, что формы, управляемые шаблонами, могут быть подходящим вариантом, когда нам нужно создавать небольшие
формы с простыми правилами проверки данных, где мы можем получить больше пользы от их простоты. На вершине
что они очень похожи на типичный HTML-код, к которому мы уже привыкли (при условии, что у нас есть
простой фон разработки HTML); нам просто нужно научиться украшать стандартную <форму>
и <input> с псевдонимами и добавлением некоторых валидаторов, обрабатываемых структурными директивами, такими как
как те, которые мы уже видели, и мы (почти) в кратчайшие сроки приступим к делу.

При этом отсутствие модульного тестирования, раздувание HTML-кода, который они в конечном итоге создадут, и
трудности масштабирования в конечном итоге приведут нас к альтернативному подходу для любой нетривиальной формы.

# Модельно-ориентированные/реактивные формы
Модельно-ориентированный подход был специально добавлен в Angular 2+ для устранения известных ограничений
Формы, управляемые шаблонами. Формы, реализуемые с помощью этого альтернативного метода, известны как
Формы, управляемые моделью, или реактивные формы — это одно и то же.

The main difference here is that (almost) nothing happens in the template, which acts as a mere
reference to a more complex TypeScript object that gets defined, instantiated, and configured programmatically within the component class: the form model.
To understand the overall concept, let’s try to rewrite the previous form in a Model-Driven/Reactive
way (the relevant parts are highlighted). The outcome of doing this is as follows:

```html
<form [formGroup]="form" (ngSubmit)="onSubmit()">
 <input formControlName="name" required />
 <button type="submit" name="btnSubmit"
 [disabled]="form.invalid">
 Submit
 </button>
</form>
```
Как мы видим, требуемого объема кода становится все меньше и больше читабельности.
Вот базовая модель формы, которую мы определим в файле класса компонента (соответствующие части
выделены в следующем коде):

```ts
import { FormGroup, FormControl } from '@angular/forms';
class ModelFormComponent implements OnInit {
 form: FormGroup;
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl()
 });
 }
}
```

Попробуем понять, что здесь происходит:
- Свойство form является экземпляром FormGroup и представляет саму форму.
- FormGroup, как следует из названия, представляет собой контейнер элементов управления формой, имеющих одну и ту же цель.
Как мы видим, сама форма действует как FormGroup, а это означает, что мы можем вкладывать FormGroup.
объекты внутри других объектов FormGroup (хотя в нашем примере мы этого не делали).
- Каждый элемент ввода данных в шаблоне формы – в предыдущем коде имя – представлен
экземпляром FormControl.
- Каждый экземпляр FormGroup инкапсулирует состояние каждого дочернего элемента управления.
быть действительным, если/когда все его дочерние элементы также действительны.

Также обратите внимание, что у нас нет возможности прямого доступа к объектам FormControl, как мы это делали в
Формы на основе шаблонов; нам нужно получить их с помощью метода .get() основной группы FormGroup,
что является самой формой.
На первый взгляд шаблон, управляемый моделью, не слишком отличается от шаблона, управляемого шаблоном;
у нас все еще есть элемент <form>, элемент <input>, подключенный к валидатору <span>, и кнопка отправки;
кроме того, проверка состояния входных элементов требует большего объема исходного кода, поскольку
у них нет псевдонимов, которые мы могли бы использовать. В чем же тогда дело?
Чтобы лучше представить разницу, давайте посмотрим на следующие диаграммы. Вот схема, изображающая
как работают формы на основе шаблонов:

![image](https://github.com/artemovsergey/Angular/assets/26972859/ec2dd468-2ade-47e8-9d4f-12d967742398)

Глядя на стрелки, мы легко видим, что в формах, управляемых шаблонами, все происходит в
шаблон; элементы формы HTML напрямую привязаны к компоненту DataModel, представленному
свойство, заполняемое асинхронным HTML-запросом к веб-серверу, подобно тому, как мы это делали с нашим
Таблица городов и стран. Эта DataModel будет обновляться, как только пользователь что-то изменит.
есть, если только валидатор не мешает им это сделать. Если мы подумаем об этом, мы легко сможем понять
что ни одна часть всего рабочего процесса не находится под нашим контролем; Угловой
обрабатывает все самостоятельно, используя информацию в привязках данных, определенных в нашем шаблоне.
Вот что на самом деле означает «Управление шаблонами»: шаблон решает все.

Теперь давайте взглянем на подход, основанный на модельно-ориентированных формах (или реактивных формах):

![image](https://github.com/artemovsergey/Angular/assets/26972859/a670e2b1-40c9-4e76-95f7-579376eb1808)

Как мы видим, стрелки, изображающие рабочий процесс форм, управляемых моделью, рассказывают совсем другую историю.
Они показывают, как данные передаются между компонентом DataModel, который мы получаем от веб-сервера, и моделью формы, ориентированной на пользовательский интерфейс, которая сохраняет состояния и значения формы HTML (и ее
дочерние элементы ввода), которые представляются пользователю. Это означает, что мы сможем встать между
объектами управления данными и формой и выполнять ряд задач непосредственно: извлекать и извлекать данные,
обнаруживать и реагировать на изменения пользователя, реализовывать собственную логику проверки, выполнять модульные тесты и т. д.
Вместо того, чтобы нас заменял шаблон, который не находится под нашим контролем, мы можем отслеживать и влиять на
рабочий процесс программно, поскольку модель формы, вызывающая снимки, также является классом TypeScript; это
что такое модельно-управляемые формы. Это также объясняет, почему их еще называют реактивными формами.
явная ссылка на стиль реактивного программирования, который предпочитает явную обработку и изменение данных.
управление на протяжении всего рабочего процесса.

Хватит теории; пришло время расширить возможности наших компонентов с помощью реактивных форм.

# Создаем нашу первую реактивную форму
В этом разделе мы создадим нашу первую реактивную форму. Точнее, мы собираемся построить
CityEditComponent, который даст нашим пользователям возможность редактировать существующую запись города.
Для этого мы сделаем следующее:
- Добавьте ссылку на ReactiveFormsModule в наш класс AppModule.
- Создайте TypeScript CityEditComponent и файлы шаблонов.
Давайте начнем.

# ReactiveFormsМодуль
Первое, что нам нужно сделать, чтобы начать работать с Reactive Forms, — это добавить ссылку на
ReactiveFormsModule в классе AppModule.
В обозревателе решений откройте файл /src/app/app.module.ts и добавьте следующий оператор импорта сразу после BrowserModule:

```ts
import { ReactiveFormsModule } from '@angular/forms';
```
Как всегда, не забудьте также добавить ReactiveFormsModule в коллекцию импорта @NgModule.
Теперь, когда мы добавили ссылку на ReactiveFormsModule в файл AppModule нашего приложения, мы можем
реализовать компонент Angular, в котором будет размещаться фактическая форма.

# CityEditComponent
Поскольку наш CityEditComponent предназначен для того, чтобы позволить нашим пользователям изменять город, нам нужно сообщить ему об этом.
какой город он должен получить (и отправить) на сервер.
Для этого нам нужно передать идентификатор города из списка городов в этот компонент: самый эффективный способ
для этого можно использовать параметр GET, например идентификатор города, который затем может использоваться компонентом.
чтобы получить информацию о городе с сервера и показать ее пользователю.

Поэтому мы собираемся реализовать стандартный шаблон пользовательского интерфейса «Основной/Детальный», очень похожий на следующий:

![image](https://github.com/artemovsergey/Angular/assets/26972859/dba6b517-bcc6-4e4e-b8ad-fd3126a14901)

Этот шаблон редактирования, помимо того, что он наиболее часто используется в мире при работе со списком элементов,
идеально подходит для нашего сценария. Звучит как план: давайте сделаем это!
Начнем с создания нового CityEditComponent с помощью Angular CLI. Однако на этот раз мы
запустите команду nggenerateComponent в папке /src/app/cities/, так как нам нужен новый
компонент, который будет создан в этой папке – вместе с существующими компонентами CitiesComponents и
Интерфейс City.ts.
Для этого нам также нужно использовать опцию --flat, которая сообщает CLI о необходимости создания новых файлов в
текущая папка вместо создания новой. Вот команда, которую нам нужно выполнить:

```
ng generate component CityEdit --flat --module=app --skip-tests
```
После этого мы можем начать обновление файлов ts, html и scss нового компонента.

# city-edit.component.ts
Откройте три новых (и пустых) файла и заполните их следующим исходным кодом /src/.
Файл app/cities/city-edit.comComponent.ts:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormControl } from '@angular/forms';
import { environment } from './../../environments/environment';
import { City } from './city';
@Component({
 selector: 'app-city-edit',
 templateUrl: './city-edit.component.html',
 styleUrls: ['./city-edit.component.scss']
})
export class CityEditComponent implements OnInit {
 // the view title
 title?: string;
 // the form model
 form!: FormGroup;
 // the city object to edit
 city?: City;
 constructor(
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private http: HttpClient) {
 }
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl(''),
 lat: new FormControl(''),
 lon: new FormControl('')
 });
this.loadData();
 }
 loadData() {
 // retrieve the ID from the 'id' parameter
 var idParam = this.activatedRoute.snapshot.paramMap.get('id');
 var id = idParam ? +idParam : 0;
 // fetch the city from the server
 var url = environment.baseUrl + 'api/Cities/' + id;
 this.http.get<City>(url).subscribe(result => {
 this.city = result;
 this.title = "Edit - " + this.city.name;
 // update the form with the city value
 this.form.patchValue(this.city);
 }, error => console.error(error));
 }
 onSubmit() {
 var city = this.city;
 if (city) {
 city.name = this.form.controls['name'].value;
 city.lat = +this.form.controls['lat'].value;
 city.lon = +this.form.controls['lon'].value;
 var url = environment.baseUrl + 'api/Cities/' + city.id;
 this.http
 .put<City>(url, city)
 .subscribe(result => {
 console.log("City " + city!.id + " has been updated.");
 // go back to cities view
 this.router.navigate(['/cities']);
 }, error => console.error(error));
 }
 }
}
```
Это изрядный объем исходного кода: к счастью, есть много комментариев, которые должны нам помочь.
понять цель каждого соответствующего шага.

ВНИМАНИЕ: приведенное выше может вызвать ошибку компиляции TypeScript, например:
Свойство «имя» происходит из сигнатуры индекса, поэтому к нему необходимо получить доступ.
по имени'].
Это может произойти при использовании старой версии TypeScript, где прямой доступ к свойствам
члены словаря не были разрешены. Это ограничение было смягчено в TypeScript 2.2.
и теперь это можно сделать, получив большие преимущества с точки зрения читаемости кода и эргономики.
Это означает, что вышеуказанную проблему можно решить, либо обновив версию TypeScript, либо
переключение на доступ к свойству обозначения скобок, следуя совету, данному в ошибке
сообщение.
Вся тема резюмируется в следующем ответе на переполнение стека: https://
stackoverflow.com/a/39768162/1233379.
А вот официальное объявление от команды разработчиков TypeScript: https://
devblogs.microsoft.com/typescript/announcing-typescript-2-2/.

Попробуем подвести итог тому, что мы здесь сделали:
- Мы добавили несколько ссылок на импорт модулей, которые собираемся использовать в этом классе. Среди
их, мы можем увидеть пару новых детей в блоке: @angular/router и @angular/form.
Первый необходим для определения некоторых шаблонов внутренней маршрутизации, а второй содержит
Классы FormGroup и FormControl, которые нам нужны для построения нашей формы.
- Прямо под определением класса мы создали экземпляр FormGroup внутри переменной формы: это
наша модель формы.
- Экземпляр переменной формы содержит три объекта FormControl, в которых будут храниться значения города.
мы хотим разрешить нашим пользователям изменять: имя, широту и долготу. Мы не хотим заставлять их меняться
Id или CountryId — по крайней мере, не сейчас.
- Прямо под переменной формы мы определили переменную города, которая будет содержать фактический город, когда
мы извлекаем его из базы данных.
- Задача получения города решается методом loadData(), который очень похож на метод
мы реализовали в файле города.компонент.тс: стандартную задачу получения данных, выполняемую
Модуль HttpClient, который внедряется (как обычно) через конструктор(). Самый актуальный
разница здесь в том, что метод сразу после цикла HTTP-запроса/ответа заранее
загружает полученные данные о городе в модель формы (с помощью метода patchValue() формы)
вместо того, чтобы полагаться на функцию привязки данных Angular: это неудивительно, поскольку мы используем
подход, основанный на модели/реактивном подходе, а не на основе шаблонов.
- В методе onSubmit() происходит волшебство обновления: HttpClient играет важную роль.
здесь также путем отправки запроса PUT на сервер и правильной отправки переменной города. Один раз
подписка Observable обработана, мы используем экземпляр маршрутизатора для перенаправления
пользователь возвращается к CitiesComponent (основное представление).

Прежде чем двигаться дальше, было бы разумно сказать пару слов о
patchValue(), который мы использовали в предыдущем коде.
Пакет @angular/forms дает нам два способа обновления модели реактивной формы:
метод setValue(), который устанавливает новое значение для каждого отдельного элемента управления, и метод
patchValue(), который заменит любые свойства, определенные в
объект, изменившийся в модели формы.
Основное различие между ними заключается в том, что setValue() выполняет строгую проверку источника.
объект и будет выдавать ошибки, если он не полностью соответствует структуре модели (включая
все вложенные элементы FormControl), а patchValue() автоматически выполнит ошибку при этих ошибках.
Следовательно, мы можем сказать, что первый метод может быть лучшим выбором для сложных форм.
и/или всякий раз, когда нам нужно отловить ошибки вложения, тогда как последнее - это путь, когда
все достаточно просто – как в наших текущих образцах.

Пакет @angular/router заслуживает особого упоминания, поскольку мы видим его впервые.
в компонентном файле TypeScript, и раньше мы использовали его только дважды:
- В файле app-routing.module.ts для определения правил маршрутизации на стороне клиента.
- В файле nav.comComponent.html, чтобы реализовать вышеупомянутые правила маршрутизации и сделать
они отображаются в виде навигационных ссылок в главном меню веб-приложения.
На этот раз нам пришлось его импортировать, потому что нам нужен был способ получить параметр City id из файла
URL-адрес. Для этого мы использовали интерфейс ActivatedRoute, который позволяет получать информацию о
текущий активный маршрут, а также искомый параметр GET.

# city-edit.component.html

Вот содержимое файла шаблона /src/app/cities/city-edit.comComponent.html:

```htnl
<div class="city-edit">
 <h1>{{title}}</h1>
 <p *ngIf="!city"><em>Loading…</em></p>
 <div [formGroup]="form" (ngSubmit)="onSubmit()">
 <!-- Name -->
 <mat-form-field>
 <mat-label>Name:</mat-label>
 <input matInput formControlName="name" required
 placeholder="Type a name">
 </mat-form-field>
 <!-- Lat -->
 <mat-form-field>
 <mat-label>Latitude:</mat-label>
<input matInput formControlName="lat" required
 placeholder="Insert latitude">
 </mat-form-field>
 <!-- Lon -->
 <mat-form-field>
 <mat-label>Longitude:</mat-label>
 <input matInput formControlName="lon" required
 placeholder="Insert longitude">
 </mat-form-field>
 <div>
 <button mat-flat-button color="primary"
 type="submit" (click)="onSubmit()">
 Save
 </button>
 <button mat-flat-button color="secondary"
 [routerLink]="['/cities']">
 Cancel
 </button>
 </div>
 </div>
</div>
```
Подождите: где наш HTML-элемент <form>? Разве мы не говорили, что работаем с формами?
подходы, потому что они намного лучше, чем размещение множества отдельных полей <input> тут и там?
На самом деле форма у нас есть: мы просто использовали <div> вместо классического элемента <form>.
Как вы уже могли догадаться, формы в Angular не обязательно должны создаваться с использованием
HTML-элемент <form>, поскольку мы не будем использовать его отличительные особенности. Именно по этой причине мы
могут свободно определять их с помощью <div>, <p> или любого элемента уровня блока HTML, который может разумно
содержат поля <input>.
Однако использование HTML-элемента <form> имеет некоторые преимущества, которые мы могли бы рассмотреть, например:
- Нам не нужно явно привязывать обработчик onSubmit() к событию нажатия кнопки отправки.
поскольку форма будет автоматически отправлена, когда пользователи нажмут на нее
- Если наше приложение включает FormsModule, который необходим для подхода к созданию форм на основе шаблонов.
– Angular автоматически применит директиву NgForm к каждому элементу HTML-шаблона <form>.
- Использование элемента <form> для хранения последовательности элементов <input> сделает наш HTML-код
соответствует стандартам и рекомендациям W3C
По всем этим причинам, возможно, было бы разумно заменить этот элемент <div> элементом <form> в
следующим образом:

```html
<form [formGroup]="form" (ngSubmit)="onSubmit()">
<!-- ...existing code... -->
</form>
```
Такие изменения не являются строго обязательными, но сделают наш HTML-код более читабельным и простым.
для понимания другими разработчиками.
Сразу после этого нам также следует удалить (теперь избыточную) ручную привязку к событию onSubmit().
обработчик, который у нас есть на кнопке отправки:

```html
<button mat-flat-button color="primary"
 type="submit">
 Save
</button>
```
Если мы этого не сделаем, метод onSubmit() будет вызываться дважды, что нам и следует сделать.
определенно избегайте.

# city-edit.component.scss

И последнее, но не менее важное: вот наш контент /src/app/cities/city-edit.comComponent.scss:

```scss
mat-form-field {
 display: block;
 margin: 10px 0;
}
```

Опять же, здесь нет ничего особенного: только минимальное количество стилей для переопределения формы Angular Material.
поведение полей по умолчанию — встроенный блок, который позволяет им располагаться горизонтально — и принудительно размещать их по вертикали.
вместо этого макет с минимальным расстоянием между полями.

# Добавление навигационной ссылки
Теперь, когда наш CityEditComponent готов, нам нужно применить наш шаблон «основной/детальный», добавив
навигационная ссылка, которая позволит нашим пользователям переходить из списка наших городов (основной) в форму редактирования города.
(деталь).
Для этого нам необходимо выполнить следующие задачи:
- Создайте новый маршрут в файле app-routing.module.ts.
- Реализуйте предыдущий маршрут в коде шаблона CitiesComponent.
Как всегда, нам не нужно добавлять ссылки на файл city-edit.comComponent.ts в приложение.
Module.ts, поскольку Angular CLI должен был сделать это автоматически при создании компонента.
Давай сделаем это!

# app-routing.module.ts
Первое, что нужно сделать, это добавить новый маршрут в файл app-routing.module.ts со следующим исходным кодом.
код (новые строки выделены):

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { CitiesComponent } from './cities/cities.component';
import { CityEditComponent } from './cities/city-edit.component';
import { CountriesComponent } from './countries/countries.component';
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'cities', component: CitiesComponent },
 { path: 'city/:id', component: CityEditComponent },
 { path: 'countries', component: CountriesComponent },
];
@NgModule({
 imports: [RouterModule.forRoot(routes)],
 exports: [RouterModule]
})
export class AppRoutingModule { }
```
Как мы видим, мы импортировали CityEditComponent и определили новый город/:id, соответствующий
маршрут. Синтаксис, который мы использовали, будет маршрутизировать любой URL-адрес, состоящий из города и параметра, который будет
зарегистрирован под своим идентификатором.

# cities.component.html

Теперь, когда у нас есть маршрут навигации, нам нужно реализовать его в главном представлении, чтобы
Детальный просмотр может быть достигнут.
Откройте файл /src/app/cities/cities.comComponent.html и измените код HTML-шаблона для
столбец «Название города» следующим образом:

```htnl
<ng-container matColumnDef="name">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
 <td mat-cell *matCellDef="let city">
 <a [routerLink]="['/city', city.id]">{{city.name}}</a>
 </td>
</ng-container>
```
Когда вы закончите, проверьте это, нажав F5 и перейдя к представлению «Города». Как показано ниже
скриншот, названия городов теперь являются кликабельными ссылками:

![image](https://github.com/artemovsergey/Angular/assets/26972859/abc7f45f-e648-4756-b075-89dcf15b1ef7)

Оттуда отфильтруйте таблицу по Парижу и щелкните первый результат, чтобы получить доступ к CityEditComponent.
что мы наконец сможем увидеть (как показано на следующем скриншоте):

![image](https://github.com/artemovsergey/Angular/assets/26972859/193da432-548d-4cb8-b98d-e345974292e1)

Как мы видим, все происходит так, как мы и ожидали. У нас есть три текстовых поля, а также
Кнопка «Сохранить» и кнопка «Отмена», обе готовы к выполнению назначенной им задачи.
Кнопка «Сохранить» отправит измененный текст на сервер для обновления, а затем перенаправит пользователя.
в главное представление, а кнопка «Отмена» перенаправит пользователя без внесения каких-либо изменений.
Это определенно хорошее начало! Однако мы еще далеки от завершения: нам еще предстоит добавить валидаторы, реализовать
обработку ошибок и напишите пару модульных тестов для клиентской и серверной стороны. Давайте начнем.

# Добавляем новый город
Прежде чем идти дальше, давайте потратим еще пару минут на добавление очень полезной функции в нашу
CityEditComponent: возможность добавить совершенно новый город. Это довольно классическое требование
Детальный вид с возможностью редактирования, который можно обрабатывать с помощью того же компонента – при условии, что мы
выполнить некоторые небольшие изменения, чтобы он мог обрабатывать новую функцию (добавление нового города), а также
существующий (редактирование существующего города) без проблем.

Для этого нам придется выполнить следующие шаги:
1. Расширьте функциональные возможности CityEditComponent, чтобы он мог добавлять новые города, а также
редактирование существующих
2. Добавьте новую кнопку «Добавить город» в файл шаблона нашего компонента и привяжите ее к новому маршруту на стороне клиента.
3. Реализовать необходимые функции для выбора страны для вновь добавленного города, что
также будет полезен в режиме редактирования (он позволит пользователям менять страну для существующих городов)
Давай приступим к работе!

# Расширение CityEditComponent
Откройте файл /src/app/cities/city-edit.comComponent.ts и добавьте следующий код (новые/обновленные строки выделены):

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormControl } from '@angular/forms';
import { environment } from './../../environments/environment';
import { City } from './city';
@Component({
 selector: 'app-city-edit',
 templateUrl: './city-edit.component.html',
 styleUrls: ['./city-edit.component.scss']
})
export class CityEditComponent implements OnInit {
 // the view title
 title?: string;
 // the form model
 form!: FormGroup;
 // the city object to edit or create
 city?: City;
 // the city object id, as fetched from the active route:
 // It's NULL when we're adding a new city,
 // and not NULL when we're editing an existing one.
 id?: number;
 constructor(
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private http: HttpClient) {
 }
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl(''),
 lat: new FormControl(''),
 lon: new FormControl('')
 });
 this.loadData();
 }
 loadData() {
 // retrieve the ID from the 'id' parameter
 var idParam = this.activatedRoute.snapshot.paramMap.get('id');
 this.id = idParam ? +idParam : 0;
 if (this.id) {
 // EDIT MODE
 // fetch the city from the server
 var url = environment.baseUrl + 'api/Cities/' + this.id;
 this.http.get<City>(url).subscribe(result => {
 this.city = result;
 this.title = "Edit - " + this.city.name;
 // update the form with the city value
 this.form.patchValue(this.city);
 }, error => console.error(error));
 }
 else {
 // ADD NEW MODE
 this.title = "Create a new City";
 }
 }
 onSubmit() {
 var city = (this.id) ? this.city : <City>{};
 if (city) {
 city.name = this.form.controls['name'].value;
 city.lat = +this.form.controls['lat'].value;
 city.lon = +this.form.controls['lon'].value;
 if (this.id) {
 // EDIT mode
 var url = environment.baseUrl + 'api/Cities/' + city.id;
 this.http
 .put<City>(url, city)
 .subscribe(result => {
 console.log("City " + city!.id + " has been updated.");
 // go back to cities view
 this.router.navigate(['/cities']);
 }, error => console.error(error));
 }
 else {
 // ADD NEW mode
 var url = environment.baseUrl + 'api/Cities';
 this.http
 .post<City>(url, city)
 .subscribe(result => {
 console.log("City " + result.id + " has been created.");
 // go back to cities view
 this.router.navigate(['/cities']);
 }, error => console.error(error));
 }
 }
 }
}
```
Благодаря этим изменениям наш код теперь сможет различать двух разных пользователей.
действия (добавление нового города или редактирование существующего) и правильно справляйтесь с ними обоими.

Файл шаблона HTML также может выполнять незначительное обновление, чтобы уведомить пользователя о новой функции.
Откройте файл /src/app/cities/cities-edit.comComponent.html и измените его следующим образом (файл
новые/обновленные строки выделены).
Добавьте следующий выделенный код в начале файла:

```html
<p *ngIf="this.id && !city"><em>Loading...</em></p>
```
Благодаря такому улучшению мы гарантируем, что сообщение «Загрузка...» не появится, когда мы
добавление нового города, поскольку переменная города будет пустой.
Наконец, измените фиксированный текст кнопки «Сохранить» на динамическое значение, используя строковую интерполяцию Angular.
особенность, которую мы уже видели несколько раз:

```html
<button mat-flat-button color="primary"
 type="submit">
 {{ this.id ? "Save" : "Create" }}
</button>
```
Это небольшое, но полезное дополнение позволит нам узнать, работает ли форма должным образом: всякий раз, когда мы добавляем
новый город (и значение this.id равно false), мы увидим более подходящую кнопку «Создать» вместо
Сохранить, который по-прежнему будет виден в режиме редактирования.
Теперь нам нужно сделать две вещи:
1. Найдите удобный способ сообщить нашим пользователям, что они могут добавлять новые города, а также изменять
существующие
2. Предоставьте им доступ к этой новой функции.
Простая кнопка «Добавить новый город» решит обе эти проблемы одновременно: давайте добавим ее в наш CitiesComponent.

# Добавляем кнопку «Добавить новый город»
Откройте файл /src/app/cities/cities.comComponent.html и добавьте следующий код сразу после
Загрузка… абзац:

```html
<p *ngIf="!cities"><em>Loading...</em></p>
<button mat-flat-button color="primary"
 class="btn-add" *ngIf="cities" [routerLink]="['/city']">
Add a new City
</button>
```
Здесь нет ничего нового; мы добавили обычную кнопку на основе маршрута внутри контейнера и *ngIf
структурная директива, чтобы она появилась после того, как массив Cities станет доступен.
Поскольку мы присвоили этой кнопке новый CSS-класс .btn-add, мы можем воспользоваться возможностью украсить ее с помощью
минимальный стиль пользовательского интерфейса, открыв файл /src/app/cities/cities.comComponent.scss и добавив
что-то вроде этого:

```scss
.btn-add {
 float: right;
}
```
Таким образом, кнопка будет выровнена по правому краю экрана.

# Добавляем новый маршрут
Теперь нам нужно определить новый маршрут, на который мы ссылались для кнопки «Добавить новый город».
Для этого откройте файл /src/app/app-routing.module.ts и обновите код следующим образом:

```
// ...existing code...
const routes: Routes = [
 { path: '', component: HomeComponent, pathMatch: 'full' },
 { path: 'cities', component: CitiesComponent },
 { path: 'city/:id', component: CityEditComponent },
 { path: 'city', component: CityEditComponent },
 { path: 'countries', component: CountriesComponent },
]),
```
Как мы видим, (новый) маршрут для добавления нового города и (существующий) маршрут для редактирования существующего города:
очень похожи, поскольку оба перенаправляют пользователя на один и тот же компонент; единственная разница в том, что
у последнего нет параметра id — метода, который мы использовали, чтобы сообщить нашему компоненту
для решения какой задачи это было запрошено. Если идентификатор присутствует, пользователь редактирует существующий город; в противном случае,
они добавляют новый.

У нас все хорошо... но мы еще не совсем там. Если бы нам нужно было проверить то, что мы уже сделали, нажав
F5 и попытка добавить новый город, наш модуль HttpClient будет встречен HTTP 500 — Internal
Ошибка сервера с сервера, аналогичная показанной на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/3531c37d-01bb-4c28-a2e9-37bacd1f5f9c)

Вот полный текст ошибки (с выделенными соответствующими частями):

```
---> Microsoft.Data.SqlClient.SqlException (0x80131904): The INSERT statement
conflicted with the FOREIGN KEY constraint "FK_Cities_Countries_CountryId".
The conflict occurred in database "WorldCities", table "dbo.Countries", column
'Id'.
The statement has been terminated.

```
Похоже, мы забыли свойство CountryId сущности City: мы сделали это намеренно.
когда нам нужно было определить городской интерфейс Angular, потому что он нам тогда не нужен был. Мы не страдали
из-за его отсутствия, когда мы реализовали режим редактирования города, потому что это свойство извлекалось автоматически
с сервера, а затем сохранялся в нашей локальной переменной Angular, которую мы отправляли обратно
сервер, пока запрос HTTP PUT выполнял обновление. Однако теперь, когда мы хотим
Если вы создадите новый город с нуля, такое недостающее имущество в конечном итоге принесет свои плоды.
Чтобы это исправить, нам нужно добавить свойство CountryId в файл /src/app/cities/city.ts следующим образом:
способ (новые строки выделены):

```ts
export interface City {
 id: number;
 name: string;
 lat: number;
 lon: number;
countryId: number;
}
```
Однако этого будет недостаточно: нам также нужно дать нашим пользователям возможность назначить конкретную страну.
в новый город; в противном случае свойство CountryId никогда не увидит фактическое значение – если мы не определим
это программно с фиксированным значением, что было бы довольно уродливым обходным путем (если не сказать больше).
Давайте исправим это по-приличному, добавив список стран в CityEditComponent, чтобы пользователю было
возможность выбрать один, прежде чем нажать кнопку «Создать». Такая новая функция будет очень полезна – даже когда
компонент работает в режиме редактирования, поскольку он позволит нашим пользователям менять страну для существующих городов.

# HTML select

Самый простой способ позволить нашим пользователям выбирать страну из списка стран — использовать <select>.
элемент и заполните его, получив наши данные из серверной части .NET через CountryController.
Метод ПолучитьСтраны(). Давайте сделаем это сейчас.
Откройте файл /src/app/cities/city-edit.comComponent.ts и добавьте следующий код (новый и
обновленные строки выделены):

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormControl } from '@angular/forms';
import { environment } from './../../environments/environment';
import { City } from './city';
import { Country } from './../countries/country';
@Component({
 selector: 'app-city-edit',
 templateUrl: './city-edit.component.html',
 styleUrls: ['./city-edit.component.scss']
})
export class CityEditComponent implements OnInit {
 // the view title
 title?: string;
 // the form model
 form!: FormGroup;
 // the city object to edit or create
 city?: City;
 // the city object id, as fetched from the active route:
// It's NULL when we're adding a new city,
 // and not NULL when we're editing an existing one.
 id?: number;
 // the countries array for the select
 countries?: Country[];
 constructor(
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private http: HttpClient) {
 }
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl(''),
 lat: new FormControl(''),
 lon: new FormControl(''),
 countryId: new FormControl('')
 });
 this.loadData();
 }
 loadData() {
 // load countries
 this.loadCountries();
 // retrieve the ID from the 'id' parameter
 var idParam = this.activatedRoute.snapshot.paramMap.get('id');
 this.id = idParam ? +idParam : 0;
 if (this.id) {
 // EDIT MODE
 // fetch the city from the server
 var url = environment.baseUrl + 'api/Cities/' + this.id;
 this.http.get<City>(url).subscribe(result => {
 this.city = result;
 this.title = "Edit - " + this.city.name;
 // update the form with the city value
 this.form.patchValue(this.city);
}, error => console.error(error));
 }
 else {
 // ADD NEW MODE
 this.title = "Create a new City";
 }
 }
 loadCountries() {
 // fetch all the countries from the server
 var url = environment.baseUrl + 'api/Countries';
 var params = new HttpParams()
 .set("pageIndex", "0")
 .set("pageSize", "9999")
 .set("sortColumn", "name");
 this.http.get<any>(url, { params }).subscribe(result => {
 this.countries = result.data;
 }, error => console.error(error));
 }
 onSubmit() {
 var city = (this.id) ? this.city : <City>{};
 if (city) {
 city.name = this.form.controls['name'].value;
 city.lat = +this.form.controls['lat'].value;
 city.lon = +this.form.controls['lon'].value;
 city.countryId = +this.form.controls['countryId'].value;
 if (this.id) {
 // EDIT mode
 var url = environment.baseUrl + 'api/Cities/' + city.id;
 this.http
 .put<City>(url, city)
 .subscribe(result => {
 console.log("City " + city!.id + " has been updated.");
 // go back to cities view
 this.router.navigate(['/cities']);
 }, error => console.error(error));
}
 else {
 // ADD NEW mode
 var url = environment.baseUrl + 'api/Cities';
 this.http
 .post<City>(url, city)
 .subscribe(result => {
 console.log("City " + result.id + " has been created.");
 // go back to cities view
 this.router.navigate(['/cities']);
 }, error => console.error(error));
 }
 }
 }
}
```
Что мы здесь делали?
- Мы добавили модуль HttpParams в список импорта @angular/common/http.
- Мы добавили ссылку на наш интерфейс «Страна», поскольку нам также нужно обрабатывать страны.
- Мы добавили переменную стран для хранения наших стран.
- Мы добавили элемент управления формы CountryId (с обязательным валидатором, поскольку это обязательное значение) в
наша форма
- Мы добавили метод loadCountries() для получения стран с сервера.
- Мы добавили вызов метода loadCountries() из метода loadData(), чтобы мы могли
асинхронно извлекаем страны, пока мы делаем остальную часть работы с loadData() (например, загрузку
город и/или настройка формы)
- Мы обновили идентификатор страны города, чтобы он соответствовал тому, который выбран в форме в
метод onSubmit(); это означает, что он будет отправлен на сервер для задачи вставки или обновления.

Стоит отметить, что в методе loadCountries() нам пришлось настроить некоторые параметры GET для URL-адреса /api/Countries, чтобы они соответствовали строгим значениям по умолчанию, которые мы установили в
Глава 6. Извлечение и отображение данных. Здесь нам не нужна разбиение по страницам, поскольку нам нужно извлекать данные.
весь список стран, чтобы заполнить наш список выбора. Точнее, мы устанавливаем pageSize
из 9999, чтобы гарантировать, что мы получим все наши страны, а также соответствующий столбец sortColumn для
пусть они будут упорядочены по имени.

Теперь мы можем использовать нашу новую переменную стран в нашем HTML-шаблоне.
Откройте файл /src/app/cities/city-edit.comComponent.html и добавьте следующий код прямо под ним.
поле mat-form-field долготы (новые строки выделены):

```html
<!-- Lon -->
<mat-form-field>
 <mat-label>Longitude:</mat-label>
 <input matInput formControlName="lon" required
 placeholder="Insert longitude">
</mat-form-field>
<!-- Country -->
<p *ngIf="countries">
 <select id="countryId" formControlName="countryId">
 <option value="">--- Select a country ---</option>
 <option *ngFor="let country of countries" [value]="country.id">
 {{country.name}}
 </option>
 </select>
</p>
```

Если мы нажмем F5, чтобы протестировать наш код, и перейдем к представлению «Добавить новый город» или «Редактировать город», мы увидим следующий вывод:

![image](https://github.com/artemovsergey/Angular/assets/26972859/f69d0c7a-6951-4551-b29c-40e125bcf07c)

Теперь, щелкнув раскрывающийся список --- Выберите страну ---, наши пользователи смогут выбрать страну.
из тех, что имеются. Это неплохо, правда? Однако макет не так уж хорош: по умолчанию,
Нестилизованный HTML-элемент <select> плохо сочетается с пользовательским интерфейсом Angular Material.
К счастью, мы определенно можем улучшить этот аспект, заменив стандартный HTML-выбор на
более мощный компонент из библиотеки пакетов Angular Material: MatSelectModule.

# Angular Material select (MatSelectModule)

Поскольку мы никогда раньше не использовали MatSelectModule, нам нужно добавить его в файл /src/app/angular-material.
файл модуль.ts.
Вот ссылка на использование для добавления:

```ts
import { MatSelectModule } from '@angular/material/select';
```
Как всегда, не забудьте также добавить модуль в коллекции импорта и экспорта @NgModule.
Сразу после этого мы можем заменить HTML-элемент <select>, который мы недавно добавили в файл /src/app/cities/cityedit.comComponent.html, следующим образом:

```ts
<!-- ...existing code... -->
<!-- Country -->
<mat-form-field *ngIf="countries">
 <mat-label>Select a Country...</mat-label>
 <mat-select id="countryId" formControlName="countryId">
 <mat-option *ngFor="let country of countries"
 [value]="country.id">
 {{country.name}}
 </mat-option>
 </mat-select>
</mat-form-field>
<!-- ...existing code... -->
```

Вот и все! Мы можем увидеть обновленный результат, нажав F5 (вывод см. на следующем снимке экрана):

![image](https://github.com/artemovsergey/Angular/assets/26972859/0d78c6ad-ce29-4059-b884-384ea8358f26)

MatSelectModule определенно красивее стандартного HTML-элемента <select>, сохраняя при этом
те же функции: нам даже не нужно менять файл класса базового компонента, поскольку он использует
тот же интерфейс привязки.

Теперь мы можем добавить наш новый город в нашу базу данных. Сделаем это, используя следующие данные:
- Название: Нью-Токио.
- Широта: 35,685.
- Долгота: 139,7514.
- Страна: Япония
Заполните форму «Создать новый город» этими значениями и нажмите кнопку «Создать». Если бы все прошло
что ж, мы должны вернуться к представлению «Города», где мы сможем найти наш город Новый Токио, используя
фильтр (см. следующий скриншот):

![image](https://github.com/artemovsergey/Angular/assets/26972859/7a24377d-7cf1-44d8-b377-294d797585d9)

Итак, мы успешно добавили наш первый город!
Теперь, когда наша Реактивная форма работает правильно, и у нас есть приличные знания о том, как она работает,
мы готовы потратить некоторое время на его настройку, добавив что-то, что может быть очень полезно в производственном сценарии: некоторые возможности обработки ошибок. Мы получим эти возможности

# Понимание проверки данных
Добавление проверки данных в форму вряд ли является выходом: это необходимая функция для проверки пользовательского ввода.
с точки зрения точности и полноты, чтобы улучшить общее качество данных путем проверки данных, которые мы
хочу – или нуждаюсь – собирать. Это также очень полезно с точки зрения пользовательского опыта, поскольку обработка ошибок
возможности, которыми она обладает, позволят нашим пользователям понять, почему форма не работает и что
они могут сделать, чтобы исправить проблемы, мешающие им отправить свои данные.

Чтобы понять эту концепцию, давайте возьмем нашу текущую реактивную форму CityEditComponent: она отлично работает.
если наши пользователи заполнят все обязательные поля; однако у них нет возможности понять, что
необходимые значения на самом деле есть, или что произойдет, если они забудут заполнить их все... кроме консоли
сообщение об ошибке, которое в настоящее время отображает наш исходный код всякий раз, когда наши запросы PUT и POST
в конечном итоге произойдет какая-либо внутренняя ошибка.
В этом разделе мы узнаем, как можно проверять вводимые пользователем данные из пользовательского интерфейса и отображать полезную информацию.
сообщения проверки с использованием нашей текущей реактивной формы. Пока мы там, мы также воспользуемся возможностью
создайте форму «Редактировать страну/Добавить новую страну» и в процессе узнайте что-то новое.

# Проверка на основе шаблонов
Для простоты мы решили не возиться с формами, управляемыми шаблонами, и внедрить
вместо этого мы сосредоточимся на модельно-ориентированных/реактивных формах. Однако, возможно, было бы разумно потратить пару
минут, чтобы понять, как мы можем добавить проверку к формам на основе шаблонов.
Хорошая новость заключается в том, что мы можем использовать те же стандартные атрибуты проверки, которые мы использовали бы.
обычно используется для проверки собственной HTML-формы: инфраструктура Angular использует директивы для их соответствия.
с функциями валидатора внутри и полностью прозрачно. Точнее, каждый раз, когда
значение элемента управления формой изменится, Angular запустит эти функции и сгенерирует либо список проверки
ошибки, что приводит к недопустимому статусу или нулю, что означает, что форма действительна.
Состояние формы, а также состояние каждого элемента управления формой можно проверить/инспектировать путем экспорта ngModel.
в локальную переменную шаблона. Вот пример, который может помочь прояснить это:

```html
<input id="name" name="name" required minlength="4"
 [(ngModel)]="city.name" #name="ngModel">
<div *ngIf="name.invalid && (name.dirty || name.touched)">
 <div *ngIf="name.errors?.required">Name is required.</div>
 <div *ngIf="name.errors?.minlength">Name must be at least 4
 characters long.</div>
</div>
```
Директивы проверки данных выделены жирным шрифтом. Как мы видим, предыдущая форма вызовет
ошибка – и показывать пользователю элемент <div> со стилем оповещения – всякий раз, когда название города отсутствует
или количество символов меньше 4, поскольку это минимально допустимая длина для ввода имени.
Стоит отметить, что мы проверяем два свойства, которые могут показаться довольно странными: name.dirty и
имя.тронуто. Вот краткое объяснение того, что они означают и почему целесообразно проверять их статус:
- Грязное свойство изначально имеет значение false и становится истинным всякий раз, когда пользователь меняет его.
начальные значения
- Свойство touched изначально имеет значение false и становится истинным всякий раз, когда пользователь размывает
формировать элемент управления, то есть щелкать (или касаться или «вкладывать») от него после того, как он оказался в фокусе

Теперь, когда мы знаем, как работают эти свойства, мы сможем понять, почему мы проверяем
их: мы хотим, чтобы наша ошибка валидатора данных была видна только в том случае, если/когда пользователь уходит от элемента управления,
оставив его с недопустимым значением или вообще без значения.

Вот и все, что касается проверки на основе шаблонов, по крайней мере, для целей этой книги. Те, кто
Если вам нужна дополнительная информация, ознакомьтесь со следующим руководством по адресу https://angular.
io/guide/forms#template-driven-forms.

# Проверка на основе модели
При работе с реактивными формами весь подход к проверке совершенно другой. В двух словах,
мы могли бы сказать, что большая часть этой работы должна быть выполнена внутри класса компонента: вместо добавления валидаторов с использованием атрибутов HTML в шаблоне нам придется добавить функции валидатора непосредственно в
сформируйте модель управления в классе компонентов, чтобы Angular мог вызывать их всякий раз, когда
значение управляющих изменений.
Поскольку в основном мы будем иметь дело с функциями, у нас также будет возможность сделать их синхронизированными или асинхронными.
таким образом получая возможность добавлять синхронные и/или асинхронные валидаторы:
- Валидаторы синхронизации немедленно возвращают либо набор ошибок проверки, либо ноль. Их можно установить
используя второй аргумент, когда мы создаем экземпляр FormControl, который им нужно проверить (
первый из них является значением по умолчанию).
- Асинхронные валидаторы возвращают Promise или Observable, настроенные на выдачу набора ошибок проверки или значения NULL. Их можно настроить с помощью третьего аргумента, когда мы создаем экземпляр
FormControl им нужно проверить.

Важно знать, что асинхронные валидаторы будут выполняться/проверяться только после синхронизации.
валидаторов, и только в том случае, если все они успешно пройдут. Такой архитектурный выбор был
сделано из соображений производительности.

В следующих разделах мы создадим их оба и добавим в нашу форму.

# Наши первые валидаторы
Хватит теории: давайте добавим первый набор валидаторов в форму CityEditComponent.
Откройте файл /src/app/cities/city-edit.comComponent.ts и добавьте следующий код:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormControl, Validators } from '@angular/forms';
// ...existing code...

''''''''''''''''
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl('', Validators.required),
 lat: new FormControl('', Validators.required),
 lon: new FormControl('', Validators.required),
 countryId: new FormControl('', Validators.required)
 });
 this.loadData();
 }
```
Как мы видим, мы добавили следующее:
- Ссылка на импорт класса Validators из пакета @angular/forms.
- Validators.required для каждого из наших элементов FormControl. Как следует из названия, это
валидатор ожидает, что эти поля будут иметь ненулевое значение; в противном случае он вернет недействительный статус.

Validators.required — это встроенный валидатор синхронизации, доступный на
класс Валидаторов. Другие встроенные валидаторы, предоставляемые этим классом, включают min,
Макс, требуетсяTrue, электронная почта, minLength, maxLength, шаблон, nullValidator,
Compose и ComposeAsync.
Для получения дополнительной информации о встроенных валидаторах Angular см.
следующий URL: https://angular.io/api/forms/Validators.

Когда вы закончите, откройте файл /src/app/cities/city-edit.comComponent.html и добавьте следующие элементы <mat-error> в конец каждого соответствующего существующего элемента mat-form-field:
перед закрывающим тегом этого элемента:

```html
<mat-error *ngIf="this.form.controls['name'].errors?.['required']">
 Name is required.
</mat-error>
<!-- ...existing code... --!/>
<mat-error *ngIf="this.form.controls['lat'].errors?.['required']">
 Latitude is required.
</mat-error>

<mat-error *ngIf="this.form.controls['lon'].errors?.['required']">
 Longitude is required.
</mat-error>
<!-- ...existing code... --!/>
<mat-error *ngIf="this.form.controls['countryId'].errors?.['required']">
 Please select a Country.
</mat-error>
```

Каждый из этих новых элементов <mat-error> будет проверять соответствующий ввод или выбирать значение.
и возвращать ошибку, если один (или несколько) из настроенных валидаторов не могут его проверить.
Как мы видим, все элементы mat-error имеют одну и ту же базовую логику: они будут показаны только тогда, когда
Свойству error.required элемента FormControl присвоено значение true, что происходит, когда соответствующее поле
значение пусто (поскольку для них всех установлен необходимый валидатор).

Стоит отметить, что ошибка мата, как и по умолчанию, будет отображаться только тогда, когда
элемент управления недействителен, и либо пользователь взаимодействовал с элементом (коснулся), либо
родительская форма была отправлена. Это отлично подходит для наших целей, поскольку означает, что
нам не нужно добавлять дополнительные проверки в директиву *ngIf для обработки затронутых
статус, как мы это делали в начале этой главы. Кроме того, важно помнить, что
каждый элемент mat-error должен быть помещен в соответствующее поле mat-form.
элемент для работы.
Дополнительную информацию о поведении по умолчанию mat-error (и о том, как его изменить) см.
следующий URL-адрес из документации Angular Material:
https://material.angular.io/comComponents/input/overview#changing-whenerror-messages-are-shown

Все, что нам нужно сделать сейчас, — это правильно протестировать эти валидаторы. Однако, прежде чем сделать это, давайте проведем
пару минут, объясняющих значение ? вопросительный знак, который мы использовали в *ngIf
директивы в приведенном выше коде TypeScript.

# Оператор безопасной навигации
Давайте еще раз посмотрим на этот код:

```
*ngIf="this.form.controls['lon'].errors?.['required']"
```
Этот вопросительный знак — оператор безопасной навигации TypeScript, также известный как оператор Элвиса.
очень полезно для защиты от нулевых и неопределенных значений в путях свойств. Если присутствует оператор безопасной навигации, TypeScript прекращает оценку выражения, когда оно достигает первого нулевого значения. В
предыдущий код, если свойство errorable, допускающее значение null, имеет значение null (что происходит всякий раз, когда
FormControl не содержит ошибок), все выражение вернет false без проверки требуемых значений.
свойство, что позволяет избежать одной из следующих ошибок нулевой ссылки:

```
TypeError: Cannot read property 'required' of null.
Error TS2531: Object is possibly 'null'
```
В более общих чертах, оператор безопасной навигации позволяет нам перемещаться по траектории объекта – даже
когда мы не знаем, существует такой путь или нет — возвращая либо значение
путь к объекту (если он существует) или ноль. Такое поведение очень удобно, когда нам нужно проверить наличие
значение любого объекта, допускающего значение NULL: ошибки FormControl, параметры GET или POST и множество других распространенных
сценарии. Именно по этой причине мы будем часто использовать его с этого момента.

Стоит отметить, что оператор безопасной навигации был частью языка шаблонов Angular HTML, начиная с Angular 2, и лишь недавно был добавлен в TypeScript. Это столь необходимое дополнение произошло в ноябре 2019 года с выпуском TypeScript v3.7:
https://www.typescriptlang.org/docs/handbook/release-notes/
машинопись-3-7.html

# Тестирование валидаторов
Давайте быстро проверим все, что мы сделали до сих пор: нажмите F5, перейдите к представлению «Города», нажмите «Добавить».
новую кнопку «Город» и поиграйте с формой, пытаясь активировать валидаторы.

Вот что происходит, когда мы циклически перебираем различные входные значения, ничего не вводя:

![image](https://github.com/artemovsergey/Angular/assets/26972859/c0b30f6d-3d1e-4c3b-a557-bf49aff3a179)

Неплохо, правда? Ошибки ввода не могут быть более заметными, а кнопка «Создать» останется неактивной до тех пор, пока
все они фиксированы, что предотвращает случайную отправку. Все эти цветные предупреждения должны помочь нашим
пользователи понимают, что они делают неправильно, и исправляют эти проблемы.
Прежде чем завершить наш путь проверки данных, нам нужно затронуть еще одну тему: проверку на стороне сервера.
что часто может быть единственным разумным способом предотвратить некоторые сложные ошибки.

# Проверка на стороне сервера
Проверка на стороне сервера — это процесс проверки ошибок (и соответствующей их обработки) на сервере.
на стороне сервера, то есть после того, как данные были отправлены на сервер. Это совершенно другой подход
от проверки на стороне клиента, когда данные проверяются внешним интерфейсом, то есть перед отправкой данных
на сервер.

Обработка ошибок на стороне клиента имеет массу преимуществ с точки зрения скорости и производительности, поскольку
пользователь сразу узнает, действительны ли входные данные, без необходимости запрашивать сервер.
Однако проверка на стороне сервера является обязательной функцией любого приличного веб-приложения, поскольку она предотвращает
множество потенциально опасных сценариев, таких как следующие:
- Ошибки реализации процесса проверки на стороне клиента, из-за которых может не блокироваться плохо отформатированные данные.
- Взломы на стороне клиента, выполняемые опытными пользователями, расширениями браузера или плагинами, которые могут
хотите разрешить пользователю отправлять неподдерживаемые входные значения на сервер
- Подделка запросов, то есть ложные HTTP-запросы, содержащие неверные или вредоносные данные.
Все эти методы основаны на обходе валидаторов на стороне клиента, что всегда возможно, поскольку у нас нет способа помешать нашим пользователям (или хакерам) пропускать, изменять или удалять
их; и наоборот, нельзя избежать валидаторов на стороне сервера, поскольку они будут выполняться одним и тем же
серверная часть, которая будет обрабатывать входные данные.
Таким образом, в двух словах, мы могли бы разумно сказать, что проверка на стороне клиента — это необязательная и удобная функция, тогда как проверка на стороне сервера — это требование для любого приличного веб-приложения, которое заботится о
о качестве входных данных.

Чтобы избежать путаницы, важно понимать, что проверка на стороне сервера, хотя и
реализованный на внутренней стороне, также требует внешней реализации, такой как вызов
серверную часть, а затем отображаем результаты проверки пользователю. Основное отличие
Между проверкой на стороне клиента и проверкой на стороне сервера заключается в том, что первая существует только на
клиентскую сторону и никогда не вызывает серверную часть, в то время как последняя полагается на интерфейсную часть и
скоординированные усилия серверной части, поэтому его сложнее реализовать и протестировать.

Более того, в некоторых сценариях проверка на стороне сервера является единственным возможным способом проверить наличие
определенные условия или требования, которые не могут быть проверены только путем проверки на стороне клиента. Объяснить
эту концепцию, давайте рассмотрим быстрый пример.
Запустите наше приложение WorldCities в режиме отладки, нажав F5, перейдите в представление «Города» и введите «Париж» в поле «Париж».
текстовое поле фильтра.

Вы должны увидеть следующий вывод:

![image](https://github.com/artemovsergey/Angular/assets/26972859/87d7e169-907f-49e0-ae06-78acde006d6e)

Предыдущий скриншот говорит нам о следующем:
- Во всем мире существует как минимум девять городов, в названии которых содержится слово «Париж»… и
шесть из них на самом деле называются Парижем (!)
- Несколько городов могут иметь одно и то же название.
Это неудивительно: когда мы создавали нашу базу данных с использованием Entity Framework с приоритетом кода, мы не
сделайте поле названия уникальным, поскольку мы знали, что существует высокая вероятность появления одноименных городов. К счастью
достаточно, это не проблема, поскольку мы все еще можем различать их, глядя на широту, долготу и долготу.
ценности страны.

Если мы проверим некоторые из этих городов на Картах Google, мы увидим, что один из них находится во Франции.
другой — в Техасе (США), третий — в Теннесси (США) и так далее: одно и то же имя, разные города.

А как насчет добавления валидатора, который мог бы проверять, имеет ли город, который мы пытаемся добавить, такое же имя?
Значения широты и долготы, поскольку город уже присутствует в нашей базе данных? Такая функция заблокирует наших пользователей
от вставки одного и того же города несколько раз, что позволяет избежать реальных дубликатов и не блокировать омонимы, имеющие разные координаты.
К сожалению, сделать это только на стороне клиента невозможно. Для выполнения этой задачи нам потребуется
создайте собственный валидатор Angular, который мог бы асинхронно проверять эти значения на сервере и
затем верните результат OK (действительный) или KO (недействительный): другими словами, задача проверки на стороне сервера.
Давайте попробуем сделать это сейчас.

# DupeCityValidator
В этом разделе мы создадим собственный валидатор, который будет выполнять асинхронный вызов нашего .NET.
Базовая серверная часть, чтобы гарантировать, что город, который мы пытаемся добавить, не имеет одинакового имени, широты, долготы и
страна как существующая.

# city-edit.component.ts
Первое, что нам нужно сделать, это создать сам валидатор и привязать его к нашей реактивной форме. Чтобы сделать это,
откройте файл /src/app/cities/city-edit.comComponent.ts и соответствующим образом измените его содержимое (файл
новые/обновленные строки выделены):

```ts
import { FormGroup, FormControl, Validators, AbstractControl, AsyncValidatorFn
} from '@angular/forms';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
// ...existing code...
 ngOnInit() {
 this.form = new FormGroup({
 name: new FormControl('', Validators.required),
 lat: new FormControl('', Validators.required),
 lon: new FormControl('', Validators.required),
 countryId: new FormControl('', Validators.required)
 }, null, this.isDupeCity());
 this.loadData();
 }

isDupeCity(): AsyncValidatorFn {
 return (control: AbstractControl): Observable<{ [key: string]: any } |
null> => {
 var city = <City>{};
 city.id = (this.id) ? this.id : 0;
 city.name = this.form.controls['name'].value;
 city.lat = +this.form.controls['lat'].value;
 city.lon = +this.form.controls['lon'].value;
 city.countryId = +this.form.controls['countryId'].value;
 var url = environment.baseUrl + 'api/Cities/IsDupeCity';
 return this.http.post<boolean>(url, city).pipe(map(result => {
 return (result ? { isDupeCity: true } : null);
 }));
 }
 }
}
```

Как мы видим, мы внесли несколько важных изменений в предыдущий код:
- Мы добавили несколько ссылок на импорт (AbstractControl, AsyncValidatorFn, Observable и
map), который мы использовали для реализации нашего нового асинхронного пользовательского валидатора. Если вы не получите то, что нам нужно
для них, не волнуйтесь: мы поговорим об этой теме позже.
- Мы создали новый метод isDupeCity(), который содержит всю реализацию нашего
асинхронный пользовательский валидатор.
- Мы настроили новый валидатор для использования основной группой форм (той, которая связана с
целая форма).
Что касается нашего специального валидатора, он кажется намного сложнее, чем есть на самом деле. Попробуем подвести итог
что оно делает:
- Первое, что стоит упомянуть, это то, что метод isDupeCity() возвращает AsyncValidatorFn.
это, в свою очередь, возвращает Observable: это означает, что мы возвращаем не значение, а подписчика
экземпляр функции, который в конечном итоге вернет значение, которое будет либо объектом «ключ/значение», либо
нулевой. Это значение будет генерироваться только при выполнении Observable.
- Внутренняя функция создает временный объект города, заполняет его данными формы в реальном времени, вызывает
внутренний URL-адрес IsDupeCity, который мы еще не знаем (но скоро узнаем), и в конечном итоге
возвращает true или null, в зависимости от результата. Стоит отметить, что мы не подписываемся
на этот раз к HttpClient, как мы часто делали в прошлом: мы манипулируем им с помощью канала
и сопоставить операторы ReactJS (RxJS), о которых мы поговорим чуть позже.

Поскольку наш пользовательский валидатор использует HTTP-запрос, отправляемый на серверную часть .NET Core, нам необходимо
реализовать этот метод.

# CitiesController
Переключитесь на проект WorldCityAPI, затем откройте файл /Controllers/CitiesController.cs и добавьте
следующий метод в нижней части файла:

```Csharp
private bool CityExists(int id)
{
 return _context.Cities.Any(e => e.Id == id);
}
[HttpPost]
[Route("IsDupeCity")]
public bool IsDupeCity(City city)
{
 return _context.Cities.Any(
 e => e.Name == city.Name
 && e.Lat == city.Lat
 && e.Lon == city.Lon
 && e.CountryId == city.CountryId
 && e.Id != city.Id
 );
}
```
Метод .NET очень прост: он проверяет модель данных для города с тем же именем,
Lat, Lon и CountryId как предоставленные внешним интерфейсом (а также другой идентификатор) и возвращает
истина или ложь в результате. Добавлена проверка идентификатора для условного отключения проверки на дублирование при
пользователь редактирует существующий город. В этом случае использование одного и того же имени, широты, долготы и CountryId будет
разрешено, поскольку мы по сути перезаписываем один и тот же город, а не создаем новый. Когда пользователь
добавляет новый город, значение этого идентификатора всегда будет равно нулю, что предотвращает отключение проверки на дублирование.

# city-edit.component.html
Теперь, когда внутренний код готов, нам нужно создать подходящее сообщение об ошибке из пользовательского интерфейса. Открой
/src/app/cities/city-edit.comComponent.html и обновите его содержимое следующим образом (файл
новые строки выделены):

```html
<div class="city-edit">
 <h1>{{title}}</h1>
 <p *ngIf="this.id && !city"><em>Loading...</em></p>
 <form [formGroup]="form" (ngSubmit)="onSubmit()">
 <p>
 <mat-error *ngIf="form.invalid && form.hasError('isDupeCity')">
 <strong>ERROR</strong>:
 A city with the same <i>name</i>, <i>lat</i>,
 <i>lon</i> and <i>country</i> already exists.
 </mat-error>
 </p>
```
Как показано в предыдущем коде, добавленное нами предупреждение <div> будет отображаться только в том случае, если следующие три
условия соблюдены:
- Форма недействительна.
- Есть ошибки, которые строго связаны с самой формой.
- Ошибка isDupeCity возвращает true.
Очень важно проверить их все, иначе мы рискуем показать такое оповещение даже тогда, когда его нет.
надо показать.

# Тестирование
Теперь, когда HTML-шаблон компонента настроен, мы можем протестировать результат нашей кропотливой работы.
Нажмите F5, перейдите к представлению «Города», нажмите кнопку «Добавить новый город» и вставьте следующие значения:
- Название: Нью-Токио.
- Широта: 35,685.
- Долгота: 139,7514.
- Страна: Япония

Если мы все сделали правильно, нас должно встретить следующее сообщение об ошибке:

![image](https://github.com/artemovsergey/Angular/assets/26972859/1ce91a65-b670-48ad-86f3-27d18c6ff387)

Замечательно! Наш собственный асинхронный валидатор работает нормально и запускает как интерфейсную, так и внутреннюю логику проверки.

# Observables и операторы RxJS
Асинхронная логика, используемая для выполнения вызова, использует шаблон Observable/RxJS: на этот раз
однако вместо того, чтобы полагаться на метод subscribe(), который мы уже использовали несколько раз, мы выбрали
для подхода «труба + карта». Это два очень важных оператора RxJS, которые позволяют нам выполнять наши
задачи манипулирования данными, сохраняя при этом статус Observable возвращаемого значения, в то время как подписки будут выполнять Observable и вместо этого возвращать фактические данные.
Эту концепцию может быть довольно сложно понять. Попробуем выразить это другими словами:
• Мы должны использовать метод subscribe(), когда хотим выполнить Observable и получить его
фактический результат; например, структурированный ответ в формате JSON. Такой метод возвращает подписку
его можно отменить, но на него больше нельзя подписаться.
• Мы должны использовать оператор map(), когда хотим преобразовать или манипулировать событиями данных.
Observable без его выполнения, чтобы его можно было передать другим асинхронным актерам, которые будут
также манипулировать (и, в конечном итоге, выполнять) им. Такой метод возвращает Observable, который может
быть подписанным.

Что касается Pipe(), то это всего лишь оператор RxJS, который объединяет/связывает другие операторы (такие как карта, фильтр,
и так далее).
Самое важное различие между методами Observable и операторами RxJS заключается в том, что последние
всегда возвращает Observables, тогда как первый возвращает другой (и в основном окончательный) тип объекта. Делает
это звоночек?
Если мы подумаем о том, что мы узнали еще в главе 6 «Извлечение и отображение данных», когда имеем дело с
.NET Entity Framework, это определенно должно звучать знакомо. Помните, когда мы играли
с интерфейсом IQueryable<T>? Различные методы IQueryable Where, OrderBy и CountAsync.
которые мы использовали при создании нашего класса ApiResult, очень похожи на то, что мы можем сделать в Angular с помощью
объединение нескольких функций карты с помощью оператора канала. И наоборот, метод subscribe() строго
напоминает различные методы ToListAsync()/ToArrayAsync(), которые мы использовали в .NET для выполнения
IQueryable и получить его результат в пригодном для использования объекте.

# Проблемы с производительностью
Прежде чем двигаться дальше, попробуем ответить на следующий вопрос: когда будет проверяться этот валидатор? В других
Другими словами, можем ли мы разумно ожидать проблем с производительностью, учитывая тот факт, что он выполняет серверную
Вызов API при каждой проверке?
Если мы вспомним то, что мы говорили ранее, асинхронные валидаторы будут проверены только тогда, когда все синхронные валидаторы вернут true. Поскольку isDupeCity является асинхронным, он не будет вызываться до тех пор, пока не будут обработаны все валидаторы.
требуется, чтобы мы ранее установили во всех элементах FormControl возврат true. Это великолепно
действительно новости, так как не было бы смысла проверять существующий город с названием, широтой, долготой и/или
или CountryId имеет нулевое значение или пуст.
Основываясь на том, что мы только что сказали, мы можем разумно ожидать, что валидатор isDupeCity будет вызван один раз.
или дважды для каждой отправки формы, что совершенно нормально с точки зрения производительности. Все
тогда все в порядке. Давайте двигаться дальше.

# Знакомство с FormBuilder
Теперь, когда наш CityEditComponent настроен, у нас может возникнуть соблазн повторно использовать те же методы.
чтобы создать CountryEditComponent и выполнить работу, как мы это делали в главе 6 «Извлечение и
Отображение данных с помощью наших файлов CitiesComponent и CountryComponent. Однако мы не будем делать
этот. Вместо этого мы воспользуемся возможностью представить в нашем сарае новый инструмент, который может оказаться очень полезным, когда
работа с несколькими формами: сервис FormBuilder.
В следующих разделах мы сделаем следующее:
- Создайте наш CountryEditComponent со всеми необходимыми файлами TypeScript, HTML и SCSS.
- Узнайте, как использовать службу FormBuilder для более эффективного создания элементов управления форм.
- Добавьте новый набор валидаторов (включая совершенно новый пользовательский валидатор isDupeCountry) в
реализация новой формы
- Протестируйте нашу новую реализацию на основе FormBuilder, чтобы убедиться, что все работает.

К концу этого раздела у нас будет полнофункциональный CountryEditComponent, который будет работать в
так же, как и CityEditComponent, за исключением того, что он будет основан на немного другом подходе.

# Создание компонента CountryEditComponent
Давайте начнем с создания компонента Angular, как мы это делали ранее с CityEditComponent.
Откройте командную строку, перейдите в папку /src/app/countries/ нашего проекта WorldCities,
а затем выполните следующую команду:

```
ng generate component CountryEdit --flat --module=app --skip-tests
```

Когда вы закончите, заполните вновь созданные файлы компонентов следующим содержимым.

# country-edit.component.ts

Откройте файл /src/app/countries/country-edit.comComponent.ts и заполните его следующим кодом.
Обратите внимание на выделенные части, которые сильно отличаются от предыдущего CityEditComponent;
другие незначительные различия, такие как страна вместо города, страны вместо городов и т.п.,
не выделены, так как их больше, чем ожидалось:

```ts
import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { ActivatedRoute, Router } from '@angular/router';
import { FormGroup, FormBuilder, Validators, AbstractControl, AsyncValidatorFn
} from '@angular/forms';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { environment } from './../../environments/environment';
import { Country } from './country';
@Component({
 selector: 'app-country-edit',
 templateUrl: './country-edit.component.html',
 styleUrls: ['./country-edit.component.scss']
})
export class CountryEditComponent implements OnInit {
 // the view title
 title?: string;
 // the form model
 form!: FormGroup;
// the country object to edit or create
 country?: Country;
 // the country object id, as fetched from the active route:
 // It's NULL when we're adding a new country,
 // and not NULL when we're editing an existing one.
 id?: number;
 // the countries array for the select
 countries?: Country[];
 constructor(
 private fb: FormBuilder,
 private activatedRoute: ActivatedRoute,
 private router: Router,
 private http: HttpClient) {
 }
 ngOnInit() {
 this.form = this.fb.group({
 name: ['',
 Validators.required,
 this.isDupeField("name")
 ],
 iso2: ['',
 [
 Validators.required,
 Validators.pattern(/^[a-zA-Z]{2}$/)
 ],
 this.isDupeField("iso2")
 ],
 iso3: ['',
 [
 Validators.required,
 Validators.pattern(/^[a-zA-Z]{3}$/)
 ],
 this.isDupeField("iso3")
 ]
 });
 this.loadData();
}
 loadData() {
 // retrieve the ID from the 'id' parameter
 var idParam = this.activatedRoute.snapshot.paramMap.get('id');
 this.id = idParam ? +idParam : 0;
 if (this.id) {
 // EDIT MODE
 // fetch the country from the server
 var url = environment.baseUrl + "api/Countries/" + this.id;
 this.http.get<Country>(url).subscribe(result => {
 this.country = result;
 this.title = "Edit - " + this.country.name;
 // update the form with the country value
 this.form.patchValue(this.country);
 }, error => console.error(error));
 }
 else {
 // ADD NEW MODE
 this.title = "Create a new Country";
 }
 }
 onSubmit() {
 var country = (this.id) ? this.country : <Country>{};
 if (country) {
 country.name = this.form.controls['name'].value;
 country.iso2 = this.form.controls['iso2'].value;
 country.iso3 = this.form.controls['iso3'].value;
 if (this.id) {
 // EDIT mode
 var url = environment.baseUrl + 'api/Countries/' + country.id;
 this.http
 .put<Country>(url, country)
 .subscribe(result => {
console.log("Country " + country!.id + " has been updated.");
 // go back to countries view
 this.router.navigate(['/countries']);
 }, error => console.error(error));
 }
 else {
 // ADD NEW mode
 var url = environment.baseUrl + 'api/Countries';
 this.http
 .post<Country>(url, country)
 .subscribe(result => {
 console.log("Country " + result.id + " has been created.");
 // go back to countries view
 this.router.navigate(['/countries']);
 }, error => console.error(error));
 }
 }
 }
 isDupeField(fieldName: string): AsyncValidatorFn {
 return (control: AbstractControl): Observable<{
 [key: string]: any
 } | null> => {
 var params = new HttpParams()
 .set("countryId", (this.id) ? this.id.toString() : "0")
 .set("fieldName", fieldName)
 .set("fieldValue", control.value);
 var url = environment.baseUrl + 'api/Countries/IsDupeField';
 return this.http.post<boolean>(url, null, { params })
 .pipe(map(result => {
 return (result ? { isDupeField: true } : null);
 }));
 }
 }
}
```
Как мы видим, исходный код компонента очень похож на CityEditComponent, за исключением некоторых
ограниченные, но важные различия, которые мы собираемся суммировать здесь:
- Служба FormBuilder добавлена в список импорта @angular/forms, заменив
Ссылка FormControl, которая нам больше не нужна. На самом деле, мы все еще создаем
элементы управления формой, но мы сделаем это через FormBuilder вместо того, чтобы создавать их экземпляры вручную,
это означает, что нам не нужно явно ссылаться на них.
- Экземпляр переменной формы теперь создается с использованием другого подхода, который сильно зависит от
новый сервис FormBuilder.
- Различные элементы FormControl, экземпляры которых создаются внутри функции формы, являются некоторыми
валидаторы, которых мы никогда раньше не видели.
Сервис FormBuilder предоставляет нам три фабричных метода, чтобы мы могли создать структуру формы:
control(), group() и array(). Каждый из них генерирует экземпляр соответствующего FormControl,
FormGroup и класс FormArray. В нашем примере мы создаем одну содержащую группу с тремя
элементы управления, каждый со своим набором валидаторов.
Что касается валидаторов, мы видим две новые записи:
- Validators.pattern: встроенный валидатор, который требует, чтобы значение элемента управления соответствовало заданному значению.
шаблон регулярного выражения (regex). Поскольку наши поля страны ISO2 и ISO3 определяются с использованием
строгий формат, мы собираемся использовать их, чтобы гарантировать, что пользователь вводит правильные значения.
- isDupeField: это специальный асинхронный валидатор, который мы реализовали здесь впервые. Его
похоже на валидатор isDupeCity, который мы создали для нашего CityEditComponent, но с некоторым ключом
различия, которые мы собираемся суммировать в следующем разделе.

Те, кто мало что знает о регулярных выражениях (или сокращенно регулярных выражениях) и хочет
использовать Validators.pattern в полной мере, обязательно посетите следующий веб-сайт,
который содержит большое количество ресурсов, касающихся регулярных выражений, и отличный онлайн-конструктор.
и тестер с полной поддержкой регулярных выражений JavaScript и PHP/PCRE: https://regexr.com/.

Валидатор шаблонов говорит сам за себя, тогда как собственный валидатор isDupeField заслуживает
некоторые дополнительные пояснения.

# Валидатор isDupeField
Как мы видим, посмотрев исходный код предыдущего компонента, пользовательский валидатор isDupeField
не назначается основной группе форм, как isDupeCity; вместо этого он устанавливается три раза: по одному для каждого
FormControl его нужно проверить. Причина этого проста: по сравнению с isDupeCity, который был
предназначенный для проверки повторяющихся городов с использованием дублирующего ключа из четырех полей, isDupeField должен индивидуально
проверьте каждое поле, которому оно назначено. Нам нужно это сделать, потому что мы не хотим, чтобы было больше одной страны.
имеющий то же имя, или тот же ISO2, или тот же ISO3.

Это также объясняет, почему нам нужно указывать имя поля и соответствующее значение поля вместо
передача интерфейса страны: серверный API isDupeField должен будет выполнить другую проверку.
для каждого имени поля, которое мы собираемся передать, вместо того, чтобы полагаться на одну универсальную проверку, такую ​​как

isDupeCity API делает.
Что касается параметра CountryId, он необходим для предотвращения возникновения ошибки проверки при проверке на дублирование.
при редактировании существующей страны. В валидаторе isDupeCity оно было передано как собственность города.
сорт. Теперь нам нужно явно добавить его в параметры POST.

# Серверный API IsDupeField
Теперь нам нужно реализовать внутренний API нашего пользовательского валидатора, так же, как мы это сделали с IsDupeCity().
на ранней стадии. Переключитесь на проект WorldCitiesAPI, затем откройте файл /Controllers/CountriesController.
cs и добавьте следующий метод внизу файла:

```Csharp
private bool CountryExists(int id)
{
 return _context.Countries.Any(e => e.Id == id);
}
[HttpPost]
[Route("IsDupeField")]
public bool IsDupeField(
 int countryId,
 string fieldName,
 string fieldValue)
{
 switch (fieldName)
 {
 case "name":
 return _context.Countries.Any(
 c => c.Name == fieldValue && c.Id != countryId);
 case "iso2":
 return _context.Countries.Any(
 c => c.ISO2 == fieldValue && c.Id != countryId);
 case "iso3":
 return _context.Countries.Any(
 c => c.ISO3 == fieldValue && c.Id != countryId);
 default:
 return false;
 }
}
```

Хотя код напоминает серверный API IsDupeCity, мы переключаем параметр fieldName и выполняем другую проверку на наличие дубликатов в зависимости от его значения; такая логика реализована с помощью
стандартный условный блок переключателя/регистра со строго типизированными лямбда-выражениями LINQ для каждого поля
мы можем разумно ожидать. Опять же, мы также проверяем, отличается ли идентификатор страны, чтобы наши пользователи
можно редактировать существующую страну.
Если имя поля, полученное от клиента, отличается от трех поддерживаемых значений, наш API
ответить ложью.

# Альтернативный подход с использованием Linq.Dynamic
Прежде чем двигаться дальше, мы можем спросить себя, почему мы реализовали API IsDupeField, используя
строго типизированные лямбда-выражения внутри блока switch...case вместо того, чтобы полагаться на метод System.
Библиотека Linq.Dynamic.Core.
На самом деле мы сделали это для простоты, поскольку динамический подход потребует от нас
нам придется писать дополнительный код для защиты нашего метода от атак с использованием SQL-инъекций. Однако, поскольку мы
такая задача уже реализована в методе IsValidProperty() нашего класса ApiResult, возможно
мы можем использовать его и уменьшить предыдущий код: в конце концов, мы сделали его общедоступным и статическим, чтобы мы могли
можно использовать его где угодно.
Вот альтернативная реализация с использованием вышеупомянутых инструментов (старый код прокомментирован,
пока новый код выделен):

```Csharp
using System.Linq.Dynamic.Core;
// ...existing code...
[HttpPost]
[Route("IsDupeField")]
public bool IsDupeField(
 int countryId,
 string fieldName,
 string fieldValue)
{
 // Default approach (using strongly-typed LAMBA expressions)
 //switch (fieldName)
 //{
 // case "name":
 // return _context.Countries.Any(c => c.Name == fieldValue);
 // case "iso2":
 // return _context.Countries.Any(c => c.ISO2 == fieldValue);
 // case "iso3":
 // return _context.Countries.Any(c => c.ISO3 == fieldValue);
 // default:
// return false;
 //}
 // Alternative approach (using System.Linq.Dynamic.Core)
 return (ApiResult<Country>.IsValidProperty(fieldName, true))
 ? _context.Countries.Any(
 string.Format("{0} == @0 && Id != @1", fieldName),
 fieldValue,
 countryId)
 : false;
}
```
Неплохо, правда?
Альтернативный динамический подход определенно выглядит более СУХИМ и универсальным, чем стандартный.
сохраняя при этом тот же уровень безопасности от атак SQL-инъекций. Единственный недостаток может быть связан
к дополнительным накладным расходам, вызванным библиотекой System.Linq.Dynamics.Core, которая, скорее всего, будет иметь
некоторое незначительное влияние на производительность. Хотя в большинстве сценариев это не должно быть проблемой, всякий раз, когда
мы хотим, чтобы наши API отвечали на HTTP-запросы как можно быстрее, возможно, нам следует отдать предпочтение
подход по умолчанию.

# country-edit.component.html
Пришло время реализовать шаблон нашего CountryEditComponent.
Откройте файл /src/app/countries/country-edit.comComponent.html и заполните его следующим кодом.
Еще раз обратите внимание на выделенные части, которые сильно отличаются от шаблона.
СитиРедитКомпонент; другие незначительные различия, такие как страна вместо города, не выделены
поскольку они больше, чем ожидалось:

```html
<div class="country-edit">
 <h1>{{title}}</h1>
 <p *ngIf="this.id && !country"><em>Loading...</em></p>
 <form [formGroup]="form" (ngSubmit)="onSubmit()">
 <!-- Name -->
 <mat-form-field>
 <mat-label>Name:</mat-label>
 <input matInput formControlName="name" required
 placeholder="Type a name">
 <mat-error *ngIf="this.form.controls['name'].errors?.['required']">
 Name is required.
 </mat-error>
 <mat-error *ngIf="this.form.controls['name'].errors?.['isDupeField']">
 Name already exists: please choose another.
</mat-error>
 </mat-form-field>
 <!-- ISO2 -->
 <mat-form-field>
 <mat-label>
 ISO 3166-1 ALPHA-2 Country code (2 letters)
 </mat-label>
 <input matInput formControlName="iso2" required
 placeholder="Insert the ISO2 Country code">
 <mat-error *ngIf="this.form.controls['iso2'].errors?.['required']">
 ISO 3166-1 ALPHA-2 Country code is required.
 </mat-error>
 <mat-error *ngIf="this.form.controls['iso2'].errors?.['pattern']">
 ISO 3166-1 ALPHA-2 Country code requires 2 letters.
 </mat-error>
 <mat-error *ngIf="this.form.controls['iso2'].errors?.['isDupeField']">
 This code already exists: please choose another.
 </mat-error>
 </mat-form-field>
 <!-- ISO3 -->
 <mat-form-field>
 <mat-label>
 ISO 3166-1 ALPHA-3 Country code (3 letters)
 </mat-label>
 <input matInput formControlName="iso3" required
 placeholder="Insert the ISO3 Country code">
 <mat-error *ngIf="this.form.controls['iso3'].errors?.['required']">
 ISO 3166-1 ALPHA-3 Country code is required.
 </mat-error>
 <mat-error *ngIf="this.form.controls['iso3'].errors?.['pattern']">
 ISO 3166-1 ALPHA-3 Country code requires 3 letters.
 </mat-error>
 <mat-error *ngIf="this.form.controls['iso3'].errors?.['isDupeField']">
 This code already exists: please choose another.
 </mat-error>
 </mat-form-field>
 <div>
 <button mat-flat-button color="primary"
type="submit">
 {{ this.id ? "Save" : "Create" }}
 </button>
 <button mat-flat-button color="secondary"
 [routerLink]="['/countries']">
 Cancel
 </button>
 </div>
 </form>
</div>
```

Как мы видим, наиболее важные различия связаны с HTML-кодом, который необходим для отображения
новый шаблон и валидаторы isDupeField. Теперь у нас есть целых три разных валидатора для наших
полей, и это очень здорово: нашим пользователям не будет предоставлена возможность ввести неправильные значения!

# country-edit.component.scss
И последнее, но не менее важное: давайте применим стили пользовательского интерфейса.
Откройте файл /src/app/countries/country-edit.comComponent.scss и заполните его следующим кодом:

```scss
mat-form-field {
 display: block;
 margin: 10px 0;
}
```
Никаких сюрпризов здесь нет; предыдущий код таблицы стилей идентичен тому, который мы использовали для CityEditComponent.
Наш компонент наконец готов! Теперь нам просто нужно сослаться на него в файле AppRoutingModule, чтобы реализовать маршруты навигации на стороне клиента.

# Модуль AppRoutingModule
К настоящему моменту мы должны знать, что делать. Откройте файл app-routing.module.ts и добавьте следующее
правила маршрутизации (новые строки выделены):

```ts
import { CountryEditComponent } from './countries/country-edit.component';
// existing code…
{ path: 'countries', component: CountriesComponent },
{ path: 'country/:id', component: CountryEditComponent },
{ path: 'country', component: CountryEditComponent }
```
Теперь, когда мы заложили два маршрута, чтобы мы могли редактировать и добавлять страны, нам просто нужно реализовать их в файле шаблона CountrysComponent, добавив ссылку на маршрут в столбце «Имя».
и кнопку «Добавить новую страну», как мы это делали с городами.

# CountriesComponent
Откройте файл /src/app/countries/countries.comComponent.html и добавьте следующий код (новый
и обновленные строки выделены):

```html
<p *ngIf="!countries"><em>Loading…</em></p>
<button mat-flat-button color="primary"
 class="btn-add" [routerLink]="['/country']">
 Add a new Country
</button>
<!-- ...existing code... -->
<!--Name Column -->
<ng-container matColumnDef="name">
 <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
 <td mat-cell *matCellDef="let country">
 <a [routerLink]="['/country', country.id]">{{country.name}}</a>
 </td>
</ng-container>
```
Мы почти закончили: нам просто нужно добавить CSS-класс .add-btn в файл Country.comComponent.scss,
чтобы кнопка «Добавить новую страну» была выровнена по правому краю…

```css
btn-add {
 float: right;
}
```
Вот и все! Теперь мы готовы все проверить.

# Тестирование CountryEditComponent
Теперь пришло время нажать F5 и полюбоваться результатом нашей кропотливой работы.
После запуска приложения в режиме отладки перейдите в представление «Страны», чтобы увидеть кнопку «Добавить новую».
Кнопка «Страна» и ссылки редактирования для различных названий стран, как показано на следующем снимке экрана:

![image](https://github.com/artemovsergey/Angular/assets/26972859/75d76665-3220-4446-8f0a-601ec4702984)

Теперь давайте найдем Данию, используя наш фильтр, и щелкните имя, чтобы ввести CountryEditComponent.
в режиме редактирования. Если все работает нормально, поля name, iso2 и iso3 должны быть зелеными, что означает
что наши специальные валидаторы isDupeField не вызывают ошибок:

![image](https://github.com/artemovsergey/Angular/assets/26972859/d4a8b3e1-c899-4042-a565-b1d7c7d70cdf)

Теперь давайте попробуем изменить название страны на Японию и код страны ISO 3166-1 ALPHA-2 на IT.
и посмотрим, что произойдет:

![image](https://github.com/artemovsergey/Angular/assets/26972859/bc9ebf20-f9ec-416c-8694-9683b3d3723d)

Это отличный результат: это значит, что наши кастомные валидаторы делают свою работу, положительно повышая
некоторые ошибки обмана, поскольку эти значения зарезервированы для других существующих стран (Япония и Италия,
соответственно).
Теперь давайте нажмем кнопку «Отмена» и вернемся к представлению «Страны». Оттуда нажмите Добавить новый
Нажмите кнопку «Страна» и попробуйте вставить страну со следующими значениями:
- Название: Новая Япония
- ISO 3166-1 АЛЬФА-2 Код страны: JP.
- ISO 3166-1 АЛЬФА-3 Код страны: NJ2.
Если все работает нормально, мы должны выдать еще две ошибки проверки, как показано ниже.
Скриншот:

![image](https://github.com/artemovsergey/Angular/assets/26972859/8fd710c7-d09c-443d-96fc-e9faa943883e)

Первая ошибка возникает нашим пользовательским валидатором isDupeField и связана с тем, что ALPHA-2
код страны уже принадлежит существующей стране (Япония); последний поднимается встроенным
Validators.pattern, который мы настроили с помощью регулярного выражения /^[a-zA-Z]{3}$/, которое не
разрешить цифры.
Давайте исправим эти ошибки, введя следующие значения:
• Название: Новая Япония
• ISO 3166-1 АЛЬФА-2 Код страны: Нью-Джерси.
• ISO 3166-1 АЛЬФА-3 Код страны: NJP.
Когда вы закончите, нажмите «Создать», чтобы создать новую страну. Если все работает так, как ожидалось,
Представление должно перенаправить нас к основному представлению «Страны».

Оттуда мы можем ввести «Новую Японию» в наш текстовый фильтр, чтобы убедиться, что наша совершенно новая страна действительно
там:

![image](https://github.com/artemovsergey/Angular/assets/26972859/3862954a-f997-43b9-aca7-4148fedb756b)

Вот! Это означает, что мы наконец закончили с CountryEditComponent и готовы перейти к
новые, увлекательные задания.

# Улучшение поведения фильтра
Фильтр реального времени, который мы внедрили в представлениях списков городов и стран, работает хорошо.
и должно быть очень полезно для наших пользователей: однако каждый раз, когда текст фильтра меняется (то есть при
каждое нажатие клавиши), Angular отправляет HTTP-запрос на серверную часть для получения обновленного списка результатов.
Такое поведение по своей сути является ресурсоемким и может легко стать огромной проблемой производительности.
особенно если мы имеем дело с большими таблицами и/или неиндексированными столбцами.
Есть ли способы улучшить этот подход без ущерба для результатов, полученных с точки зрения пользователя?
опыт? На самом деле, ответ — да, если мы готовы реализовать пару
широко используемые методы, специально предназначенные для повышения производительности исполняемого кода
неоднократно в течение короткого периода времени.

# Дросселирование и устранение дребезга
Если задуматься, наша повседневная жизнь полна ситуаций, когда мы вынуждены что-то делать, пока
наше внимание привлечено чем-то другим: социальными сетями, такими как Twitter, и приложениями для обмена мгновенными сообщениями.
такие как WhatsApp, являются прекрасным примером этого, поскольку они заваливают нас уведомлениями независимо от
что мы делаем.

Что мы обычно делаем в таких случаях? Рассмотрим следующие альтернативы:
- Отвечать на все уведомления в режиме реального времени, что было бы полезно для запрашивающей стороны, но
поставит под угрозу то, что мы делаем
- Не предпринимайте немедленных действий и проверяйте наши сообщения только раз в, скажем, пять минут.
- Не предпринимайте немедленных действий и проверяйте наши сообщения только тогда, когда не приходит новых уведомлений.
за последние пять минут
Первый подход — это то, что сейчас делает наше приложение; второй называется дросселированием, а третий
называется дебаунсингом. Давайте попробуем лучше понять, что на самом деле означают эти термины.

# Определения
В разработке программного обеспечения регулирование используется для определения поведения, обеспечивающего максимальное количество
сколько раз функция может быть вызвана с течением времени. Другими словами, это способ сказать: «Давайте выполним это».
функционировать не чаще одного раза каждые N миллисекунд». Независимо от того, сколько раз пользователь запускает событие, это
функция будет выполнена только один раз за заданный интервал времени.
Термин устранение дребезга используется для определения метода, который предотвращает вызов функции до тех пор, пока
прошло определенное количество времени, а его не вызывали: другими словами, это способ сказать: «давай
выполнять эту функцию только в том случае, если прошло N миллисекунд без ее вызова». Концепция имеет некоторые
сходство с техникой дросселирования, с важным отличием: неважно, сколько раз
пользователь запускает событие, прикрепленная функция будет выполнена только через указанное время после
пользователь перестает запускать событие.
В двух словах, мы можем сказать, что основное различие между регулированием и устранением дребезга заключается в том, что регулирование выполняет функцию через регулярные промежутки времени, тогда как устранение дребезга выполняет функцию только после
период охлаждения.

# Зачем нам ограничивать или снижать производительность нашего кода?
Давайте сократим это: в информационных технологиях дросселирование и устранение дребезга в основном полезны для двоих.
Основные причины: оптимизация и производительность. Они широко используются в JavaScript, поскольку их можно
очень полезно для эффективного решения некоторых ресурсоемких задач, связанных с DOM, таких как прокрутка и
изменение размера HTML-компонентов, а также получение данных с сервера.
В нашем данном сценарии мы можем думать о них как о двух способах оптимизации обработки событий, тем самым снимая некоторые
работать с нашего сервера (контроллера и базы данных): точнее, мы хотим найти способ уменьшить
HTTP-запросы, которые Angular в настоящее время отправляет нашему серверу при каждом нажатии клавиши.
Сделаем ли мы это, используя регулирование или устранение дребезга?
Если мы подумаем о том, как работает функция фильтра с точки зрения пользовательского опыта, мы легко сможем определить:
правильный ответ. Поскольку мы говорим о текстовом поле, которое можно использовать для фильтрации результатов листинга.
и тех, которые содержат один или несколько символов, набранных пользователем, мы можем разумно заключить, что мы
может отложить HTTP-запрос до тех пор, пока пользователь не перестанет печатать, при условии, что мы обработаем его сразу после этого.
Такое поведение не помешает пользовательскому опыту, предоставляемому текущим фильтром, но при этом не помешает хорошему результату.
количество ненужных HTTP-вызовов.

Другими словами, нам нужно отклонить наши вызовы на серверную часть: давайте посмотрим, как мы можем это сделать.

# Отказ от вызовов на серверную часть
Простой подход к устранению дребезжания с помощью Angular предлагает RxJS, реактивные расширения для JavaScript.
библиотека, которая позволяет нам использовать Observables, которые мы представили в главе 4, Front-End и Back-End.
Взаимодействия. Поскольку мы используем Observable для выполнения HTTP-вызова, мы уже на полпути: мы просто
нужно использовать удобный оператор debounceTime RxJS, который будет выдавать значение из источника
Наблюдается только по прошествии определенного периода времени без выбросов другого источника. В то время как мы
есть ли там, мы также можем воспользоваться возможностью добавить оператор DifferentUntilChanged, который
выдает значение, только если оно отличается от последнего, вставленного пользователем: это предотвратит любые HTTP-запросы.
вызов, идентичный предыдущему, который может произойти, например, если пользователь напишет предложение,
потом добавляет букву и тут же удаляет ее.

# Обновление компонента CitiesComponent
Чтобы реализовать такую логику, откройте файл /src/app/cities/cities.comComponent.ts и выполните
следующие изменения:

```ts
import { MatSort } from '@angular/material/sort';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
// ...existing code...
 @ViewChild(MatPaginator) paginator!: MatPaginator;
 @ViewChild(MatSort) sort!: MatSort;
 filterTextChanged: Subject<string> = new Subject<string>();
// ...existing code...
 ngOnInit() {
 this.loadData();
 }
 // debounce filter text changes
 onFilterTextChanged(filterText: string) {
 if (this.filterTextChanged.observers.length === 0) {
 this.filterTextChanged
 .pipe(debounceTime(1000), distinctUntilChanged())
.subscribe(query => {
 this.loadData(query);
 });
 }
 this.filterTextChanged.next(filterText);
 }
```

Как мы видим, мы вообще не трогали метод loadData, чтобы не испортить ничего, что
мы уже закончили; вместо этого мы добавили новый метод onFilterTextChanged, который будет называться
по входу фильтра и будет прозрачно решать задачу устранения дребезга.
Если мы внимательно посмотрим на метод onFilterTextChanged, то увидим, что он работает с новым
переменная filterTextChanged, которую мы также добавили в наш класс компонента: эта переменная содержит тему,
специальный тип Observable, который позволяет передавать значения многим наблюдателям.
В двух словах, вот что делает этот новый метод каждый раз, когда он вызывается методом ввода фильтра:
- Проверяет объект filterTextChanged, чтобы узнать, прослушивают ли наблюдатели; если нет
Наблюдатели пока пересылают операторы debounceTime и DifferentUntilChanged и добавляют новый
подписка на метод loadData
- Передает субъекту новое значение, которое будет рассылаться наблюдателям, зарегистрированным для прослушивания.
к этому

Хотя мы уже объяснили, что делают эти операторы, давайте еще раз кратко повторим их роль:
- debounceTime выдаст значение после 1000 миллисекунд отсутствия входных данных от источника.
Пользователь
- DifferentUntilChanged выдаст значение, только если оно отличается от последнего вставленного значения.
Теперь, когда мы реализовали логику устранения дребезга в классе Angular, нам просто нужно обновить
файл шаблона компонента, чтобы входные данные фильтра вместо этого вызывали новый метод onFilterTextChanged
из loadData.
Откройте файл /src/app/cities/cities.comComponent.html и примените следующие изменения:

```html
<mat-form-field [hidden]="!cities">
 <input matInput #filter (keyup)="onFilterTextChanged(filter.value)"
 placeholder="Filter by name (or part of it)...">
</mat-form-field>
```

# Обновление компонента Countrys
Прежде чем идти дальше, давайте обновим CountryComponent точно таким же образом. Это можно сделать
открыв следующие файлы:
- /src/app/countries/countries.comComponent.ts
- /src/app/countries/countries.comComponent.html
и применив те же изменения, что мы внесли в файлы CitiesComponent.

Задержка этих HTTP-запросов в этих двух компонентах исключит большинство ненужных HTTP-запросов.
исходит из нашего приложения Angular, что предотвращает быстрый вызов нашей базы данных снова и снова.

# А как насчет дросселирования?
На самом деле, в нашем приложении WorldCities Angular нет задач или функций, которые могли бы получить пользу от
дросселирование. Однако стоит отметить, что такой метод можно реализовать, используя тот же подход, который мы использовали для устранения дребезга, заменив оператор RxJS debounceTime на throttleTime.

# Краткое содержание
Эта глава была полностью посвящена формам Angular. Мы начали с выяснения, что же это за форма на самом деле
is и перечислил функции, которыми он должен обладать для выполнения своих обязанностей, сгруппировав их в две
Основные требования: обеспечение хорошего пользовательского опыта и правильная обработка предоставленных данных.
Затем мы сосредоточили внимание на платформе Angular и двух предлагаемых ею моделях проектирования форм:
Подход, основанный на шаблонах, в основном унаследованный от AngularJS, а также альтернатива, управляемая моделью или реактивная. Мы потратили некоторое драгоценное время, чтобы проанализировать плюсы и минусы каждого из них, а затем
мы провели детальное сравнение базовой логики и рабочего процесса. В конце дня мы
решил использовать реактивный способ ведения дел, поскольку он дает разработчику больше контроля и обеспечивает соблюдение
более последовательное разделение обязанностей между моделью данных и моделью формы.
Сразу после этого мы перешли от теории к практике, создав CityEditComponent и применив его для
реализовать полнофункциональную реактивную форму; мы также добавили проверку данных на стороне клиента и на сервере.

логику, эффективно используя синтаксис шаблона Angular в сочетании с классами и директивами.
предоставленный Angular ReactiveFormsModule.
Закончив, мы сделали то же самое с CountryEditComponent, воспользовавшись возможностью попробовать использовать
FormBuilder вместо экземпляров FormGroup/FormControl, которые мы использовали ранее.
После этого мы провели поверхностный тест в нашем браузере, чтобы проверить все встроенные и пользовательские валидаторы.
гарантируя, что они правильно работают как на внешнем, так и на внутреннем API.
И последнее, но не менее важное: мы потратили немало драгоценного времени на анализ некоторых проблем с производительностью нашего фильтра.
функцию и нашел способ смягчить их, внедрив технику устранения дребезга: это позволило
нам узнать, как использовать некоторые очень полезные функции библиотеки RxJS: Тема, debounceTime и
различныеUntilChanged.
В следующей главе мы собираемся усовершенствовать то, что мы уже сделали, путем рефакторинга некоторых грубых аспектов.
наших компонентов Angular лучше. Таким образом, мы научимся постобработке данных, добавлению
достойная обработка ошибок, реализация некоторой логики повторов для решения проблем с подключением, отладка нашей формы
с помощью клиентского отладчика Visual Studio и, что наиболее важно, выполнить несколько модульных тестов.

# Предлагаемые темы
Для получения дополнительной информации мы рекомендуем следующие темы: Формы на основе шаблонов, Формы на основе моделей, Реактивные формы, JSON, RFC 7578, RFC 1341, Уровень жизни URL, Уровень жизни HTML,
проверка данных, валидаторы Angular, пользовательские валидаторы, асинхронные валидаторы, регулярные выражения
(регулярное выражение), Angular каналы, FormBuilder, RxJS, Observables, оператор безопасной навигации (оператор Элвиса),
Операторы RxJS, Тема, debounceTime, throttleTime.


















































































































































